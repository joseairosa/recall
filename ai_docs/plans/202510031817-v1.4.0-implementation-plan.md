# v1.4.0 Implementation Plan: Memory Relationships

**Status:** Planning
**Created:** 2025-10-03
**Target Release:** v1.4.0
**Estimated Time:** 4-6 hours

---

## Overview

Implement **Memory Relationships** to enable linking related memories together, creating a knowledge graph for better context organization and discovery.

### Goals

1. Link related memories with typed relationships
2. Traverse memory graphs to discover connected context
3. Visualize memory relationships
4. Support bidirectional relationship queries
5. Handle relationship lifecycle (create, read, delete)

### Use Cases

- **Code Patterns:** Link implementation examples to their patterns
- **Decision Trees:** Connect decisions to their rationale and consequences
- **Problem-Solution:** Link errors to their solutions
- **Context Chains:** Build narrative flows across memories
- **Feature History:** Track feature evolution across related memories

---

## Technical Design

### Schema Changes

#### New Types (src/types.ts)

```typescript
// Relationship types
export enum RelationshipType {
  RELATES_TO = 'relates_to',      // Generic connection
  PARENT_OF = 'parent_of',         // Hierarchical (from is parent)
  CHILD_OF = 'child_of',           // Hierarchical (from is child)
  REFERENCES = 'references',       // From references to
  SUPERSEDES = 'supersedes',       // From replaces to
  IMPLEMENTS = 'implements',       // From implements to
  EXAMPLE_OF = 'example_of',       // From is example of to
}

// Memory relationship schema
export const MemoryRelationshipSchema = z.object({
  id: z.string().describe('Unique relationship identifier (ULID)'),
  from_memory_id: z.string().describe('Source memory ID'),
  to_memory_id: z.string().describe('Target memory ID'),
  relationship_type: z.nativeEnum(RelationshipType).describe('Type of relationship'),
  created_at: z.string().describe('ISO 8601 timestamp'),
  metadata: z.record(z.unknown()).optional().describe('Optional metadata'),
});

export type MemoryRelationship = z.infer<typeof MemoryRelationshipSchema>;

// Tool schemas
export const LinkMemoriesSchema = z.object({
  from_memory_id: z.string().describe('Source memory ID'),
  to_memory_id: z.string().describe('Target memory ID'),
  relationship_type: z.nativeEnum(RelationshipType).describe('Type of relationship'),
  metadata: z.record(z.unknown()).optional().describe('Optional metadata'),
});

export const GetRelatedMemoriesSchema = z.object({
  memory_id: z.string().describe('Memory ID to get relationships for'),
  relationship_types: z.array(z.nativeEnum(RelationshipType)).optional().describe('Filter by relationship types'),
  depth: z.number().min(1).max(5).default(1).describe('Traversal depth (1-5)'),
  direction: z.enum(['outgoing', 'incoming', 'both']).default('both').describe('Relationship direction'),
});

export const UnlinkMemoriesSchema = z.object({
  relationship_id: z.string().describe('Relationship ID to remove'),
});

export const GetMemoryGraphSchema = z.object({
  memory_id: z.string().describe('Root memory ID for graph'),
  max_depth: z.number().min(1).max(3).default(2).describe('Maximum graph depth'),
  max_nodes: z.number().min(1).max(100).default(50).describe('Maximum nodes to return'),
});
```

#### Redis Key Structure

```typescript
// Add to RedisKeys in src/types.ts
export const RedisKeys = {
  // ... existing keys

  // Relationships
  relationship: (workspace: string, id: string) => `ws:${workspace}:relationship:${id}`,
  relationships: (workspace: string) => `ws:${workspace}:relationships:all`,
  memoryRelationships: (workspace: string, memoryId: string) =>
    `ws:${workspace}:memory:${memoryId}:relationships`,
  memoryRelationshipsOut: (workspace: string, memoryId: string) =>
    `ws:${workspace}:memory:${memoryId}:relationships:out`,
  memoryRelationshipsIn: (workspace: string, memoryId: string) =>
    `ws:${workspace}:memory:${memoryId}:relationships:in`,

  // Global relationships
  globalRelationship: (id: string) => `global:relationship:${id}`,
  globalRelationships: () => `global:relationships:all`,
  globalMemoryRelationships: (memoryId: string) => `global:memory:${memoryId}:relationships`,
  globalMemoryRelationshipsOut: (memoryId: string) => `global:memory:${memoryId}:relationships:out`,
  globalMemoryRelationshipsIn: (memoryId: string) => `global:memory:${memoryId}:relationships:in`,
} as const;
```

### Storage Implementation (src/redis/memory-store.ts)

#### Create Relationship

```typescript
async createRelationship(
  fromMemoryId: string,
  toMemoryId: string,
  relationshipType: RelationshipType,
  metadata?: Record<string, unknown>
): Promise<MemoryRelationship> {
  // Validate both memories exist
  const fromMemory = await this.getMemory(fromMemoryId);
  const toMemory = await this.getMemory(toMemoryId);

  if (!fromMemory) {
    throw new Error(`Source memory not found: ${fromMemoryId}`);
  }
  if (!toMemory) {
    throw new Error(`Target memory not found: ${toMemoryId}`);
  }

  // Prevent self-references
  if (fromMemoryId === toMemoryId) {
    throw new Error('Cannot create relationship to self');
  }

  // Check if relationship already exists
  const existing = await this.findRelationship(fromMemoryId, toMemoryId, relationshipType);
  if (existing) {
    return existing; // Idempotent
  }

  const id = ulid();
  const relationship: MemoryRelationship = {
    id,
    from_memory_id: fromMemoryId,
    to_memory_id: toMemoryId,
    relationship_type: relationshipType,
    created_at: new Date().toISOString(),
    metadata,
  };

  // Determine if this is a global relationship (both memories are global)
  const isGlobal = fromMemory.is_global && toMemory.is_global;

  const pipeline = this.redis.pipeline();

  if (isGlobal) {
    pipeline.hset(RedisKeys.globalRelationship(id), relationship);
    pipeline.sadd(RedisKeys.globalRelationships(), id);
    pipeline.sadd(RedisKeys.globalMemoryRelationships(fromMemoryId), id);
    pipeline.sadd(RedisKeys.globalMemoryRelationshipsOut(fromMemoryId), id);
    pipeline.sadd(RedisKeys.globalMemoryRelationshipsIn(toMemoryId), id);
  } else {
    pipeline.hset(RedisKeys.relationship(this.workspaceId, id), relationship);
    pipeline.sadd(RedisKeys.relationships(this.workspaceId), id);
    pipeline.sadd(RedisKeys.memoryRelationships(this.workspaceId, fromMemoryId), id);
    pipeline.sadd(RedisKeys.memoryRelationshipsOut(this.workspaceId, fromMemoryId), id);
    pipeline.sadd(RedisKeys.memoryRelationshipsIn(this.workspaceId, toMemoryId), id);
  }

  await pipeline.exec();

  return relationship;
}
```

#### Get Related Memories

```typescript
async getRelatedMemories(
  memoryId: string,
  options: {
    relationshipTypes?: RelationshipType[];
    depth?: number;
    direction?: 'outgoing' | 'incoming' | 'both';
  } = {}
): Promise<Array<{ memory: MemoryEntry; relationship: MemoryRelationship; depth: number }>> {
  const { relationshipTypes, depth = 1, direction = 'both' } = options;

  const results: Array<{ memory: MemoryEntry; relationship: MemoryRelationship; depth: number }> = [];
  const visited = new Set<string>();

  await this.traverseGraph(memoryId, depth, visited, results, relationshipTypes, direction, 0);

  return results;
}

private async traverseGraph(
  memoryId: string,
  maxDepth: number,
  visited: Set<string>,
  results: Array<{ memory: MemoryEntry; relationship: MemoryRelationship; depth: number }>,
  relationshipTypes?: RelationshipType[],
  direction: 'outgoing' | 'incoming' | 'both' = 'both',
  currentDepth: number = 0
): Promise<void> {
  if (currentDepth >= maxDepth || visited.has(memoryId)) {
    return;
  }

  visited.add(memoryId);

  // Get relationships for this memory
  const relationships = await this.getMemoryRelationships(memoryId, direction);

  // Filter by type if specified
  const filtered = relationshipTypes
    ? relationships.filter(r => relationshipTypes.includes(r.relationship_type))
    : relationships;

  for (const relationship of filtered) {
    const relatedMemoryId =
      relationship.from_memory_id === memoryId
        ? relationship.to_memory_id
        : relationship.from_memory_id;

    if (!visited.has(relatedMemoryId)) {
      const memory = await this.getMemory(relatedMemoryId);
      if (memory) {
        results.push({
          memory,
          relationship,
          depth: currentDepth + 1,
        });

        // Recurse if not at max depth
        if (currentDepth + 1 < maxDepth) {
          await this.traverseGraph(
            relatedMemoryId,
            maxDepth,
            visited,
            results,
            relationshipTypes,
            direction,
            currentDepth + 1
          );
        }
      }
    }
  }
}
```

#### Delete Relationship

```typescript
async deleteRelationship(relationshipId: string): Promise<boolean> {
  const relationship = await this.getRelationship(relationshipId);
  if (!relationship) {
    return false;
  }

  // Check if global based on memories
  const fromMemory = await this.getMemory(relationship.from_memory_id);
  const isGlobal = fromMemory?.is_global || false;

  const pipeline = this.redis.pipeline();

  if (isGlobal) {
    pipeline.del(RedisKeys.globalRelationship(relationshipId));
    pipeline.srem(RedisKeys.globalRelationships(), relationshipId);
    pipeline.srem(RedisKeys.globalMemoryRelationships(relationship.from_memory_id), relationshipId);
    pipeline.srem(RedisKeys.globalMemoryRelationshipsOut(relationship.from_memory_id), relationshipId);
    pipeline.srem(RedisKeys.globalMemoryRelationshipsIn(relationship.to_memory_id), relationshipId);
  } else {
    pipeline.del(RedisKeys.relationship(this.workspaceId, relationshipId));
    pipeline.srem(RedisKeys.relationships(this.workspaceId), relationshipId);
    pipeline.srem(RedisKeys.memoryRelationships(this.workspaceId, relationship.from_memory_id), relationshipId);
    pipeline.srem(RedisKeys.memoryRelationshipsOut(this.workspaceId, relationship.from_memory_id), relationshipId);
    pipeline.srem(RedisKeys.memoryRelationshipsIn(this.workspaceId, relationship.to_memory_id), relationshipId);
  }

  await pipeline.exec();

  return true;
}
```

### New Tools (src/tools/relationship-tools.ts)

Create new file with 4 tools:

1. **`link_memories`** - Create relationship between memories
2. **`get_related_memories`** - Get related memories with traversal
3. **`unlink_memories`** - Remove relationship
4. **`get_memory_graph`** - Get full graph structure for visualization

### New Resources (src/resources/index.ts)

Add relationship resources:

- **`memory://relationships`** - List all relationships
- **`memory://memory/{id}/related`** - Get related memories
- **`memory://graph/{id}?depth=2`** - Get memory graph structure

### Global Relationship Support

Relationships inherit scope from memories:
- **Both memories global** → Global relationship
- **Either memory workspace** → Workspace relationship
- **Cannot link** global to workspace (throw error)

---

## Implementation Plan

### Phase 1: Schema & Types (1 hour)

- [ ] Add relationship types to src/types.ts
- [ ] Add relationship schemas (MemoryRelationship, LinkMemories, etc.)
- [ ] Add Redis key helpers for relationships
- [ ] Update exports

### Phase 2: Storage Layer (2 hours)

- [ ] Implement createRelationship() in MemoryStore
- [ ] Implement getRelationship() and getMemoryRelationships()
- [ ] Implement findRelationship() helper
- [ ] Implement deleteRelationship()
- [ ] Implement graph traversal (getRelatedMemories)
- [ ] Add circular reference protection
- [ ] Support global relationships

### Phase 3: Tools (1 hour)

- [ ] Create src/tools/relationship-tools.ts
- [ ] Implement link_memories tool
- [ ] Implement get_related_memories tool
- [ ] Implement unlink_memories tool
- [ ] Implement get_memory_graph tool
- [ ] Export from src/tools/index.ts

### Phase 4: Resources (30 min)

- [ ] Add memory://relationships resource
- [ ] Add memory://memory/{id}/related resource
- [ ] Add memory://graph/{id} resource

### Phase 5: Documentation (1 hour)

- [ ] Update README.md with relationship examples
- [ ] Update CHANGELOG.md for v1.4.0
- [ ] Create MEMORY_RELATIONSHIPS.md guide
- [ ] Update version to 1.4.0

### Phase 6: Testing & Polish (30 min)

- [ ] Build and verify TypeScript compilation
- [ ] Manual testing of relationship creation
- [ ] Test graph traversal
- [ ] Test global relationship support
- [ ] Verify circular reference handling

---

## Success Criteria

- [ ] Can create relationships between memories
- [ ] Can traverse relationships with depth control
- [ ] Can filter by relationship type
- [ ] Can delete relationships
- [ ] Supports bidirectional traversal (incoming/outgoing/both)
- [ ] Global relationships work correctly
- [ ] No breaking changes
- [ ] Documentation complete
- [ ] All TypeScript compiles without errors

---

## Example Usage

```typescript
// Link pattern to implementation
await linkMemories(
  "mem_pattern_123",
  "mem_implementation_456",
  RelationshipType.EXAMPLE_OF
);

// Get related memories
const related = await getRelatedMemories("mem_decision_789", {
  depth: 2,
  relationshipTypes: [RelationshipType.REFERENCES, RelationshipType.SUPERSEDES]
});

// Get full graph
const graph = await getMemoryGraph("mem_root", {
  max_depth: 3,
  max_nodes: 50
});
```

---

## Notes

- Keep depth limits (max 5) to prevent performance issues
- Use Sets for visited tracking to handle cycles
- Support both workspace and global relationships
- Relationship scope determined by memory scope (global + global = global)
- Consider future: relationship metadata for weights/notes
