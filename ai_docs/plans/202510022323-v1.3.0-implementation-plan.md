# v1.3.0 Implementation Plan - Global Memories & Core Enhancements

**Target Release Date:** 2 weeks from start
**Created:** 2025-10-02
**Status:** Planning

---

## Overview

Version 1.3.0 focuses on four major features that significantly enhance Recall's capabilities:

1. **Global Memories** - Cross-workspace memory support
2. **Memory Relationships** - Link and relate memories together
3. **Memory Versioning/History** - Track changes over time
4. **Smart Memory Suggestions** - AI-powered memory quality and detection

---

## Feature 1: Global Memories

### Goal
Enable memories that persist across all workspaces (e.g., personal preferences, team conventions) while maintaining the current workspace isolation model.

### Technical Design

#### Schema Changes

**Add to Memory Schema:**
```typescript
interface Memory {
  id: string;
  content: string;
  context_type: ContextType;
  importance: number;
  tags?: string[];
  metadata?: Record<string, unknown>;
  is_global: boolean;  // ← NEW FIELD (default: false)
  created_at: string;
  updated_at: string;
  workspace_id: string;  // empty string for global memories
  ttl_seconds?: number;
  embedding?: number[];
}
```

#### Redis Key Structure

**Current (v1.2.x):**
```
ws:{workspace_id}:memory:{id}
ws:{workspace_id}:embeddings
ws:{workspace_id}:tags:{tag}
ws:{workspace_id}:session:{id}
```

**New (v1.3.0):**
```
# Workspace memories (existing)
ws:{workspace_id}:memory:{id}
ws:{workspace_id}:embeddings
ws:{workspace_id}:tags:{tag}
ws:{workspace_id}:session:{id}

# Global memories (new)
global:memory:{id}
global:embeddings
global:tags:{tag}
```

#### Environment Variables

**Add `WORKSPACE_MODE`:**
```typescript
enum WorkspaceMode {
  ISOLATED = 'isolated',  // Default: workspace-only (current behavior)
  GLOBAL = 'global',      // All memories shared
  HYBRID = 'hybrid'       // Support both global + workspace
}

// Environment variable
process.env.WORKSPACE_MODE = 'hybrid'  // default: 'isolated'
```

#### New Tools

**1. `convert_to_global`**
```typescript
{
  name: "convert_to_global",
  description: "Convert a workspace-specific memory to global (available across all workspaces)",
  inputSchema: {
    type: "object",
    properties: {
      memory_id: {
        type: "string",
        description: "ID of the memory to convert to global"
      }
    },
    required: ["memory_id"]
  }
}
```

**2. `convert_to_workspace`**
```typescript
{
  name: "convert_to_workspace",
  description: "Convert a global memory to workspace-specific",
  inputSchema: {
    type: "object",
    properties: {
      memory_id: {
        type: "string",
        description: "ID of the global memory to convert"
      },
      workspace_id: {
        type: "string",
        description: "Target workspace (default: current workspace)"
      }
    },
    required: ["memory_id"]
  }
}
```

**3. Update `store_memory` schema:**
```typescript
// Add is_global to CreateMemorySchema
{
  is_global: {
    type: "boolean",
    description: "If true, memory is accessible across all workspaces (default: false)",
    default: false
  }
}
```

#### Search Logic Updates

**Hybrid Mode Search Strategy:**
```typescript
async search(query: string, limit: number): Promise<Memory[]> {
  const mode = process.env.WORKSPACE_MODE || 'isolated';

  let results: Memory[] = [];

  if (mode === 'isolated') {
    // Current behavior: workspace only
    results = await searchWorkspace(currentWorkspace, query, limit);
  }
  else if (mode === 'global') {
    // New: global only
    results = await searchGlobal(query, limit);
  }
  else if (mode === 'hybrid') {
    // New: both with weighting
    const workspaceResults = await searchWorkspace(currentWorkspace, query, limit);
    const globalResults = await searchGlobal(query, limit);

    // Weight global memories slightly lower (0.9x) to prefer local context
    globalResults.forEach(m => m.score *= 0.9);

    // Merge and sort by score
    results = [...workspaceResults, ...globalResults]
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);
  }

  return results;
}
```

#### Resources Updates

**Add global memory resources:**
```typescript
// New resources
memory://global/recent          // Recent global memories
memory://global/by-type/{type}  // Global memories by type
memory://global/by-tag/{tag}    // Global memories by tag
memory://global/important       // Important global memories
memory://global/search?q=query  // Search only global memories
```

#### Migration Path

**For existing users (v1.2.x → v1.3.0):**

1. **No breaking changes** - Default mode is `isolated` (current behavior)
2. **All existing memories remain workspace-scoped** - `is_global` defaults to `false`
3. **Opt-in to global memories** - Users choose when to use global memories
4. **Clear upgrade documentation** - Explain the new feature and how to use it

**Migration script (if needed):**
```typescript
// migrations/v1.3.0-add-global-flag.ts
async function migrateToV130() {
  // Scan all existing memories
  const allKeys = await redis.keys('ws:*:memory:*');

  for (const key of allKeys) {
    const memory = await redis.get(key);
    if (memory && !memory.hasOwnProperty('is_global')) {
      // Add is_global: false to existing memories
      memory.is_global = false;
      await redis.set(key, JSON.stringify(memory));
    }
  }

  console.log(`Migrated ${allKeys.length} memories to v1.3.0`);
}
```

### Implementation Steps

1. **Day 1-2: Schema & Storage**
   - [ ] Add `is_global` field to `CreateMemorySchema` in `src/types.ts`
   - [ ] Update `Memory` interface to include `is_global`
   - [ ] Add `WORKSPACE_MODE` environment variable parsing
   - [ ] Update Redis key generation logic in `src/redis/memory-store.ts`
   - [ ] Implement dual storage paths (workspace vs global)

2. **Day 3-4: Search Logic**
   - [ ] Update `search_memories` to support hybrid mode
   - [ ] Implement global memory search
   - [ ] Add score weighting for global memories
   - [ ] Update `recall_relevant_context` to include global memories

3. **Day 5-6: New Tools**
   - [ ] Implement `convert_to_global` tool
   - [ ] Implement `convert_to_workspace` tool
   - [ ] Update `store_memory` tool to support `is_global`
   - [ ] Update `update_memory` to handle is_global changes

4. **Day 7: Resources**
   - [ ] Add global memory resources
   - [ ] Update existing resources to respect workspace mode
   - [ ] Add filtering for global vs workspace

5. **Day 8: Testing**
   - [ ] Unit tests for global memory storage
   - [ ] Integration tests for hybrid search
   - [ ] Test conversion tools
   - [ ] Test migration script

6. **Day 9: Documentation**
   - [ ] Update README.md with global memory examples
   - [ ] Create migration guide
   - [ ] Update WORKSPACE_MODES.md
   - [ ] Add troubleshooting section

### Success Criteria

- [ ] Global memories work across all workspaces
- [ ] Workspace isolation remains intact in `isolated` mode
- [ ] Hybrid mode properly merges workspace + global results
- [ ] Conversion tools work bidirectionally
- [ ] No breaking changes for existing users
- [ ] All tests pass
- [ ] Documentation is complete

---

## Feature 2: Memory Relationships

### Goal
Enable users to link related memories together, creating a knowledge graph.

### Technical Design

#### Schema Changes

**Add relationship tracking:**
```typescript
interface MemoryRelationship {
  id: string;
  from_memory_id: string;
  to_memory_id: string;
  relationship_type: 'relates_to' | 'parent_of' | 'child_of' | 'references' | 'supersedes';
  created_at: string;
  metadata?: Record<string, unknown>;
}

// Add to Memory interface:
interface Memory {
  // ... existing fields
  related_memory_ids?: string[];  // Quick access to related IDs
}
```

#### Redis Storage

```
# Relationships
ws:{workspace_id}:relationship:{id}
ws:{workspace_id}:memory:{memory_id}:relationships  # Set of relationship IDs
```

#### New Tools

**1. `link_memories`**
```typescript
{
  name: "link_memories",
  description: "Create a relationship between two memories",
  inputSchema: {
    type: "object",
    properties: {
      from_memory_id: { type: "string" },
      to_memory_id: { type: "string" },
      relationship_type: {
        type: "string",
        enum: ["relates_to", "parent_of", "child_of", "references", "supersedes"]
      }
    },
    required: ["from_memory_id", "to_memory_id", "relationship_type"]
  }
}
```

**2. `get_related_memories`**
```typescript
{
  name: "get_related_memories",
  description: "Get all memories related to a given memory",
  inputSchema: {
    type: "object",
    properties: {
      memory_id: { type: "string" },
      relationship_types: {
        type: "array",
        items: { type: "string" }
      },
      depth: {
        type: "number",
        description: "How many levels deep to traverse (default: 1)",
        default: 1
      }
    },
    required: ["memory_id"]
  }
}
```

**3. `unlink_memories`**
```typescript
{
  name: "unlink_memories",
  description: "Remove a relationship between memories",
  inputSchema: {
    type: "object",
    properties: {
      relationship_id: { type: "string" }
    },
    required: ["relationship_id"]
  }
}
```

#### Graph Traversal

```typescript
async function getRelatedMemories(
  memoryId: string,
  depth: number = 1,
  visited: Set<string> = new Set()
): Promise<Memory[]> {

  if (depth === 0 || visited.has(memoryId)) {
    return [];
  }

  visited.add(memoryId);

  // Get immediate relationships
  const relationshipIds = await redis.smembers(
    `${prefix}:memory:${memoryId}:relationships`
  );

  const relationships = await Promise.all(
    relationshipIds.map(id => getRelationship(id))
  );

  const relatedMemoryIds = relationships.map(r =>
    r.from_memory_id === memoryId ? r.to_memory_id : r.from_memory_id
  );

  const memories = await Promise.all(
    relatedMemoryIds.map(id => getMemory(id))
  );

  // Recurse for deeper levels
  if (depth > 1) {
    const nestedMemories = await Promise.all(
      relatedMemoryIds.map(id =>
        getRelatedMemories(id, depth - 1, visited)
      )
    );

    memories.push(...nestedMemories.flat());
  }

  return memories;
}
```

### Implementation Steps

1. **Day 1-2: Schema & Storage**
   - [ ] Define `MemoryRelationship` interface
   - [ ] Create relationship storage in Redis
   - [ ] Update `Memory` to track relationships

2. **Day 3-4: Core Functions**
   - [ ] Implement `createRelationship()`
   - [ ] Implement `getRelationships()`
   - [ ] Implement `deleteRelationship()`
   - [ ] Implement graph traversal logic

3. **Day 5: Tools**
   - [ ] Create `link_memories` tool
   - [ ] Create `get_related_memories` tool
   - [ ] Create `unlink_memories` tool

4. **Day 6: Resources**
   - [ ] Add `memory://graph/{memory_id}` resource
   - [ ] Add relationship visualization data

5. **Day 7: Testing**
   - [ ] Unit tests for relationship CRUD
   - [ ] Graph traversal tests
   - [ ] Circular reference handling tests

### Success Criteria

- [ ] Can create relationships between memories
- [ ] Can retrieve related memories
- [ ] Graph traversal works correctly
- [ ] Handles circular references
- [ ] Relationships persist across sessions

---

## Feature 3: Memory Versioning/History

### Goal
Track all changes to memories over time, enabling rollback and audit trails.

### Technical Design

#### Schema Changes

**Add history tracking:**
```typescript
interface MemoryVersion {
  id: string;
  memory_id: string;
  version: number;
  content: string;
  importance: number;
  tags: string[];
  metadata: Record<string, unknown>;
  changed_at: string;
  changed_by?: string;  // Future: user tracking
  change_reason?: string;
}

// Update Memory interface:
interface Memory {
  // ... existing fields
  version: number;  // Current version number
  history_enabled: boolean;  // Can be disabled per memory
}
```

#### Redis Storage

```
# Version history
ws:{workspace_id}:memory:{memory_id}:history  # Sorted set by version
ws:{workspace_id}:memory:{memory_id}:version:{version}  # Version data
```

#### New Tools

**1. `get_memory_history`**
```typescript
{
  name: "get_memory_history",
  description: "Get version history for a memory",
  inputSchema: {
    type: "object",
    properties: {
      memory_id: { type: "string" },
      limit: { type: "number", default: 10 }
    },
    required: ["memory_id"]
  }
}
```

**2. `rollback_memory`**
```typescript
{
  name: "rollback_memory",
  description: "Rollback a memory to a previous version",
  inputSchema: {
    type: "object",
    properties: {
      memory_id: { type: "string" },
      version: { type: "number" }
    },
    required: ["memory_id", "version"]
  }
}
```

**3. `compare_memory_versions`**
```typescript
{
  name: "compare_memory_versions",
  description: "Compare two versions of a memory",
  inputSchema: {
    type: "object",
    properties: {
      memory_id: { type: "string" },
      version_a: { type: "number" },
      version_b: { type: "number" }
    },
    required: ["memory_id", "version_a", "version_b"]
  }
}
```

#### Version Storage Logic

```typescript
async function updateMemory(id: string, updates: Partial<Memory>) {
  const currentMemory = await getMemory(id);

  if (!currentMemory) {
    throw new Error('Memory not found');
  }

  // Save current version to history
  if (currentMemory.history_enabled !== false) {
    const version: MemoryVersion = {
      id: generateUlid(),
      memory_id: id,
      version: currentMemory.version,
      content: currentMemory.content,
      importance: currentMemory.importance,
      tags: currentMemory.tags,
      metadata: currentMemory.metadata,
      changed_at: new Date().toISOString()
    };

    await redis.zadd(
      `${prefix}:memory:${id}:history`,
      currentMemory.version,
      version.id
    );

    await redis.set(
      `${prefix}:memory:${id}:version:${currentMemory.version}`,
      JSON.stringify(version)
    );
  }

  // Apply updates with new version
  const updatedMemory = {
    ...currentMemory,
    ...updates,
    version: currentMemory.version + 1,
    updated_at: new Date().toISOString()
  };

  await redis.set(
    `${prefix}:memory:${id}`,
    JSON.stringify(updatedMemory)
  );

  return updatedMemory;
}
```

### Implementation Steps

1. **Day 1-2: Schema & Storage**
   - [ ] Define `MemoryVersion` interface
   - [ ] Add `version` and `history_enabled` to Memory
   - [ ] Implement version storage logic

2. **Day 3: Update Logic**
   - [ ] Modify `updateMemory()` to save history
   - [ ] Implement version retrieval
   - [ ] Add version cleanup (max versions)

3. **Day 4: Tools**
   - [ ] Create `get_memory_history` tool
   - [ ] Create `rollback_memory` tool
   - [ ] Create `compare_memory_versions` tool

4. **Day 5: Resources**
   - [ ] Add `memory://history/{memory_id}` resource
   - [ ] Add version diff formatting

5. **Day 6: Testing**
   - [ ] Version storage tests
   - [ ] Rollback tests
   - [ ] History retrieval tests

### Success Criteria

- [ ] All memory updates create version history
- [ ] Can retrieve full history
- [ ] Rollback works correctly
- [ ] Version comparison shows diffs
- [ ] History doesn't impact performance significantly

---

## Feature 4: Smart Memory Suggestions

### Goal
Use AI to detect when conversation contains memorable content and suggest storing it.

### Technical Design

#### Quality Scoring System

```typescript
interface MemoryQualityScore {
  score: number;  // 0-10
  confidence: number;  // 0-1
  reasons: string[];
  suggested_importance: number;
  suggested_type: ContextType;
  suggested_tags: string[];
}

async function scoreMemoryQuality(content: string, context: string): Promise<MemoryQualityScore> {
  // Use Claude to analyze
  const prompt = `
  Analyze this content for memory quality:

  Content: ${content}
  Context: ${context}

  Evaluate:
  1. Is this information worth remembering? (0-10)
  2. What type of information is this? (directive/decision/pattern/etc)
  3. How important is it? (1-10)
  4. What tags describe it?
  5. Why should/shouldn't this be remembered?

  Return JSON: { score, confidence, reasons, suggested_importance, suggested_type, suggested_tags }
  `;

  const response = await anthropic.messages.create({
    model: 'claude-haiku-3-5',
    max_tokens: 500,
    messages: [{ role: 'user', content: prompt }]
  });

  return JSON.parse(response.content[0].text);
}
```

#### Duplicate Detection

```typescript
async function checkForDuplicates(content: string): Promise<Memory[]> {
  // Search for similar existing memories
  const results = await searchMemories(content, 5);

  // Filter to high similarity
  return results.filter(m => m.similarity > 0.85);
}
```

#### New Tool

**`suggest_memories`**
```typescript
{
  name: "suggest_memories",
  description: "Analyze conversation and suggest what should be remembered",
  inputSchema: {
    type: "object",
    properties: {
      conversation_text: {
        type: "string",
        description: "Recent conversation to analyze"
      },
      min_quality_score: {
        type: "number",
        default: 7,
        description: "Minimum quality score to suggest (0-10)"
      }
    },
    required: ["conversation_text"]
  }
}
```

#### Proactive Suggestion Logic

```typescript
async function analyzConversationForMemories(text: string): Promise<MemorySuggestion[]> {
  const suggestions: MemorySuggestion[] = [];

  // Extract potential memories
  const prompt = `
  Extract memorable information from this conversation:

  ${text}

  Return JSON array of:
  - content: what to remember
  - context: why it's important
  - snippet: relevant excerpt
  `;

  const response = await anthropic.messages.create({
    model: 'claude-haiku-3-5',
    max_tokens: 2000,
    messages: [{ role: 'user', content: prompt }]
  });

  const potentialMemories = JSON.parse(response.content[0].text);

  for (const potential of potentialMemories) {
    // Score quality
    const quality = await scoreMemoryQuality(potential.content, potential.context);

    // Check duplicates
    const duplicates = await checkForDuplicates(potential.content);

    if (quality.score >= 7 && duplicates.length === 0) {
      suggestions.push({
        ...potential,
        quality,
        is_duplicate: false
      });
    } else if (duplicates.length > 0) {
      suggestions.push({
        ...potential,
        quality,
        is_duplicate: true,
        existing_memories: duplicates
      });
    }
  }

  return suggestions;
}
```

### Implementation Steps

1. **Day 1-2: Quality Scoring**
   - [ ] Implement Claude-based quality scoring
   - [ ] Create scoring prompt template
   - [ ] Test scoring accuracy

2. **Day 3: Duplicate Detection**
   - [ ] Implement similarity checking
   - [ ] Add configurable thresholds
   - [ ] Test duplicate identification

3. **Day 4: Suggestion Tool**
   - [ ] Create `suggest_memories` tool
   - [ ] Implement conversation analysis
   - [ ] Format suggestions for user

4. **Day 5: Integration**
   - [ ] Add suggestions to `analyze_and_remember`
   - [ ] Create prompt for proactive suggestions
   - [ ] Add user confirmation flow

5. **Day 6: Testing**
   - [ ] Test quality scoring accuracy
   - [ ] Test duplicate detection
   - [ ] Test suggestion formatting

### Success Criteria

- [ ] Accurately identifies memorable content
- [ ] Detects duplicates reliably
- [ ] Suggestions are helpful (not noisy)
- [ ] Performance is acceptable (<2s)
- [ ] User can accept/reject suggestions

---

## Testing Strategy

### Unit Tests

```typescript
// Global Memories
describe('Global Memories', () => {
  test('stores global memory correctly', async () => {});
  test('searches global memories in hybrid mode', async () => {});
  test('converts workspace to global', async () => {});
  test('weights global memories appropriately', async () => {});
});

// Relationships
describe('Memory Relationships', () => {
  test('creates relationship between memories', async () => {});
  test('retrieves related memories', async () => {});
  test('traverses graph correctly', async () => {});
  test('handles circular references', async () => {});
});

// Versioning
describe('Memory Versioning', () => {
  test('creates version on update', async () => {});
  test('retrieves history', async () => {});
  test('rolls back to previous version', async () => {});
  test('compares versions', async () => {});
});

// Suggestions
describe('Smart Suggestions', () => {
  test('scores memory quality', async () => {});
  test('detects duplicates', async () => {});
  test('suggests memorable content', async () => {});
});
```

### Integration Tests

```typescript
describe('v1.3.0 Integration', () => {
  test('global memories work across workspaces', async () => {});
  test('relationships persist with versioning', async () => {});
  test('suggestions respect existing memories', async () => {});
  test('all features work together', async () => {});
});
```

### Performance Tests

```typescript
describe('Performance', () => {
  test('global search completes in <500ms', async () => {});
  test('relationship traversal scales', async () => {});
  test('version history doesn\'t slow updates', async () => {});
  test('quality scoring completes in <2s', async () => {});
});
```

---

## Documentation Updates

### README.md

- [ ] Add global memories section with examples
- [ ] Document memory relationships with use cases
- [ ] Explain version history feature
- [ ] Show smart suggestions in action

### New Docs

- [ ] `GLOBAL_MEMORIES.md` - Detailed guide on workspace modes
- [ ] `RELATIONSHIPS.md` - Building knowledge graphs
- [ ] `VERSIONING.md` - History and rollback guide

### CHANGELOG.md

```markdown
## [1.3.0] - 2025-10-XX

### Added
- **Global Memories** - Cross-workspace memory support with `is_global` flag
- **Memory Relationships** - Link memories together to build knowledge graphs
- **Memory Versioning** - Full history tracking with rollback capability
- **Smart Suggestions** - AI-powered memory quality scoring and duplicate detection
- New tools: `convert_to_global`, `convert_to_workspace`, `link_memories`, `get_related_memories`, `get_memory_history`, `rollback_memory`, `suggest_memories`
- New resources: `memory://global/*`, `memory://graph/{id}`, `memory://history/{id}`
- `WORKSPACE_MODE` environment variable (isolated/global/hybrid)

### Changed
- Search now respects workspace mode configuration
- Memory schema includes `is_global`, `version`, and `related_memory_ids` fields

### Migration
- All existing memories remain workspace-isolated (no breaking changes)
- New `is_global` field defaults to `false`
- Run migration script if needed: `npm run migrate:v1.3.0`
```

---

## Release Checklist

- [ ] All features implemented and tested
- [ ] Unit tests pass (coverage >80%)
- [ ] Integration tests pass
- [ ] Performance benchmarks acceptable
- [ ] Documentation updated
- [ ] CHANGELOG.md updated
- [ ] Migration guide created
- [ ] Version bumped to 1.3.0
- [ ] Built and tested locally
- [ ] PR created and reviewed
- [ ] Merged to main
- [ ] Published to npm
- [ ] GitHub release created
- [ ] Announcement posted

---

## Risk Assessment

### High Risk
- **Breaking changes accidentally introduced**
  - Mitigation: Comprehensive testing, default to `isolated` mode

- **Performance degradation with global search**
  - Mitigation: Benchmark and optimize, add caching

### Medium Risk
- **Circular reference issues in relationships**
  - Mitigation: Implement cycle detection, depth limits

- **Version history consuming too much Redis memory**
  - Mitigation: Configurable max versions, compression

### Low Risk
- **AI quality scoring inaccuracy**
  - Mitigation: Tunable thresholds, user feedback loop

---

## Post-Release

### Monitoring
- [ ] Track adoption of global memories
- [ ] Monitor relationship usage patterns
- [ ] Check version history storage growth
- [ ] Measure suggestion acceptance rate

### Feedback Collection
- [ ] GitHub issues for bugs
- [ ] Discord discussion for feedback
- [ ] Usage analytics (opt-in)
- [ ] User interviews

### Next Steps
- [ ] Plan v1.4.0 based on feedback
- [ ] Address any critical issues
- [ ] Iterate on AI suggestions
- [ ] Consider UI for relationships

---

*Implementation Plan by José Airosa - Last Updated: 2025-10-02*
