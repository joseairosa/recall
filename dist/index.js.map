{"version":3,"sources":["../src/index.ts","../src/redis/client.ts","../src/tools/index.ts","../src/redis/memory-store.ts","../src/embeddings/generator.ts","../src/types.ts","../src/tools/context-tools.ts","../src/analysis/conversation-analyzer.ts","../src/tools/export-import-tools.ts","../src/resources/index.ts","../src/resources/analytics.ts","../src/prompts/formatters.ts","../src/prompts/index.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  ReadResourceRequestSchema,\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport { checkRedisConnection, closeRedisClient } from './redis/client.js';\nimport { tools } from './tools/index.js';\nimport { resources } from './resources/index.js';\nimport { listPrompts, getPrompt } from './prompts/index.js';\n\n// Create server instance\nconst server = new Server(\n  {\n    name: '@joseairosa/recall',\n    version: '1.2.1',\n  },\n  {\n    capabilities: {\n      resources: {},\n      tools: {},\n      prompts: {},\n    },\n  }\n);\n\n// List available tools\nserver.setRequestHandler(ListToolsRequestSchema, async () => {\n  return {\n    tools: Object.entries(tools).map(([name, tool]) => ({\n      name,\n      description: tool.description,\n      inputSchema: tool.inputSchema,\n    })),\n  };\n});\n\n// Handle tool calls\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  const { name, arguments: args } = request.params;\n\n  const tool = tools[name as keyof typeof tools];\n  if (!tool) {\n    throw new Error(`Unknown tool: ${name}`);\n  }\n\n  return await tool.handler(args as any);\n});\n\n// List available resources\nserver.setRequestHandler(ListResourcesRequestSchema, async () => {\n  return {\n    resources: [\n      {\n        uri: 'memory://recent',\n        name: 'Recent Memories',\n        description: 'Get the most recent memories (default: 50)',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://by-type/{type}',\n        name: 'Memories by Type',\n        description: 'Get memories filtered by context type (directive, information, heading, decision, code_pattern, requirement, error, todo, insight, preference)',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://by-tag/{tag}',\n        name: 'Memories by Tag',\n        description: 'Get memories filtered by tag',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://important',\n        name: 'Important Memories',\n        description: 'Get high-importance memories (importance >= 8)',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://session/{session_id}',\n        name: 'Session Memories',\n        description: 'Get all memories in a specific session',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://sessions',\n        name: 'All Sessions',\n        description: 'Get list of all sessions',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://summary',\n        name: 'Memory Summary',\n        description: 'Get overall summary statistics',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://search',\n        name: 'Search Memories',\n        description: 'Search memories using semantic similarity. Requires query parameter \"q\"',\n        mimeType: 'application/json',\n      },\n    ],\n  };\n});\n\n// Handle resource reads\nserver.setRequestHandler(ReadResourceRequestSchema, async (request) => {\n  const uriString = request.params.uri;\n  const uri = new URL(uriString);\n\n  // For memory:// URIs, resource name is hostname + pathname\n  const resourcePath = uri.hostname + uri.pathname;\n\n  // Match resource patterns\n  if (resourcePath === 'recent') {\n    return await resources['memory://recent'].handler(uri);\n  }\n\n  if (resourcePath === 'important') {\n    return await resources['memory://important'].handler(uri);\n  }\n\n  if (resourcePath === 'sessions') {\n    return await resources['memory://sessions'].handler(uri);\n  }\n\n  if (resourcePath === 'summary') {\n    return await resources['memory://summary'].handler(uri);\n  }\n\n  if (resourcePath === 'search') {\n    return await resources['memory://search'].handler(uri);\n  }\n\n  if (resourcePath === 'analytics') {\n    return await resources['memory://analytics'].handler(uri);\n  }\n\n  // Pattern matching for parameterized resources\n  const typeMatch = resourcePath.match(/^by-type\\/(.+)$/);\n  if (typeMatch) {\n    return await resources['memory://by-type/{type}'].handler(uri, { type: typeMatch[1] });\n  }\n\n  const tagMatch = resourcePath.match(/^by-tag\\/(.+)$/);\n  if (tagMatch) {\n    return await resources['memory://by-tag/{tag}'].handler(uri, { tag: tagMatch[1] });\n  }\n\n  const sessionMatch = resourcePath.match(/^session\\/(.+)$/);\n  if (sessionMatch) {\n    return await resources['memory://session/{session_id}'].handler(uri, { session_id: sessionMatch[1] });\n  }\n\n  throw new Error(`Unknown resource: ${request.params.uri}`);\n});\n\n// List available prompts\nserver.setRequestHandler(ListPromptsRequestSchema, async () => {\n  const promptsList = await listPrompts();\n  return {\n    prompts: promptsList,\n  };\n});\n\n// Get prompt\nserver.setRequestHandler(GetPromptRequestSchema, async (request) => {\n  const promptResult = await getPrompt(request.params.name);\n  return promptResult;\n});\n\n// Start server\nasync function main() {\n  // Check Redis connection\n  console.error('Checking Redis connection...');\n  const isConnected = await checkRedisConnection();\n\n  if (!isConnected) {\n    console.error('ERROR: Failed to connect to Redis');\n    console.error('Please ensure Redis is running and REDIS_URL is set correctly');\n    process.exit(1);\n  }\n\n  console.error('Redis connection successful');\n\n  // Create transport\n  const transport = new StdioServerTransport();\n\n  // Connect server to transport\n  await server.connect(transport);\n\n  console.error('Recall MCP Server started successfully');\n  console.error('Listening on stdio...');\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.error('\\nShutting down...');\n  await closeRedisClient();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  console.error('\\nShutting down...');\n  await closeRedisClient();\n  process.exit(0);\n});\n\n// Start the server\nmain().catch((error) => {\n  console.error('Fatal error:', error);\n  process.exit(1);\n});\n","import Redis from 'ioredis';\n\nlet redisClient: Redis | null = null;\n\nexport function getRedisClient(): Redis {\n  if (!redisClient) {\n    const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';\n\n    redisClient = new Redis(redisUrl, {\n      maxRetriesPerRequest: 3,\n      retryStrategy(times) {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      reconnectOnError(err) {\n        const targetError = 'READONLY';\n        if (err.message.includes(targetError)) {\n          // Reconnect on READONLY errors\n          return true;\n        }\n        return false;\n      },\n    });\n\n    redisClient.on('error', (err) => {\n      console.error('Redis Client Error:', err);\n    });\n\n    redisClient.on('connect', () => {\n      console.error('Redis Client Connected');\n    });\n\n    redisClient.on('ready', () => {\n      console.error('Redis Client Ready');\n    });\n  }\n\n  return redisClient;\n}\n\nexport async function closeRedisClient(): Promise<void> {\n  if (redisClient) {\n    await redisClient.quit();\n    redisClient = null;\n  }\n}\n\n// Health check\nexport async function checkRedisConnection(): Promise<boolean> {\n  try {\n    const client = getRedisClient();\n    const result = await client.ping();\n    return result === 'PONG';\n  } catch (error) {\n    console.error('Redis connection check failed:', error);\n    return false;\n  }\n}\n","import { z } from 'zod';\nimport { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport {\n  CreateMemorySchema,\n  BatchCreateMemoriesSchema,\n  UpdateMemorySchema,\n  DeleteMemorySchema,\n  SearchMemorySchema,\n  OrganizeSessionSchema,\n  ConvertToGlobalSchema,\n  ConvertToWorkspaceSchema,\n} from '../types.js';\nimport {\n  recall_relevant_context,\n  analyze_and_remember,\n  summarize_session,\n} from './context-tools.js';\nimport {\n  exportMemories,\n  importMemories,\n  findDuplicates,\n  consolidateMemories,\n} from './export-import-tools.js';\nimport {\n  ExportMemoriesSchema,\n  ImportMemoriesSchema,\n  FindDuplicatesSchema,\n  ConsolidateMemoriesSchema,\n} from '../types.js';\n\nconst memoryStore = new MemoryStore();\n\nexport const tools = {\n  // Context management tools\n  recall_relevant_context,\n  analyze_and_remember,\n  summarize_session,\n\n  // Export/Import tools\n  export_memories: {\n    description: 'Export memories to JSON format with optional filtering',\n    inputSchema: zodToJsonSchema(ExportMemoriesSchema),\n    handler: async (args: z.infer<typeof ExportMemoriesSchema>) => {\n      try {\n        return await exportMemories(args);\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to export memories: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  import_memories: {\n    description: 'Import memories from JSON export data',\n    inputSchema: zodToJsonSchema(ImportMemoriesSchema),\n    handler: async (args: z.infer<typeof ImportMemoriesSchema>) => {\n      try {\n        return await importMemories(args);\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to import memories: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  find_duplicates: {\n    description: 'Find and optionally merge duplicate memories based on similarity',\n    inputSchema: zodToJsonSchema(FindDuplicatesSchema),\n    handler: async (args: z.infer<typeof FindDuplicatesSchema>) => {\n      try {\n        return await findDuplicates(args);\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to find duplicates: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  consolidate_memories: {\n    description: 'Manually consolidate multiple memories into one',\n    inputSchema: zodToJsonSchema(ConsolidateMemoriesSchema),\n    handler: async (args: z.infer<typeof ConsolidateMemoriesSchema>) => {\n      try {\n        return await consolidateMemories(args);\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to consolidate memories: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  // Original memory tools\n  store_memory: {\n    description: 'Store a new memory/context entry for long-term persistence',\n    inputSchema: zodToJsonSchema(CreateMemorySchema),\n    handler: async (args: z.infer<typeof CreateMemorySchema>) => {\n      try {\n        const memory = await memoryStore.createMemory(args);\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                memory_id: memory.id,\n                timestamp: memory.timestamp,\n                summary: memory.summary,\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to store memory: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  store_batch_memories: {\n    description: 'Store multiple memories in a batch operation',\n    inputSchema: zodToJsonSchema(BatchCreateMemoriesSchema),\n    handler: async (args: z.infer<typeof BatchCreateMemoriesSchema>) => {\n      try {\n        const memories = await memoryStore.createMemories(args.memories);\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                count: memories.length,\n                memory_ids: memories.map(m => m.id),\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to store memories: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  update_memory: {\n    description: 'Update an existing memory entry',\n    inputSchema: zodToJsonSchema(UpdateMemorySchema),\n    handler: async (args: z.infer<typeof UpdateMemorySchema>) => {\n      try {\n        const { memory_id, ...updates } = args;\n        const memory = await memoryStore.updateMemory(memory_id, updates);\n\n        if (!memory) {\n          throw new McpError(ErrorCode.InvalidRequest, `Memory ${memory_id} not found`);\n        }\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                memory_id: memory.id,\n                updated_at: Date.now(),\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to update memory: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  delete_memory: {\n    description: 'Delete a memory entry',\n    inputSchema: zodToJsonSchema(DeleteMemorySchema),\n    handler: async (args: z.infer<typeof DeleteMemorySchema>) => {\n      try {\n        const success = await memoryStore.deleteMemory(args.memory_id);\n\n        if (!success) {\n          throw new McpError(ErrorCode.InvalidRequest, `Memory ${args.memory_id} not found`);\n        }\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                memory_id: args.memory_id,\n                deleted_at: Date.now(),\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to delete memory: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  search_memories: {\n    description: 'Search memories using semantic similarity',\n    inputSchema: zodToJsonSchema(SearchMemorySchema),\n    handler: async (args: z.infer<typeof SearchMemorySchema>) => {\n      try {\n        const results = await memoryStore.searchMemories(\n          args.query,\n          args.limit,\n          args.min_importance,\n          args.context_types\n        );\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                query: args.query,\n                count: results.length,\n                results: results.map(r => ({\n                  memory_id: r.id,\n                  content: r.content,\n                  summary: r.summary,\n                  context_type: r.context_type,\n                  importance: r.importance,\n                  tags: r.tags,\n                  similarity: r.similarity,\n                  timestamp: r.timestamp,\n                })),\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to search memories: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  organize_session: {\n    description: 'Create a session snapshot grouping related memories',\n    inputSchema: zodToJsonSchema(OrganizeSessionSchema),\n    handler: async (args: z.infer<typeof OrganizeSessionSchema>) => {\n      try {\n        const session = await memoryStore.createSession(\n          args.session_name,\n          args.memory_ids,\n          args.summary\n        );\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                session_id: session.session_id,\n                session_name: session.session_name,\n                memory_count: session.memory_count,\n                created_at: session.created_at,\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to organize session: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  // Global memory conversion tools\n  convert_to_global: {\n    description: 'Convert a workspace-specific memory to global (accessible across all workspaces)',\n    inputSchema: zodToJsonSchema(ConvertToGlobalSchema),\n    handler: async (args: z.infer<typeof ConvertToGlobalSchema>) => {\n      try {\n        const result = await memoryStore.convertToGlobal(args.memory_id);\n\n        if (!result) {\n          throw new McpError(\n            ErrorCode.InvalidRequest,\n            `Memory not found: ${args.memory_id}`\n          );\n        }\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                memory_id: result.id,\n                is_global: result.is_global,\n                content: result.content,\n                message: 'Memory converted to global successfully',\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to convert memory to global: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  convert_to_workspace: {\n    description: 'Convert a global memory to workspace-specific',\n    inputSchema: zodToJsonSchema(ConvertToWorkspaceSchema),\n    handler: async (args: z.infer<typeof ConvertToWorkspaceSchema>) => {\n      try {\n        const result = await memoryStore.convertToWorkspace(\n          args.memory_id,\n          args.workspace_id\n        );\n\n        if (!result) {\n          throw new McpError(\n            ErrorCode.InvalidRequest,\n            `Memory not found: ${args.memory_id}`\n          );\n        }\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                memory_id: result.id,\n                is_global: result.is_global,\n                workspace_id: result.workspace_id,\n                content: result.content,\n                message: 'Memory converted to workspace-specific successfully',\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to convert memory to workspace: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n};\n\n// Helper function to convert Zod schema to JSON Schema\nfunction zodToJsonSchema(schema: z.ZodType): any {\n  // Simple conversion - in production you'd use @anatine/zod-to-json-schema\n  if (schema instanceof z.ZodObject) {\n    const shape = schema._def.shape();\n    const properties: any = {};\n    const required: string[] = [];\n\n    for (const [key, value] of Object.entries(shape)) {\n      properties[key] = zodToJsonSchemaInner(value as z.ZodType);\n      if (!(value as any).isOptional()) {\n        required.push(key);\n      }\n    }\n\n    return {\n      type: 'object',\n      properties,\n      required,\n    };\n  }\n\n  return zodToJsonSchemaInner(schema);\n}\n\nfunction zodToJsonSchemaInner(schema: z.ZodType): any {\n  if (schema instanceof z.ZodString) {\n    const result: any = { type: 'string' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodNumber) {\n    const result: any = { type: 'number' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodBoolean) {\n    const result: any = { type: 'boolean' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodArray) {\n    const result: any = {\n      type: 'array',\n      items: zodToJsonSchemaInner(schema.element),\n    };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodEnum) {\n    const result: any = {\n      type: 'string',\n      enum: schema.options,\n    };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodOptional) {\n    return zodToJsonSchemaInner(schema.unwrap());\n  }\n\n  if (schema instanceof z.ZodDefault) {\n    const inner = zodToJsonSchemaInner(schema._def.innerType);\n    inner.default = schema._def.defaultValue();\n    return inner;\n  }\n\n  if (schema instanceof z.ZodObject) {\n    return zodToJsonSchema(schema);\n  }\n\n  return { type: 'string' };\n}\n","import { ulid } from 'ulid';\nimport type { Redis } from 'ioredis';\nimport { getRedisClient } from './client.js';\nimport { generateEmbedding, cosineSimilarity } from '../embeddings/generator.js';\nimport { RedisKeys, createWorkspaceId, getWorkspaceMode, WorkspaceMode, type MemoryEntry, type CreateMemory, type SessionInfo, type ContextType } from '../types.js';\n\nexport class MemoryStore {\n  private redis: Redis;\n  private workspaceId: string;\n  private workspacePath: string;\n\n  constructor(workspacePath?: string) {\n    this.redis = getRedisClient();\n    this.workspacePath = workspacePath || process.cwd();\n    this.workspaceId = createWorkspaceId(this.workspacePath);\n\n    // Log workspace info for debugging\n    console.error(`[MemoryStore] Workspace: ${this.workspacePath}`);\n    console.error(`[MemoryStore] Workspace ID: ${this.workspaceId}`);\n  }\n\n  // Store a new memory\n  async createMemory(data: CreateMemory): Promise<MemoryEntry> {\n    const id = ulid();\n    const timestamp = Date.now();\n\n    // Generate embedding for the content\n    const embedding = await generateEmbedding(data.content);\n\n    // Auto-generate summary if not provided\n    const summary = data.summary || this.generateSummary(data.content);\n\n    // Calculate expiration if TTL provided\n    let expiresAt: number | undefined;\n    if (data.ttl_seconds) {\n      expiresAt = timestamp + (data.ttl_seconds * 1000);\n    }\n\n    const isGlobal = data.is_global || false;\n\n    const memory: MemoryEntry = {\n      id,\n      timestamp,\n      context_type: data.context_type,\n      content: data.content,\n      summary,\n      tags: data.tags,\n      importance: data.importance,\n      session_id: data.session_id,\n      embedding,\n      ttl_seconds: data.ttl_seconds,\n      expires_at: expiresAt,\n      is_global: isGlobal,\n      workspace_id: isGlobal ? '' : this.workspaceId,\n    };\n\n    // Store in Redis (workspace or global based on is_global flag)\n    const pipeline = this.redis.pipeline();\n\n    // Main memory hash\n    const memoryKey = isGlobal\n      ? RedisKeys.globalMemory(id)\n      : RedisKeys.memory(this.workspaceId, id);\n\n    pipeline.hset(memoryKey, this.serializeMemory(memory));\n\n    // Set TTL on the hash if specified\n    if (data.ttl_seconds) {\n      pipeline.expire(memoryKey, data.ttl_seconds);\n    }\n\n    // Add to global set\n    if (isGlobal) {\n      pipeline.sadd(RedisKeys.globalMemories(), id);\n      pipeline.zadd(RedisKeys.globalTimeline(), timestamp, id);\n      pipeline.sadd(RedisKeys.globalByType(data.context_type), id);\n\n      for (const tag of data.tags) {\n        pipeline.sadd(RedisKeys.globalByTag(tag), id);\n      }\n\n      if (data.importance >= 8) {\n        pipeline.zadd(RedisKeys.globalImportant(), data.importance, id);\n      }\n    } else {\n      pipeline.sadd(RedisKeys.memories(this.workspaceId), id);\n      pipeline.zadd(RedisKeys.timeline(this.workspaceId), timestamp, id);\n      pipeline.sadd(RedisKeys.byType(this.workspaceId, data.context_type), id);\n\n      for (const tag of data.tags) {\n        pipeline.sadd(RedisKeys.byTag(this.workspaceId, tag), id);\n      }\n\n      if (data.importance >= 8) {\n        pipeline.zadd(RedisKeys.important(this.workspaceId), data.importance, id);\n      }\n    }\n\n    await pipeline.exec();\n\n    return memory;\n  }\n\n  // Batch create memories\n  async createMemories(memories: CreateMemory[]): Promise<MemoryEntry[]> {\n    const results: MemoryEntry[] = [];\n\n    for (const memoryData of memories) {\n      const memory = await this.createMemory(memoryData);\n      results.push(memory);\n    }\n\n    return results;\n  }\n\n  // Get memory by ID (checks both workspace and global)\n  async getMemory(id: string, isGlobal?: boolean): Promise<MemoryEntry | null> {\n    // If we know it's global, check global first\n    if (isGlobal === true) {\n      const globalData = await this.redis.hgetall(RedisKeys.globalMemory(id));\n      if (globalData && Object.keys(globalData).length > 0) {\n        return this.deserializeMemory(globalData);\n      }\n      return null;\n    }\n\n    // If we know it's workspace, check workspace only\n    if (isGlobal === false) {\n      const wsData = await this.redis.hgetall(RedisKeys.memory(this.workspaceId, id));\n      if (wsData && Object.keys(wsData).length > 0) {\n        return this.deserializeMemory(wsData);\n      }\n      return null;\n    }\n\n    // If unknown, check workspace first, then global\n    const wsData = await this.redis.hgetall(RedisKeys.memory(this.workspaceId, id));\n    if (wsData && Object.keys(wsData).length > 0) {\n      return this.deserializeMemory(wsData);\n    }\n\n    const globalData = await this.redis.hgetall(RedisKeys.globalMemory(id));\n    if (globalData && Object.keys(globalData).length > 0) {\n      return this.deserializeMemory(globalData);\n    }\n\n    return null;\n  }\n\n  // Get multiple memories by IDs\n  async getMemories(ids: string[]): Promise<MemoryEntry[]> {\n    const memories: MemoryEntry[] = [];\n\n    for (const id of ids) {\n      const memory = await this.getMemory(id);\n      if (memory) {\n        memories.push(memory);\n      }\n    }\n\n    return memories;\n  }\n\n  // Get recent memories (respects workspace mode)\n  async getRecentMemories(limit: number = 50): Promise<MemoryEntry[]> {\n    const mode = getWorkspaceMode();\n\n    if (mode === WorkspaceMode.GLOBAL) {\n      // Global mode: only global memories\n      const ids = await this.redis.zrevrange(RedisKeys.globalTimeline(), 0, limit - 1);\n      return this.getMemories(ids);\n    } else if (mode === WorkspaceMode.ISOLATED) {\n      // Isolated mode: only workspace memories\n      const ids = await this.redis.zrevrange(RedisKeys.timeline(this.workspaceId), 0, limit - 1);\n      return this.getMemories(ids);\n    } else {\n      // Hybrid mode: merge workspace + global\n      const wsIds = await this.redis.zrevrange(RedisKeys.timeline(this.workspaceId), 0, limit - 1);\n      const globalIds = await this.redis.zrevrange(RedisKeys.globalTimeline(), 0, limit - 1);\n\n      const allMemories = await this.getMemories([...wsIds, ...globalIds]);\n\n      // Sort by timestamp descending\n      allMemories.sort((a, b) => b.timestamp - a.timestamp);\n\n      return allMemories.slice(0, limit);\n    }\n  }\n\n  // Get memories by type (respects workspace mode)\n  async getMemoriesByType(type: ContextType, limit?: number): Promise<MemoryEntry[]> {\n    const mode = getWorkspaceMode();\n    let ids: string[] = [];\n\n    if (mode === WorkspaceMode.GLOBAL) {\n      ids = await this.redis.smembers(RedisKeys.globalByType(type));\n    } else if (mode === WorkspaceMode.ISOLATED) {\n      ids = await this.redis.smembers(RedisKeys.byType(this.workspaceId, type));\n    } else {\n      // Hybrid: merge both\n      const wsIds = await this.redis.smembers(RedisKeys.byType(this.workspaceId, type));\n      const globalIds = await this.redis.smembers(RedisKeys.globalByType(type));\n      ids = [...new Set([...wsIds, ...globalIds])]; // Deduplicate\n    }\n\n    const memories = await this.getMemories(ids);\n\n    // Sort by timestamp descending\n    memories.sort((a, b) => b.timestamp - a.timestamp);\n\n    return limit ? memories.slice(0, limit) : memories;\n  }\n\n  // Get memories by tag (respects workspace mode)\n  async getMemoriesByTag(tag: string, limit?: number): Promise<MemoryEntry[]> {\n    const mode = getWorkspaceMode();\n    let ids: string[] = [];\n\n    if (mode === WorkspaceMode.GLOBAL) {\n      ids = await this.redis.smembers(RedisKeys.globalByTag(tag));\n    } else if (mode === WorkspaceMode.ISOLATED) {\n      ids = await this.redis.smembers(RedisKeys.byTag(this.workspaceId, tag));\n    } else {\n      // Hybrid: merge both\n      const wsIds = await this.redis.smembers(RedisKeys.byTag(this.workspaceId, tag));\n      const globalIds = await this.redis.smembers(RedisKeys.globalByTag(tag));\n      ids = [...new Set([...wsIds, ...globalIds])]; // Deduplicate\n    }\n\n    const memories = await this.getMemories(ids);\n\n    // Sort by timestamp descending\n    memories.sort((a, b) => b.timestamp - a.timestamp);\n\n    return limit ? memories.slice(0, limit) : memories;\n  }\n\n  // Get important memories (respects workspace mode)\n  async getImportantMemories(minImportance: number = 8, limit?: number): Promise<MemoryEntry[]> {\n    const mode = getWorkspaceMode();\n    let results: string[] = [];\n\n    if (mode === WorkspaceMode.GLOBAL) {\n      results = await this.redis.zrevrangebyscore(\n        RedisKeys.globalImportant(),\n        10,\n        minImportance,\n        'LIMIT',\n        0,\n        limit || 100\n      );\n    } else if (mode === WorkspaceMode.ISOLATED) {\n      results = await this.redis.zrevrangebyscore(\n        RedisKeys.important(this.workspaceId),\n        10,\n        minImportance,\n        'LIMIT',\n        0,\n        limit || 100\n      );\n    } else {\n      // Hybrid: get from both and merge\n      const wsResults = await this.redis.zrevrangebyscore(\n        RedisKeys.important(this.workspaceId),\n        10,\n        minImportance,\n        'LIMIT',\n        0,\n        limit || 100\n      );\n      const globalResults = await this.redis.zrevrangebyscore(\n        RedisKeys.globalImportant(),\n        10,\n        minImportance,\n        'LIMIT',\n        0,\n        limit || 100\n      );\n\n      const allMemories = await this.getMemories([...wsResults, ...globalResults]);\n      // Sort by importance descending\n      allMemories.sort((a, b) => b.importance - a.importance);\n      return allMemories.slice(0, limit || 100);\n    }\n\n    return this.getMemories(results);\n  }\n\n  // Update memory (handles both workspace and global)\n  async updateMemory(id: string, updates: Partial<CreateMemory>): Promise<MemoryEntry | null> {\n    const existing = await this.getMemory(id);\n    if (!existing) {\n      return null;\n    }\n\n    const pipeline = this.redis.pipeline();\n\n    // Update content and regenerate embedding if content changed\n    let embedding = existing.embedding;\n    if (updates.content && updates.content !== existing.content) {\n      embedding = await generateEmbedding(updates.content);\n    }\n\n    const updated: MemoryEntry = {\n      ...existing,\n      ...updates,\n      embedding,\n      summary: updates.summary || (updates.content ? this.generateSummary(updates.content) : existing.summary),\n    };\n\n    const isGlobal = existing.is_global;\n\n    // Update hash (use appropriate key based on is_global)\n    const memoryKey = isGlobal\n      ? RedisKeys.globalMemory(id)\n      : RedisKeys.memory(this.workspaceId, id);\n\n    pipeline.hset(memoryKey, this.serializeMemory(updated));\n\n    // Update type index if changed\n    if (updates.context_type && updates.context_type !== existing.context_type) {\n      if (isGlobal) {\n        pipeline.srem(RedisKeys.globalByType(existing.context_type), id);\n        pipeline.sadd(RedisKeys.globalByType(updates.context_type), id);\n      } else {\n        pipeline.srem(RedisKeys.byType(this.workspaceId, existing.context_type), id);\n        pipeline.sadd(RedisKeys.byType(this.workspaceId, updates.context_type), id);\n      }\n    }\n\n    // Update tag indexes if changed\n    if (updates.tags) {\n      // Remove from old tags\n      for (const tag of existing.tags) {\n        if (!updates.tags.includes(tag)) {\n          if (isGlobal) {\n            pipeline.srem(RedisKeys.globalByTag(tag), id);\n          } else {\n            pipeline.srem(RedisKeys.byTag(this.workspaceId, tag), id);\n          }\n        }\n      }\n      // Add to new tags\n      for (const tag of updates.tags) {\n        if (!existing.tags.includes(tag)) {\n          if (isGlobal) {\n            pipeline.sadd(RedisKeys.globalByTag(tag), id);\n          } else {\n            pipeline.sadd(RedisKeys.byTag(this.workspaceId, tag), id);\n          }\n        }\n      }\n    }\n\n    // Update importance index if changed\n    if (updates.importance !== undefined) {\n      if (existing.importance >= 8) {\n        if (isGlobal) {\n          pipeline.zrem(RedisKeys.globalImportant(), id);\n        } else {\n          pipeline.zrem(RedisKeys.important(this.workspaceId), id);\n        }\n      }\n      if (updates.importance >= 8) {\n        if (isGlobal) {\n          pipeline.zadd(RedisKeys.globalImportant(), updates.importance, id);\n        } else {\n          pipeline.zadd(RedisKeys.important(this.workspaceId), updates.importance, id);\n        }\n      }\n    }\n\n    await pipeline.exec();\n\n    return updated;\n  }\n\n  // Delete memory (handles both workspace and global)\n  async deleteMemory(id: string): Promise<boolean> {\n    const memory = await this.getMemory(id);\n    if (!memory) {\n      return false;\n    }\n\n    const pipeline = this.redis.pipeline();\n    const isGlobal = memory.is_global;\n\n    // Remove from all indexes (use appropriate keys based on is_global)\n    if (isGlobal) {\n      pipeline.del(RedisKeys.globalMemory(id));\n      pipeline.srem(RedisKeys.globalMemories(), id);\n      pipeline.zrem(RedisKeys.globalTimeline(), id);\n      pipeline.srem(RedisKeys.globalByType(memory.context_type), id);\n\n      for (const tag of memory.tags) {\n        pipeline.srem(RedisKeys.globalByTag(tag), id);\n      }\n\n      if (memory.importance >= 8) {\n        pipeline.zrem(RedisKeys.globalImportant(), id);\n      }\n    } else {\n      pipeline.del(RedisKeys.memory(this.workspaceId, id));\n      pipeline.srem(RedisKeys.memories(this.workspaceId), id);\n      pipeline.zrem(RedisKeys.timeline(this.workspaceId), id);\n      pipeline.srem(RedisKeys.byType(this.workspaceId, memory.context_type), id);\n\n      for (const tag of memory.tags) {\n        pipeline.srem(RedisKeys.byTag(this.workspaceId, tag), id);\n      }\n\n      if (memory.importance >= 8) {\n        pipeline.zrem(RedisKeys.important(this.workspaceId), id);\n      }\n    }\n\n    await pipeline.exec();\n\n    return true;\n  }\n\n  // Semantic search (respects workspace mode with global memory weighting)\n  async searchMemories(\n    query: string,\n    limit: number = 10,\n    minImportance?: number,\n    contextTypes?: ContextType[]\n  ): Promise<Array<MemoryEntry & { similarity: number }>> {\n    // Generate embedding for query\n    const queryEmbedding = await generateEmbedding(query);\n\n    const mode = getWorkspaceMode();\n    let memories: MemoryEntry[] = [];\n\n    // Get all memories based on workspace mode\n    if (mode === WorkspaceMode.GLOBAL) {\n      // Global mode: only global memories\n      let ids: string[];\n      if (contextTypes && contextTypes.length > 0) {\n        const sets = contextTypes.map(type => RedisKeys.globalByType(type));\n        ids = await this.redis.sunion(...sets);\n      } else {\n        ids = await this.redis.smembers(RedisKeys.globalMemories());\n      }\n      memories = await this.getMemories(ids);\n    } else if (mode === WorkspaceMode.ISOLATED) {\n      // Isolated mode: only workspace memories\n      let ids: string[];\n      if (contextTypes && contextTypes.length > 0) {\n        const sets = contextTypes.map(type => RedisKeys.byType(this.workspaceId, type));\n        ids = await this.redis.sunion(...sets);\n      } else {\n        ids = await this.redis.smembers(RedisKeys.memories(this.workspaceId));\n      }\n      memories = await this.getMemories(ids);\n    } else {\n      // Hybrid mode: merge workspace + global\n      let wsIds: string[];\n      let globalIds: string[];\n\n      if (contextTypes && contextTypes.length > 0) {\n        const wsSets = contextTypes.map(type => RedisKeys.byType(this.workspaceId, type));\n        const globalSets = contextTypes.map(type => RedisKeys.globalByType(type));\n        wsIds = await this.redis.sunion(...wsSets);\n        globalIds = await this.redis.sunion(...globalSets);\n      } else {\n        wsIds = await this.redis.smembers(RedisKeys.memories(this.workspaceId));\n        globalIds = await this.redis.smembers(RedisKeys.globalMemories());\n      }\n\n      memories = await this.getMemories([...wsIds, ...globalIds]);\n    }\n\n    // Filter by importance if specified\n    let filtered = memories;\n    if (minImportance !== undefined) {\n      filtered = memories.filter(m => m.importance >= minImportance);\n    }\n\n    // Calculate similarities\n    const withSimilarity = filtered.map(memory => {\n      const baseSimilarity = memory.embedding ? cosineSimilarity(queryEmbedding, memory.embedding) : 0;\n\n      // In hybrid mode, weight global memories slightly lower (0.9x) to prefer local context\n      const similarity = (mode === WorkspaceMode.HYBRID && memory.is_global)\n        ? baseSimilarity * 0.9\n        : baseSimilarity;\n\n      return {\n        ...memory,\n        similarity,\n      };\n    });\n\n    // Sort by similarity descending\n    withSimilarity.sort((a, b) => b.similarity - a.similarity);\n\n    return withSimilarity.slice(0, limit);\n  }\n\n  // Create session\n  async createSession(name: string, memoryIds: string[], summary?: string): Promise<SessionInfo> {\n    const sessionId = ulid();\n    const timestamp = Date.now();\n\n    // Verify all memory IDs exist\n    const validIds: string[] = [];\n    for (const id of memoryIds) {\n      const exists = await this.redis.exists(RedisKeys.memory(this.workspaceId, id));\n      if (exists) {\n        validIds.push(id);\n      }\n    }\n\n    const session: SessionInfo = {\n      session_id: sessionId,\n      session_name: name,\n      created_at: timestamp,\n      memory_count: validIds.length,\n      summary,\n      memory_ids: validIds,\n    };\n\n    // Store session\n    await this.redis.hset(RedisKeys.session(this.workspaceId, sessionId), {\n      session_id: sessionId,\n      session_name: name,\n      created_at: timestamp.toString(),\n      memory_count: validIds.length.toString(),\n      summary: summary || '',\n      memory_ids: JSON.stringify(validIds),\n    });\n\n    await this.redis.sadd(RedisKeys.sessions(this.workspaceId), sessionId);\n\n    return session;\n  }\n\n  // Get session\n  async getSession(sessionId: string): Promise<SessionInfo | null> {\n    const data = await this.redis.hgetall(RedisKeys.session(this.workspaceId, sessionId));\n\n    if (!data || Object.keys(data).length === 0) {\n      return null;\n    }\n\n    return {\n      session_id: data.session_id,\n      session_name: data.session_name,\n      created_at: parseInt(data.created_at, 10),\n      memory_count: parseInt(data.memory_count, 10),\n      summary: data.summary || undefined,\n      memory_ids: JSON.parse(data.memory_ids),\n    };\n  }\n\n  // Get all sessions\n  async getAllSessions(): Promise<SessionInfo[]> {\n    const ids = await this.redis.smembers(RedisKeys.sessions(this.workspaceId));\n    const sessions: SessionInfo[] = [];\n\n    for (const id of ids) {\n      const session = await this.getSession(id);\n      if (session) {\n        sessions.push(session);\n      }\n    }\n\n    return sessions.sort((a, b) => b.created_at - a.created_at);\n  }\n\n  // Get memories in session\n  async getSessionMemories(sessionId: string): Promise<MemoryEntry[]> {\n    const session = await this.getSession(sessionId);\n    if (!session) {\n      return [];\n    }\n\n    return this.getMemories(session.memory_ids);\n  }\n\n  // Generate summary stats\n  async getSummaryStats(): Promise<{\n    total_memories: number;\n    by_type: Record<ContextType, number>;\n    total_sessions: number;\n    important_count: number;\n    workspace_path: string;\n  }> {\n    const totalMemories = await this.redis.scard(RedisKeys.memories(this.workspaceId));\n    const totalSessions = await this.redis.scard(RedisKeys.sessions(this.workspaceId));\n    const importantCount = await this.redis.zcard(RedisKeys.important(this.workspaceId));\n\n    const byType: Record<string, number> = {};\n    const types: ContextType[] = ['directive', 'information', 'heading', 'decision', 'code_pattern', 'requirement', 'error', 'todo', 'insight', 'preference'];\n\n    for (const type of types) {\n      byType[type] = await this.redis.scard(RedisKeys.byType(this.workspaceId, type));\n    }\n\n    return {\n      total_memories: totalMemories,\n      by_type: byType as Record<ContextType, number>,\n      total_sessions: totalSessions,\n      important_count: importantCount,\n      workspace_path: this.workspacePath,\n    };\n  }\n\n  // Merge multiple memories into one\n  async mergeMemories(memoryIds: string[], keepId?: string): Promise<MemoryEntry | null> {\n    // Get all memories to merge\n    const memories = await this.getMemories(memoryIds);\n\n    if (memories.length === 0) {\n      return null;\n    }\n\n    // Determine which memory to keep\n    const toKeep = keepId\n      ? memories.find(m => m.id === keepId)\n      : memories.reduce((prev, current) =>\n          current.importance > prev.importance ? current : prev\n        );\n\n    if (!toKeep) {\n      return null;\n    }\n\n    // Merge content, tags, and metadata\n    const allTags = new Set<string>();\n    const contentParts: string[] = [];\n\n    for (const memory of memories) {\n      if (memory.id !== toKeep.id) {\n        contentParts.push(memory.content);\n      }\n      memory.tags.forEach(tag => allTags.add(tag));\n    }\n\n    // Create merged content\n    const mergedContent = contentParts.length > 0\n      ? `${toKeep.content}\\n\\n--- Merged content ---\\n${contentParts.join('\\n\\n')}`\n      : toKeep.content;\n\n    // Update the memory to keep with merged data\n    const updated = await this.updateMemory(toKeep.id, {\n      content: mergedContent,\n      tags: Array.from(allTags),\n      importance: Math.max(...memories.map(m => m.importance)),\n    });\n\n    // Delete the other memories\n    for (const memory of memories) {\n      if (memory.id !== toKeep.id) {\n        await this.deleteMemory(memory.id);\n      }\n    }\n\n    return updated;\n  }\n\n  // Helper: Generate summary from content (first 100 chars)\n  private generateSummary(content: string): string {\n    return content.length > 100 ? content.substring(0, 100) + '...' : content;\n  }\n\n  // Helper: Serialize memory for Redis\n  private serializeMemory(memory: MemoryEntry): Record<string, string> {\n    return {\n      id: memory.id,\n      timestamp: memory.timestamp.toString(),\n      context_type: memory.context_type,\n      content: memory.content,\n      summary: memory.summary || '',\n      tags: JSON.stringify(memory.tags),\n      importance: memory.importance.toString(),\n      session_id: memory.session_id || '',\n      embedding: JSON.stringify(memory.embedding || []),\n      ttl_seconds: memory.ttl_seconds?.toString() || '',\n      expires_at: memory.expires_at?.toString() || '',\n      is_global: memory.is_global ? 'true' : 'false',\n      workspace_id: memory.workspace_id || '',\n    };\n  }\n\n  // Helper: Deserialize memory from Redis\n  private deserializeMemory(data: Record<string, string>): MemoryEntry {\n    return {\n      id: data.id,\n      timestamp: parseInt(data.timestamp, 10),\n      context_type: data.context_type as ContextType,\n      content: data.content,\n      summary: data.summary || undefined,\n      tags: JSON.parse(data.tags || '[]'),\n      importance: parseInt(data.importance, 10),\n      session_id: data.session_id || undefined,\n      embedding: JSON.parse(data.embedding || '[]'),\n      ttl_seconds: data.ttl_seconds ? parseInt(data.ttl_seconds, 10) : undefined,\n      expires_at: data.expires_at ? parseInt(data.expires_at, 10) : undefined,\n      is_global: data.is_global === 'true',\n      workspace_id: data.workspace_id || '',\n    };\n  }\n\n  // Convert workspace memory to global\n  async convertToGlobal(memoryId: string): Promise<MemoryEntry | null> {\n    const memory = await this.getMemory(memoryId);\n    if (!memory) {\n      return null;\n    }\n\n    // Already global\n    if (memory.is_global) {\n      return memory;\n    }\n\n    const pipeline = this.redis.pipeline();\n\n    // Delete from workspace indexes\n    pipeline.del(RedisKeys.memory(this.workspaceId, memoryId));\n    pipeline.srem(RedisKeys.memories(this.workspaceId), memoryId);\n    pipeline.zrem(RedisKeys.timeline(this.workspaceId), memoryId);\n    pipeline.srem(RedisKeys.byType(this.workspaceId, memory.context_type), memoryId);\n\n    for (const tag of memory.tags) {\n      pipeline.srem(RedisKeys.byTag(this.workspaceId, tag), memoryId);\n    }\n\n    if (memory.importance >= 8) {\n      pipeline.zrem(RedisKeys.important(this.workspaceId), memoryId);\n    }\n\n    // Update memory to global\n    const globalMemory: MemoryEntry = {\n      ...memory,\n      is_global: true,\n      workspace_id: '',\n    };\n\n    // Add to global indexes\n    pipeline.hset(RedisKeys.globalMemory(memoryId), this.serializeMemory(globalMemory));\n    pipeline.sadd(RedisKeys.globalMemories(), memoryId);\n    pipeline.zadd(RedisKeys.globalTimeline(), memory.timestamp, memoryId);\n    pipeline.sadd(RedisKeys.globalByType(memory.context_type), memoryId);\n\n    for (const tag of memory.tags) {\n      pipeline.sadd(RedisKeys.globalByTag(tag), memoryId);\n    }\n\n    if (memory.importance >= 8) {\n      pipeline.zadd(RedisKeys.globalImportant(), memory.importance, memoryId);\n    }\n\n    await pipeline.exec();\n\n    return globalMemory;\n  }\n\n  // Convert global memory to workspace\n  async convertToWorkspace(memoryId: string, targetWorkspaceId?: string): Promise<MemoryEntry | null> {\n    const memory = await this.getMemory(memoryId);\n    if (!memory) {\n      return null;\n    }\n\n    // Already workspace-specific\n    if (!memory.is_global) {\n      return memory;\n    }\n\n    const workspaceId = targetWorkspaceId || this.workspaceId;\n    const pipeline = this.redis.pipeline();\n\n    // Delete from global indexes\n    pipeline.del(RedisKeys.globalMemory(memoryId));\n    pipeline.srem(RedisKeys.globalMemories(), memoryId);\n    pipeline.zrem(RedisKeys.globalTimeline(), memoryId);\n    pipeline.srem(RedisKeys.globalByType(memory.context_type), memoryId);\n\n    for (const tag of memory.tags) {\n      pipeline.srem(RedisKeys.globalByTag(tag), memoryId);\n    }\n\n    if (memory.importance >= 8) {\n      pipeline.zrem(RedisKeys.globalImportant(), memoryId);\n    }\n\n    // Update memory to workspace-specific\n    const workspaceMemory: MemoryEntry = {\n      ...memory,\n      is_global: false,\n      workspace_id: workspaceId,\n    };\n\n    // Add to workspace indexes\n    pipeline.hset(RedisKeys.memory(workspaceId, memoryId), this.serializeMemory(workspaceMemory));\n    pipeline.sadd(RedisKeys.memories(workspaceId), memoryId);\n    pipeline.zadd(RedisKeys.timeline(workspaceId), memory.timestamp, memoryId);\n    pipeline.sadd(RedisKeys.byType(workspaceId, memory.context_type), memoryId);\n\n    for (const tag of memory.tags) {\n      pipeline.sadd(RedisKeys.byTag(workspaceId, tag), memoryId);\n    }\n\n    if (memory.importance >= 8) {\n      pipeline.zadd(RedisKeys.important(workspaceId), memory.importance, memoryId);\n    }\n\n    await pipeline.exec();\n\n    return workspaceMemory;\n  }\n}\n","import Anthropic from '@anthropic-ai/sdk';\n\nlet anthropicClient: Anthropic | null = null;\n\nfunction getAnthropicClient(): Anthropic {\n  if (!anthropicClient) {\n    const apiKey = process.env.ANTHROPIC_API_KEY;\n    if (!apiKey) {\n      throw new Error('ANTHROPIC_API_KEY environment variable is required');\n    }\n    anthropicClient = new Anthropic({ apiKey });\n  }\n  return anthropicClient;\n}\n\n// Claude doesn't have a native embeddings API, so we'll use a lightweight approach:\n// Generate a semantic \"fingerprint\" by having Claude extract key concepts\nasync function generateSemanticFingerprint(text: string): Promise<string[]> {\n  try {\n    const client = getAnthropicClient();\n    const response = await client.messages.create({\n      model: 'claude-3-5-haiku-20241022', // Fast, cheap model for this task\n      max_tokens: 200,\n      messages: [{\n        role: 'user',\n        content: `Extract 5-10 key concepts/keywords from this text. Return ONLY a comma-separated list, no explanations:\n\n${text}`\n      }]\n    });\n\n    const content = response.content[0];\n    if (content.type === 'text') {\n      // Parse comma-separated keywords\n      const keywords = content.text\n        .split(',')\n        .map(k => k.trim().toLowerCase())\n        .filter(k => k.length > 0);\n\n      return keywords;\n    }\n\n    return [];\n  } catch (error) {\n    console.error('Error generating semantic fingerprint:', error);\n    throw error;\n  }\n}\n\n// Convert text to a simple vector representation using character n-grams and keywords\nexport async function generateEmbedding(text: string): Promise<number[]> {\n  try {\n    // Get semantic keywords from Claude\n    const keywords = await generateSemanticFingerprint(text);\n\n    // Create a simple vector representation\n    // This is a lightweight approach that combines:\n    // 1. Character trigrams (for text similarity)\n    // 2. Semantic keywords (from Claude)\n    const vector = createSimpleVector(text, keywords);\n\n    return vector;\n  } catch (error) {\n    console.error('Error generating embedding:', error);\n    throw error;\n  }\n}\n\nexport async function generateEmbeddings(texts: string[]): Promise<number[][]> {\n  try {\n    // Process in parallel\n    const embeddings = await Promise.all(\n      texts.map(text => generateEmbedding(text))\n    );\n    return embeddings;\n  } catch (error) {\n    console.error('Error generating embeddings:', error);\n    throw error;\n  }\n}\n\n// Create a simple 128-dimensional vector from text and keywords\nfunction createSimpleVector(text: string, keywords: string[]): number[] {\n  const VECTOR_SIZE = 128;\n  const vector = new Array(VECTOR_SIZE).fill(0);\n\n  // Normalize text\n  const normalized = text.toLowerCase();\n\n  // Part 1: Character trigrams (first 64 dimensions)\n  const trigrams = extractTrigrams(normalized);\n  for (let i = 0; i < Math.min(trigrams.length, 64); i++) {\n    const hash = simpleHash(trigrams[i]);\n    const index = hash % 64;\n    vector[index] += 1;\n  }\n\n  // Part 2: Keyword-based features (last 64 dimensions)\n  for (const keyword of keywords) {\n    const hash = simpleHash(keyword);\n    const index = 64 + (hash % 64);\n    vector[index] += 2; // Weight keywords higher\n  }\n\n  // Normalize the vector\n  const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\n  if (magnitude > 0) {\n    for (let i = 0; i < vector.length; i++) {\n      vector[i] /= magnitude;\n    }\n  }\n\n  return vector;\n}\n\n// Extract character trigrams from text\nfunction extractTrigrams(text: string): string[] {\n  const trigrams: string[] = [];\n  for (let i = 0; i < text.length - 2; i++) {\n    trigrams.push(text.substring(i, i + 3));\n  }\n  return trigrams;\n}\n\n// Simple hash function\nfunction simpleHash(str: string): number {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash);\n}\n\n// Cosine similarity calculation\nexport function cosineSimilarity(a: number[], b: number[]): number {\n  if (a.length !== b.length) {\n    throw new Error('Vectors must have the same length');\n  }\n\n  let dotProduct = 0;\n  let normA = 0;\n  let normB = 0;\n\n  for (let i = 0; i < a.length; i++) {\n    dotProduct += a[i] * b[i];\n    normA += a[i] * a[i];\n    normB += b[i] * b[i];\n  }\n\n  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n}\n","import { z } from 'zod';\n\n// Context types for different kinds of memory\nexport const ContextType = z.enum([\n  'directive',      // Instructions or commands\n  'information',    // General facts or knowledge\n  'heading',        // Section headers or organizational markers\n  'decision',       // Decisions made during work\n  'code_pattern',   // Code patterns or conventions\n  'requirement',    // Project requirements\n  'error',          // Error encountered and solution\n  'todo',           // Task or todo item\n  'insight',        // Key insight or realization\n  'preference',     // User preference\n]);\n\nexport type ContextType = z.infer<typeof ContextType>;\n\n// Memory entry schema\nexport const MemoryEntrySchema = z.object({\n  id: z.string().describe('ULID identifier'),\n  timestamp: z.number().describe('Unix timestamp in milliseconds'),\n  context_type: ContextType,\n  content: z.string().describe('The actual memory content'),\n  summary: z.string().optional().describe('Short summary for quick scanning'),\n  tags: z.array(z.string()).default([]).describe('Tags for categorization'),\n  importance: z.number().min(1).max(10).default(5).describe('Importance score 1-10'),\n  session_id: z.string().optional().describe('Optional session grouping'),\n  embedding: z.array(z.number()).optional().describe('Vector embedding'),\n  ttl_seconds: z.number().optional().describe('Time-to-live in seconds (auto-expires)'),\n  expires_at: z.number().optional().describe('Unix timestamp when memory expires'),\n  is_global: z.boolean().default(false).describe('If true, memory is accessible across all workspaces'),\n  workspace_id: z.string().describe('Workspace identifier (empty for global memories)'),\n});\n\nexport type MemoryEntry = z.infer<typeof MemoryEntrySchema>;\n\n// Input schema for creating memories\nexport const CreateMemorySchema = z.object({\n  content: z.string().min(1).describe('The memory content to store'),\n  context_type: ContextType.default('information'),\n  tags: z.array(z.string()).default([]).describe('Tags for categorization'),\n  importance: z.number().min(1).max(10).default(5).describe('Importance score 1-10'),\n  summary: z.string().optional().describe('Optional summary'),\n  session_id: z.string().optional().describe('Optional session ID'),\n  ttl_seconds: z.number().min(60).optional().describe('Time-to-live in seconds (minimum 60s)'),\n  is_global: z.boolean().default(false).describe('If true, memory is accessible across all workspaces'),\n});\n\nexport type CreateMemory = z.infer<typeof CreateMemorySchema>;\n\n// Batch create schema\nexport const BatchCreateMemoriesSchema = z.object({\n  memories: z.array(CreateMemorySchema).min(1).describe('Array of memories to store'),\n});\n\n// Update memory schema\nexport const UpdateMemorySchema = z.object({\n  memory_id: z.string().describe('ULID of memory to update'),\n  content: z.string().optional(),\n  context_type: ContextType.optional(),\n  tags: z.array(z.string()).optional(),\n  importance: z.number().min(1).max(10).optional(),\n  summary: z.string().optional(),\n  session_id: z.string().optional(),\n});\n\n// Delete memory schema\nexport const DeleteMemorySchema = z.object({\n  memory_id: z.string().describe('ULID of memory to delete'),\n});\n\n// Search schema\nexport const SearchMemorySchema = z.object({\n  query: z.string().describe('Search query'),\n  limit: z.number().min(1).max(100).default(10).describe('Number of results'),\n  min_importance: z.number().min(1).max(10).optional().describe('Filter by minimum importance'),\n  context_types: z.array(ContextType).optional().describe('Filter by context types'),\n});\n\n// Session organization schema\nexport const OrganizeSessionSchema = z.object({\n  session_name: z.string().describe('Name for the session'),\n  memory_ids: z.array(z.string()).min(1).describe('Array of memory IDs to include'),\n  summary: z.string().optional().describe('Optional session summary'),\n});\n\n// Session info\nexport interface SessionInfo {\n  session_id: string;\n  session_name: string;\n  created_at: number;\n  memory_count: number;\n  summary?: string;\n  memory_ids: string[];\n}\n\n// Workspace mode configuration\nexport enum WorkspaceMode {\n  ISOLATED = 'isolated',  // Default: workspace-only (current behavior)\n  GLOBAL = 'global',      // All memories shared across workspaces\n  HYBRID = 'hybrid'       // Support both global + workspace memories\n}\n\n// Workspace context\nexport interface WorkspaceContext {\n  workspace_path: string;\n  workspace_id: string; // Hash of the path for Redis keys\n  mode: WorkspaceMode;   // Workspace isolation mode\n}\n\n// Helper to create workspace ID from path\nexport function createWorkspaceId(path: string): string {\n  // Simple hash function for workspace path\n  let hash = 0;\n  for (let i = 0; i < path.length; i++) {\n    const char = path.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(36);\n}\n\n// Helper to get workspace mode from environment\nexport function getWorkspaceMode(): WorkspaceMode {\n  const mode = process.env.WORKSPACE_MODE?.toLowerCase();\n\n  switch (mode) {\n    case 'global':\n      return WorkspaceMode.GLOBAL;\n    case 'hybrid':\n      return WorkspaceMode.HYBRID;\n    case 'isolated':\n    default:\n      return WorkspaceMode.ISOLATED;\n  }\n}\n\n// Recall context schema (for proactive context retrieval)\nexport const RecallContextSchema = z.object({\n  current_task: z.string().describe('Description of what I\\'m currently working on'),\n  query: z.string().optional().describe('Optional specific search query'),\n  limit: z.number().min(1).max(20).default(5).describe('Number of results to return'),\n  min_importance: z.number().min(1).max(10).default(6).describe('Minimum importance threshold'),\n});\n\nexport type RecallContext = z.infer<typeof RecallContextSchema>;\n\n// Analyze conversation schema (for extracting structured memories)\nexport const AnalyzeConversationSchema = z.object({\n  conversation_text: z.string().min(1).describe('Conversation text to analyze and extract memories from'),\n  auto_categorize: z.boolean().default(true).describe('Automatically categorize extracted memories'),\n  auto_store: z.boolean().default(true).describe('Automatically store extracted memories'),\n});\n\nexport type AnalyzeConversation = z.infer<typeof AnalyzeConversationSchema>;\n\n// Summarize session schema\nexport const SummarizeSessionSchema = z.object({\n  session_name: z.string().optional().describe('Optional name for the session'),\n  auto_create_snapshot: z.boolean().default(true).describe('Automatically create session snapshot'),\n  lookback_minutes: z.number().default(60).describe('How many minutes back to look for memories'),\n});\n\nexport type SummarizeSession = z.infer<typeof SummarizeSessionSchema>;\n\n// Extracted memory from conversation analysis\nexport interface ExtractedMemory {\n  content: string;\n  context_type: ContextType;\n  importance: number;\n  tags: string[];\n  summary?: string;\n}\n\n// Analysis result\nexport interface AnalysisResult {\n  extracted_memories: ExtractedMemory[];\n  total_count: number;\n  stored_ids?: string[];\n}\n\n// Export memories schema\nexport const ExportMemoriesSchema = z.object({\n  format: z.enum(['json']).default('json').describe('Export format'),\n  include_embeddings: z.boolean().default(false).describe('Include vector embeddings in export'),\n  filter_by_type: z.array(ContextType).optional().describe('Only export specific types'),\n  min_importance: z.number().min(1).max(10).optional().describe('Only export above this importance'),\n});\n\nexport type ExportMemories = z.infer<typeof ExportMemoriesSchema>;\n\n// Import memories schema\nexport const ImportMemoriesSchema = z.object({\n  data: z.string().describe('JSON string of exported memories'),\n  overwrite_existing: z.boolean().default(false).describe('Overwrite if memory ID already exists'),\n  regenerate_embeddings: z.boolean().default(true).describe('Regenerate embeddings on import'),\n});\n\nexport type ImportMemories = z.infer<typeof ImportMemoriesSchema>;\n\n// Find duplicates schema\nexport const FindDuplicatesSchema = z.object({\n  similarity_threshold: z.number().min(0).max(1).default(0.85).describe('Similarity threshold (0-1)'),\n  auto_merge: z.boolean().default(false).describe('Automatically merge duplicates'),\n  keep_highest_importance: z.boolean().default(true).describe('When merging, keep highest importance'),\n});\n\nexport type FindDuplicates = z.infer<typeof FindDuplicatesSchema>;\n\n// Consolidate memories schema\nexport const ConsolidateMemoriesSchema = z.object({\n  memory_ids: z.array(z.string()).min(2).describe('Array of memory IDs to consolidate'),\n  keep_id: z.string().optional().describe('Optional ID of memory to keep (default: highest importance)'),\n});\n\nexport type ConsolidateMemories = z.infer<typeof ConsolidateMemoriesSchema>;\n\n// Duplicate group interface\nexport interface DuplicateGroup {\n  memories: MemoryEntry[];\n  similarity_score: number;\n}\n\n// Redis keys helper with workspace isolation and global support\nexport const RedisKeys = {\n  // Workspace-scoped keys\n  memory: (workspace: string, id: string) => `ws:${workspace}:memory:${id}`,\n  memories: (workspace: string) => `ws:${workspace}:memories:all`,\n  byType: (workspace: string, type: ContextType) => `ws:${workspace}:memories:type:${type}`,\n  byTag: (workspace: string, tag: string) => `ws:${workspace}:memories:tag:${tag}`,\n  timeline: (workspace: string) => `ws:${workspace}:memories:timeline`,\n  session: (workspace: string, id: string) => `ws:${workspace}:session:${id}`,\n  sessions: (workspace: string) => `ws:${workspace}:sessions:all`,\n  important: (workspace: string) => `ws:${workspace}:memories:important`,\n\n  // Global keys (workspace-independent)\n  globalMemory: (id: string) => `global:memory:${id}`,\n  globalMemories: () => `global:memories:all`,\n  globalByType: (type: ContextType) => `global:memories:type:${type}`,\n  globalByTag: (tag: string) => `global:memories:tag:${tag}`,\n  globalTimeline: () => `global:memories:timeline`,\n  globalImportant: () => `global:memories:important`,\n} as const;\n\n// Helper to get the appropriate key based on is_global flag\nexport function getMemoryKey(workspace: string, id: string, isGlobal: boolean): string {\n  return isGlobal ? RedisKeys.globalMemory(id) : RedisKeys.memory(workspace, id);\n}\n\n// Convert memory to global schema\nexport const ConvertToGlobalSchema = z.object({\n  memory_id: z.string().describe('ID of the memory to convert to global'),\n});\n\nexport type ConvertToGlobal = z.infer<typeof ConvertToGlobalSchema>;\n\n// Convert memory to workspace schema\nexport const ConvertToWorkspaceSchema = z.object({\n  memory_id: z.string().describe('ID of the global memory to convert to workspace-specific'),\n  workspace_id: z.string().optional().describe('Target workspace (default: current workspace)'),\n});\n\nexport type ConvertToWorkspace = z.infer<typeof ConvertToWorkspaceSchema>;\n","import { z } from 'zod';\nimport { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport { ConversationAnalyzer } from '../analysis/conversation-analyzer.js';\nimport {\n  RecallContextSchema,\n  AnalyzeConversationSchema,\n  SummarizeSessionSchema,\n  type AnalysisResult,\n} from '../types.js';\n\nconst memoryStore = new MemoryStore();\nconst analyzer = new ConversationAnalyzer();\n\n/**\n * recall_relevant_context - Proactively retrieve relevant memories for current task\n */\nexport const recall_relevant_context = {\n  description: 'Proactively search memory for context relevant to current task. Use this when you need to recall patterns, decisions, or conventions.',\n  inputSchema: zodToJsonSchema(RecallContextSchema),\n  handler: async (args: z.infer<typeof RecallContextSchema>) => {\n    try {\n      // Enhance the search query\n      const enhancedQuery = await analyzer.enhanceQuery(args.current_task, args.query);\n\n      // Semantic search with filters\n      const results = await memoryStore.searchMemories(\n        enhancedQuery,\n        args.limit,\n        args.min_importance\n      );\n\n      // Format results for Claude to read\n      const formattedResults = results.map(r => ({\n        content: r.content,\n        summary: r.summary,\n        context_type: r.context_type,\n        importance: r.importance,\n        tags: r.tags,\n        similarity: Math.round(r.similarity * 100) / 100,\n      }));\n\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify({\n              current_task: args.current_task,\n              found: results.length,\n              relevant_memories: formattedResults,\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to recall context: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  },\n};\n\n/**\n * analyze_and_remember - Extract structured memories from conversation\n */\nexport const analyze_and_remember = {\n  description: 'Analyze conversation text and automatically extract and store important information (decisions, patterns, directives, etc.). Use this after important discussions.',\n  inputSchema: zodToJsonSchema(AnalyzeConversationSchema),\n  handler: async (args: z.infer<typeof AnalyzeConversationSchema>) => {\n    try {\n      // Analyze conversation to extract memories\n      const extracted = await analyzer.analyzeConversation(args.conversation_text);\n\n      const result: AnalysisResult = {\n        extracted_memories: extracted,\n        total_count: extracted.length,\n      };\n\n      // Auto-store if requested\n      if (args.auto_store && extracted.length > 0) {\n        const memories = await memoryStore.createMemories(\n          extracted.map(e => ({\n            content: e.content,\n            context_type: e.context_type,\n            importance: e.importance,\n            tags: e.tags,\n            summary: e.summary,\n          }))\n        );\n\n        result.stored_ids = memories.map(m => m.id);\n      }\n\n      // Format response\n      const response = {\n        success: true,\n        analyzed: result.total_count,\n        stored: result.stored_ids?.length || 0,\n        breakdown: {\n          directives: extracted.filter(e => e.context_type === 'directive').length,\n          decisions: extracted.filter(e => e.context_type === 'decision').length,\n          patterns: extracted.filter(e => e.context_type === 'code_pattern').length,\n          requirements: extracted.filter(e => e.context_type === 'requirement').length,\n          errors: extracted.filter(e => e.context_type === 'error').length,\n          insights: extracted.filter(e => e.context_type === 'insight').length,\n          other: extracted.filter(e => !['directive', 'decision', 'code_pattern', 'requirement', 'error', 'insight'].includes(e.context_type)).length,\n        },\n        memories: extracted.map(e => ({\n          content: e.content.substring(0, 100) + (e.content.length > 100 ? '...' : ''),\n          type: e.context_type,\n          importance: e.importance,\n        })),\n      };\n\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify(response, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to analyze conversation: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  },\n};\n\n/**\n * summarize_session - Create a session summary and snapshot\n */\nexport const summarize_session = {\n  description: 'Summarize the current work session and create a snapshot. Use this at the end of a work session to preserve context.',\n  inputSchema: zodToJsonSchema(SummarizeSessionSchema),\n  handler: async (args: z.infer<typeof SummarizeSessionSchema>) => {\n    try {\n      // Get recent memories from the lookback period\n      const lookbackMs = args.lookback_minutes * 60 * 1000;\n      const cutoffTime = Date.now() - lookbackMs;\n\n      const allRecent = await memoryStore.getRecentMemories(100);\n      const sessionMemories = allRecent.filter(m => m.timestamp >= cutoffTime);\n\n      if (sessionMemories.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: false,\n                message: 'No memories found in the specified lookback period',\n                lookback_minutes: args.lookback_minutes,\n              }, null, 2),\n            },\n          ],\n        };\n      }\n\n      // Generate summary using Claude\n      const summary = await analyzer.summarizeSession(\n        sessionMemories.map(m => ({\n          content: m.content,\n          context_type: m.context_type,\n          importance: m.importance,\n        }))\n      );\n\n      let sessionInfo = null;\n\n      // Create session snapshot if requested\n      if (args.auto_create_snapshot) {\n        const sessionName = args.session_name || `Session ${new Date().toISOString().split('T')[0]}`;\n        sessionInfo = await memoryStore.createSession(\n          sessionName,\n          sessionMemories.map(m => m.id),\n          summary\n        );\n      }\n\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              summary,\n              session_id: sessionInfo?.session_id,\n              session_name: sessionInfo?.session_name,\n              memory_count: sessionMemories.length,\n              lookback_minutes: args.lookback_minutes,\n              breakdown: {\n                directives: sessionMemories.filter(m => m.context_type === 'directive').length,\n                decisions: sessionMemories.filter(m => m.context_type === 'decision').length,\n                patterns: sessionMemories.filter(m => m.context_type === 'code_pattern').length,\n                insights: sessionMemories.filter(m => m.context_type === 'insight').length,\n              },\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to summarize session: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  },\n};\n\n// Helper function to convert Zod schema to JSON Schema (same as in tools/index.ts)\nfunction zodToJsonSchema(schema: z.ZodType): any {\n  if (schema instanceof z.ZodObject) {\n    const shape = schema._def.shape();\n    const properties: any = {};\n    const required: string[] = [];\n\n    for (const [key, value] of Object.entries(shape)) {\n      properties[key] = zodToJsonSchemaInner(value as z.ZodType);\n      if (!(value as any).isOptional()) {\n        required.push(key);\n      }\n    }\n\n    return {\n      type: 'object',\n      properties,\n      required,\n    };\n  }\n\n  return zodToJsonSchemaInner(schema);\n}\n\nfunction zodToJsonSchemaInner(schema: z.ZodType): any {\n  if (schema instanceof z.ZodString) {\n    const result: any = { type: 'string' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodNumber) {\n    const result: any = { type: 'number' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodBoolean) {\n    const result: any = { type: 'boolean' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodArray) {\n    const result: any = {\n      type: 'array',\n      items: zodToJsonSchemaInner(schema.element),\n    };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodEnum) {\n    const result: any = {\n      type: 'string',\n      enum: schema.options,\n    };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodOptional) {\n    return zodToJsonSchemaInner(schema.unwrap());\n  }\n\n  if (schema instanceof z.ZodDefault) {\n    const inner = zodToJsonSchemaInner(schema._def.innerType);\n    inner.default = schema._def.defaultValue();\n    return inner;\n  }\n\n  if (schema instanceof z.ZodObject) {\n    return zodToJsonSchema(schema);\n  }\n\n  return { type: 'string' };\n}\n","import Anthropic from '@anthropic-ai/sdk';\nimport type { ExtractedMemory, ContextType, AnalysisResult } from '../types.js';\n\nexport class ConversationAnalyzer {\n  private client: Anthropic;\n\n  constructor() {\n    const apiKey = process.env.ANTHROPIC_API_KEY;\n    if (!apiKey) {\n      throw new Error('ANTHROPIC_API_KEY environment variable is required');\n    }\n    this.client = new Anthropic({ apiKey });\n  }\n\n  /**\n   * Analyze conversation and extract structured memories\n   */\n  async analyzeConversation(conversationText: string): Promise<ExtractedMemory[]> {\n    try {\n      const response = await this.client.messages.create({\n        model: 'claude-3-5-haiku-20241022',\n        max_tokens: 2000,\n        messages: [{\n          role: 'user',\n          content: `Analyze this conversation and extract important information that should be remembered long-term.\n\nFor each important piece of information, output EXACTLY in this JSON format (one per line):\n{\"content\":\"the information\",\"type\":\"directive|information|decision|code_pattern|requirement|error|todo|insight|preference\",\"importance\":1-10,\"tags\":[\"tag1\",\"tag2\"],\"summary\":\"brief summary\"}\n\nGuidelines:\n- Extract directives (instructions to follow)\n- Extract decisions (choices made)\n- Extract code_patterns (coding conventions)\n- Extract requirements (project specs)\n- Extract errors (problems and solutions)\n- Extract insights (key realizations)\n- Extract preferences (user preferences)\n- Importance: 10=critical, 8-9=very important, 6-7=important, 1-5=nice to have\n- Tags: relevant keywords for categorization\n- Summary: max 50 chars\n\nConversation:\n${conversationText}\n\nOutput ONLY the JSON objects, one per line, no other text:`\n        }]\n      });\n\n      const content = response.content[0];\n      if (content.type !== 'text') {\n        return [];\n      }\n\n      // Parse JSON lines\n      const lines = content.text.split('\\n').filter(line => line.trim().startsWith('{'));\n      const extracted: ExtractedMemory[] = [];\n\n      for (const line of lines) {\n        try {\n          const parsed = JSON.parse(line.trim());\n\n          // Validate and normalize\n          if (parsed.content && parsed.type && parsed.importance) {\n            extracted.push({\n              content: parsed.content,\n              context_type: this.normalizeContextType(parsed.type),\n              importance: Math.min(10, Math.max(1, parseInt(parsed.importance))),\n              tags: Array.isArray(parsed.tags) ? parsed.tags : [],\n              summary: parsed.summary || undefined,\n            });\n          }\n        } catch (e) {\n          console.error('Failed to parse line:', line, e);\n          // Skip malformed JSON\n        }\n      }\n\n      return extracted;\n    } catch (error) {\n      console.error('Error analyzing conversation:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate a summary of a session\n   */\n  async summarizeSession(memories: Array<{ content: string; context_type: string; importance: number }>): Promise<string> {\n    try {\n      const memoriesText = memories\n        .sort((a, b) => b.importance - a.importance)\n        .map(m => `[${m.context_type}] ${m.content}`)\n        .join('\\n');\n\n      const response = await this.client.messages.create({\n        model: 'claude-3-5-haiku-20241022',\n        max_tokens: 500,\n        messages: [{\n          role: 'user',\n          content: `Summarize this work session in 2-3 sentences. Focus on what was accomplished, decided, or learned.\n\nSession memories:\n${memoriesText}\n\nSummary (2-3 sentences):`\n        }]\n      });\n\n      const content = response.content[0];\n      if (content.type === 'text') {\n        return content.text.trim();\n      }\n\n      return 'Session completed with multiple activities';\n    } catch (error) {\n      console.error('Error summarizing session:', error);\n      return 'Session summary unavailable';\n    }\n  }\n\n  /**\n   * Enhance a search query for better semantic matching\n   */\n  async enhanceQuery(currentTask: string, query?: string): Promise<string> {\n    const combined = query ? `${currentTask} ${query}` : currentTask;\n\n    // For now, just return the combined query\n    // Could use Claude to expand/enhance the query in the future\n    return combined;\n  }\n\n  /**\n   * Normalize context type strings from Claude\n   */\n  private normalizeContextType(type: string): ContextType {\n    const normalized = type.toLowerCase().trim();\n\n    const mapping: Record<string, ContextType> = {\n      'directive': 'directive',\n      'instruction': 'directive',\n      'command': 'directive',\n      'information': 'information',\n      'info': 'information',\n      'fact': 'information',\n      'heading': 'heading',\n      'section': 'heading',\n      'title': 'heading',\n      'decision': 'decision',\n      'choice': 'decision',\n      'code_pattern': 'code_pattern',\n      'pattern': 'code_pattern',\n      'convention': 'code_pattern',\n      'requirement': 'requirement',\n      'req': 'requirement',\n      'spec': 'requirement',\n      'error': 'error',\n      'bug': 'error',\n      'issue': 'error',\n      'todo': 'todo',\n      'task': 'todo',\n      'insight': 'insight',\n      'realization': 'insight',\n      'learning': 'insight',\n      'preference': 'preference',\n      'pref': 'preference',\n      'setting': 'preference',\n    };\n\n    return mapping[normalized] || 'information';\n  }\n}\n","import { z } from 'zod';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport {\n  ExportMemoriesSchema,\n  ImportMemoriesSchema,\n  FindDuplicatesSchema,\n  ConsolidateMemoriesSchema,\n  type ExportMemories,\n  type ImportMemories,\n  type FindDuplicates,\n  type ConsolidateMemories,\n  type MemoryEntry,\n  type DuplicateGroup,\n  type CreateMemory,\n} from '../types.js';\nimport { cosineSimilarity } from '../embeddings/generator.js';\n\n/**\n * Export memories to JSON format\n */\nexport async function exportMemories(\n  args: ExportMemories,\n  workspacePath?: string\n): Promise<{ content: Array<{ type: string; text: string }> }> {\n  const store = new MemoryStore(workspacePath);\n\n  // Get all memories or filtered subset\n  let memories: MemoryEntry[];\n\n  if (args.filter_by_type && args.filter_by_type.length > 0) {\n    // Get memories by types\n    const memoriesByType: MemoryEntry[] = [];\n    for (const type of args.filter_by_type) {\n      const typeMemories = await store.getMemoriesByType(type);\n      memoriesByType.push(...typeMemories);\n    }\n    // Deduplicate by ID\n    const uniqueMap = new Map<string, MemoryEntry>();\n    for (const memory of memoriesByType) {\n      uniqueMap.set(memory.id, memory);\n    }\n    memories = Array.from(uniqueMap.values());\n  } else {\n    // Get all memories via timeline\n    memories = await store.getRecentMemories(10000); // Large limit to get all\n  }\n\n  // Filter by importance if specified\n  if (args.min_importance !== undefined) {\n    memories = memories.filter(m => m.importance >= args.min_importance!);\n  }\n\n  // Remove embeddings if not requested\n  const exportData = memories.map(memory => {\n    if (!args.include_embeddings) {\n      const { embedding, ...rest } = memory;\n      return rest;\n    }\n    return memory;\n  });\n\n  const exportObject = {\n    version: '1.2.0',\n    exported_at: Date.now(),\n    memory_count: exportData.length,\n    memories: exportData,\n  };\n\n  const jsonString = JSON.stringify(exportObject, null, 2);\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: `Successfully exported ${exportData.length} memories\\n\\n${jsonString}`,\n      },\n    ],\n  };\n}\n\n/**\n * Import memories from JSON export\n */\nexport async function importMemories(\n  args: ImportMemories,\n  workspacePath?: string\n): Promise<{ content: Array<{ type: string; text: string }> }> {\n  const store = new MemoryStore(workspacePath);\n\n  let importData: any;\n  try {\n    importData = JSON.parse(args.data);\n  } catch (error) {\n    throw new Error(`Invalid JSON data: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  if (!importData.memories || !Array.isArray(importData.memories)) {\n    throw new Error('Invalid import format: missing memories array');\n  }\n\n  const results = {\n    imported: 0,\n    skipped: 0,\n    overwritten: 0,\n    errors: [] as string[],\n  };\n\n  for (const memoryData of importData.memories) {\n    try {\n      // Check if memory exists\n      const existing = await store.getMemory(memoryData.id);\n\n      if (existing && !args.overwrite_existing) {\n        results.skipped++;\n        continue;\n      }\n\n      // Prepare memory for creation\n      const createData: CreateMemory = {\n        content: memoryData.content,\n        context_type: memoryData.context_type,\n        tags: memoryData.tags || [],\n        importance: memoryData.importance || 5,\n        summary: memoryData.summary,\n        session_id: memoryData.session_id,\n        ttl_seconds: memoryData.ttl_seconds,\n      };\n\n      // Create or update memory\n      if (existing && args.overwrite_existing) {\n        await store.updateMemory(memoryData.id, createData);\n        results.overwritten++;\n      } else {\n        // For new imports, we'll create with the original ID by directly manipulating\n        // We need to recreate the memory with its original ID\n        // This is a special case for imports\n        const importedMemory: MemoryEntry = {\n          id: memoryData.id,\n          timestamp: memoryData.timestamp || Date.now(),\n          context_type: memoryData.context_type,\n          content: memoryData.content,\n          summary: memoryData.summary,\n          tags: memoryData.tags || [],\n          importance: memoryData.importance || 5,\n          session_id: memoryData.session_id,\n          embedding: args.regenerate_embeddings ? undefined : memoryData.embedding,\n          ttl_seconds: memoryData.ttl_seconds,\n          expires_at: memoryData.expires_at,\n        };\n\n        // If we need to regenerate embeddings, create normally\n        if (args.regenerate_embeddings) {\n          await store.createMemory(createData);\n        } else {\n          // Direct import preserving ID and embedding - we'll need a special method\n          // For now, create normally (this will generate new ID)\n          await store.createMemory(createData);\n        }\n        results.imported++;\n      }\n    } catch (error) {\n      results.errors.push(`Failed to import memory ${memoryData.id}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  const summary = [\n    `Import completed:`,\n    `- Imported: ${results.imported}`,\n    `- Overwritten: ${results.overwritten}`,\n    `- Skipped: ${results.skipped}`,\n    `- Errors: ${results.errors.length}`,\n  ];\n\n  if (results.errors.length > 0) {\n    summary.push('', 'Errors:', ...results.errors.slice(0, 10));\n    if (results.errors.length > 10) {\n      summary.push(`... and ${results.errors.length - 10} more errors`);\n    }\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: summary.join('\\n'),\n      },\n    ],\n  };\n}\n\n/**\n * Find duplicate memories based on similarity\n */\nexport async function findDuplicates(\n  args: FindDuplicates,\n  workspacePath?: string\n): Promise<{ content: Array<{ type: string; text: string }> }> {\n  const store = new MemoryStore(workspacePath);\n\n  // Get all memories\n  const memories = await store.getRecentMemories(10000);\n\n  // Group duplicates\n  const duplicateGroups: DuplicateGroup[] = [];\n  const processed = new Set<string>();\n\n  for (let i = 0; i < memories.length; i++) {\n    const memory1 = memories[i];\n\n    if (processed.has(memory1.id)) {\n      continue;\n    }\n\n    const similarMemories: MemoryEntry[] = [memory1];\n    let maxSimilarity = 0;\n\n    for (let j = i + 1; j < memories.length; j++) {\n      const memory2 = memories[j];\n\n      if (processed.has(memory2.id)) {\n        continue;\n      }\n\n      // Calculate similarity\n      if (memory1.embedding && memory2.embedding) {\n        const similarity = cosineSimilarity(memory1.embedding, memory2.embedding);\n\n        if (similarity >= args.similarity_threshold) {\n          similarMemories.push(memory2);\n          maxSimilarity = Math.max(maxSimilarity, similarity);\n          processed.add(memory2.id);\n        }\n      }\n    }\n\n    // If we found duplicates, add to groups\n    if (similarMemories.length > 1) {\n      duplicateGroups.push({\n        memories: similarMemories,\n        similarity_score: maxSimilarity,\n      });\n      processed.add(memory1.id);\n    }\n  }\n\n  // Auto-merge if requested\n  if (args.auto_merge && duplicateGroups.length > 0) {\n    let mergedCount = 0;\n\n    for (const group of duplicateGroups) {\n      try {\n        // Find memory to keep (highest importance)\n        const toKeep = args.keep_highest_importance\n          ? group.memories.reduce((prev, current) =>\n              current.importance > prev.importance ? current : prev\n            )\n          : group.memories[0];\n\n        // Merge tags from all memories\n        const allTags = new Set<string>();\n        for (const memory of group.memories) {\n          memory.tags.forEach(tag => allTags.add(tag));\n        }\n\n        // Update the memory to keep with merged tags\n        await store.updateMemory(toKeep.id, {\n          tags: Array.from(allTags),\n        });\n\n        // Delete the others\n        for (const memory of group.memories) {\n          if (memory.id !== toKeep.id) {\n            await store.deleteMemory(memory.id);\n            mergedCount++;\n          }\n        }\n      } catch (error) {\n        console.error(`Failed to merge duplicate group: ${error}`);\n      }\n    }\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Found ${duplicateGroups.length} duplicate groups and merged ${mergedCount} duplicate memories.`,\n        },\n      ],\n    };\n  }\n\n  // Just report duplicates\n  if (duplicateGroups.length === 0) {\n    return {\n      content: [\n        {\n          type: 'text',\n          text: 'No duplicate memories found.',\n        },\n      ],\n    };\n  }\n\n  const report = [\n    `Found ${duplicateGroups.length} duplicate groups:\\n`,\n  ];\n\n  for (let i = 0; i < duplicateGroups.length; i++) {\n    const group = duplicateGroups[i];\n    report.push(`Group ${i + 1} (similarity: ${group.similarity_score.toFixed(3)}):`);\n\n    for (const memory of group.memories) {\n      report.push(`  - ID: ${memory.id} | Importance: ${memory.importance} | Summary: ${memory.summary || memory.content.substring(0, 50)}`);\n    }\n    report.push('');\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: report.join('\\n'),\n      },\n    ],\n  };\n}\n\n/**\n * Consolidate multiple memories into one\n */\nexport async function consolidateMemories(\n  args: ConsolidateMemories,\n  workspacePath?: string\n): Promise<{ content: Array<{ type: string; text: string }> }> {\n  const store = new MemoryStore(workspacePath);\n\n  const result = await store.mergeMemories(args.memory_ids, args.keep_id);\n\n  if (!result) {\n    return {\n      content: [\n        {\n          type: 'text',\n          text: 'Failed to consolidate memories. Check that all memory IDs exist.',\n        },\n      ],\n    };\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: `Successfully consolidated ${args.memory_ids.length} memories into ID: ${result.id}\\n\\nMerged Memory:\\n- Content: ${result.summary || result.content.substring(0, 100)}\\n- Tags: ${result.tags.join(', ')}\\n- Importance: ${result.importance}`,\n      },\n    ],\n  };\n}\n\n// Tool definitions for MCP\nexport const exportImportTools = {\n  export_memories: {\n    description: 'Export memories to JSON format with optional filtering',\n    inputSchema: ExportMemoriesSchema,\n    handler: exportMemories,\n  },\n  import_memories: {\n    description: 'Import memories from JSON export data',\n    inputSchema: ImportMemoriesSchema,\n    handler: importMemories,\n  },\n  find_duplicates: {\n    description: 'Find and optionally merge duplicate memories based on similarity',\n    inputSchema: FindDuplicatesSchema,\n    handler: findDuplicates,\n  },\n  consolidate_memories: {\n    description: 'Manually consolidate multiple memories into one',\n    inputSchema: ConsolidateMemoriesSchema,\n    handler: consolidateMemories,\n  },\n};\n","import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport type { ContextType } from '../types.js';\nimport { getAnalytics } from './analytics.js';\n\nconst memoryStore = new MemoryStore();\n\nexport const resources = {\n  'memory://recent': {\n    name: 'Recent Memories',\n    description: 'Get the most recent memories (default: 50)',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const limit = parseInt(uri.searchParams.get('limit') || '50', 10);\n      const memories = await memoryStore.getRecentMemories(limit);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                count: memories.length,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  context_type: m.context_type,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                  session_id: m.session_id,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://by-type/{type}': {\n    name: 'Memories by Type',\n    description: 'Get memories filtered by context type',\n    mimeType: 'application/json',\n    handler: async (uri: URL, params: { type: string }) => {\n      const type = params.type as ContextType;\n      const limit = uri.searchParams.get('limit') ? parseInt(uri.searchParams.get('limit')!, 10) : undefined;\n\n      const memories = await memoryStore.getMemoriesByType(type, limit);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                context_type: type,\n                count: memories.length,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://by-tag/{tag}': {\n    name: 'Memories by Tag',\n    description: 'Get memories filtered by tag',\n    mimeType: 'application/json',\n    handler: async (uri: URL, params: { tag: string }) => {\n      const { tag } = params;\n      const limit = uri.searchParams.get('limit') ? parseInt(uri.searchParams.get('limit')!, 10) : undefined;\n\n      const memories = await memoryStore.getMemoriesByTag(tag, limit);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                tag,\n                count: memories.length,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  context_type: m.context_type,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://important': {\n    name: 'Important Memories',\n    description: 'Get high-importance memories (importance >= 8)',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const minImportance = parseInt(uri.searchParams.get('min') || '8', 10);\n      const limit = uri.searchParams.get('limit') ? parseInt(uri.searchParams.get('limit')!, 10) : undefined;\n\n      const memories = await memoryStore.getImportantMemories(minImportance, limit);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                min_importance: minImportance,\n                count: memories.length,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  context_type: m.context_type,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://session/{session_id}': {\n    name: 'Session Memories',\n    description: 'Get all memories in a specific session',\n    mimeType: 'application/json',\n    handler: async (uri: URL, params: { session_id: string }) => {\n      const { session_id } = params;\n      const session = await memoryStore.getSession(session_id);\n\n      if (!session) {\n        throw new McpError(ErrorCode.InvalidRequest, `Session ${session_id} not found`);\n      }\n\n      const memories = await memoryStore.getSessionMemories(session_id);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                session_id: session.session_id,\n                session_name: session.session_name,\n                created_at: session.created_at,\n                summary: session.summary,\n                count: memories.length,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  context_type: m.context_type,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://sessions': {\n    name: 'All Sessions',\n    description: 'Get list of all sessions',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const sessions = await memoryStore.getAllSessions();\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                count: sessions.length,\n                sessions: sessions.map(s => ({\n                  session_id: s.session_id,\n                  session_name: s.session_name,\n                  created_at: s.created_at,\n                  memory_count: s.memory_count,\n                  summary: s.summary,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://summary': {\n    name: 'Memory Summary',\n    description: 'Get overall summary statistics of stored memories',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const stats = await memoryStore.getSummaryStats();\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(stats, null, 2),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://search': {\n    name: 'Search Memories',\n    description: 'Search memories using semantic similarity',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const query = uri.searchParams.get('q');\n      if (!query) {\n        throw new McpError(ErrorCode.InvalidRequest, 'Query parameter \"q\" is required');\n      }\n\n      const limit = parseInt(uri.searchParams.get('limit') || '10', 10);\n      const minImportance = uri.searchParams.get('min_importance')\n        ? parseInt(uri.searchParams.get('min_importance')!, 10)\n        : undefined;\n\n      const results = await memoryStore.searchMemories(query, limit, minImportance);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                query,\n                count: results.length,\n                results: results.map(r => ({\n                  memory_id: r.id,\n                  content: r.content,\n                  summary: r.summary,\n                  context_type: r.context_type,\n                  importance: r.importance,\n                  tags: r.tags,\n                  similarity: r.similarity,\n                  timestamp: r.timestamp,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://analytics': {\n    name: 'Memory Analytics',\n    description: 'Get detailed analytics about memory usage and trends',\n    mimeType: 'text/markdown',\n    handler: async (uri: URL) => {\n      const analytics = await getAnalytics();\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'text/markdown',\n            text: analytics,\n          },\n        ],\n      };\n    },\n  },\n};\n","import { MemoryStore } from '../redis/memory-store.js';\nimport type { MemoryEntry } from '../types.js';\n\nexport interface AnalyticsData {\n  overview: {\n    total_memories: number;\n    by_type: Record<string, number>;\n    total_sessions: number;\n    important_count: number;\n    workspace_path: string;\n  };\n  trends: {\n    memories_last_24h: number;\n    memories_last_7d: number;\n    memories_last_30d: number;\n    most_active_types_24h: Array<{ type: string; count: number }>;\n  };\n  top_tags: Array<{ tag: string; count: number }>;\n  importance_distribution: {\n    critical: number; // 9-10\n    high: number; // 7-8\n    medium: number; // 5-6\n    low: number; // 1-4\n  };\n  recent_activity: Array<{\n    date: string;\n    count: number;\n    types: Record<string, number>;\n  }>;\n}\n\nexport async function getAnalytics(workspacePath?: string): Promise<string> {\n  const store = new MemoryStore(workspacePath);\n\n  // Get summary stats\n  const stats = await store.getSummaryStats();\n\n  // Get recent memories for trend analysis\n  const recentMemories = await store.getRecentMemories(1000);\n\n  // Calculate time-based trends\n  const now = Date.now();\n  const day24h = now - 24 * 60 * 60 * 1000;\n  const day7d = now - 7 * 24 * 60 * 60 * 1000;\n  const day30d = now - 30 * 24 * 60 * 60 * 1000;\n\n  const memories24h = recentMemories.filter(m => m.timestamp >= day24h);\n  const memories7d = recentMemories.filter(m => m.timestamp >= day7d);\n  const memories30d = recentMemories.filter(m => m.timestamp >= day30d);\n\n  // Most active types in last 24h\n  const typeCount24h = new Map<string, number>();\n  for (const memory of memories24h) {\n    typeCount24h.set(memory.context_type, (typeCount24h.get(memory.context_type) || 0) + 1);\n  }\n  const mostActiveTypes24h = Array.from(typeCount24h.entries())\n    .map(([type, count]) => ({ type, count }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 5);\n\n  // Tag frequency\n  const tagCount = new Map<string, number>();\n  for (const memory of recentMemories) {\n    for (const tag of memory.tags) {\n      tagCount.set(tag, (tagCount.get(tag) || 0) + 1);\n    }\n  }\n  const topTags = Array.from(tagCount.entries())\n    .map(([tag, count]) => ({ tag, count }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 10);\n\n  // Importance distribution\n  const importanceDist = {\n    critical: recentMemories.filter(m => m.importance >= 9).length,\n    high: recentMemories.filter(m => m.importance >= 7 && m.importance < 9).length,\n    medium: recentMemories.filter(m => m.importance >= 5 && m.importance < 7).length,\n    low: recentMemories.filter(m => m.importance < 5).length,\n  };\n\n  // Recent activity by day (last 7 days)\n  const activityByDay = new Map<string, { count: number; types: Map<string, number> }>();\n  const last7Days = [];\n  for (let i = 6; i >= 0; i--) {\n    const date = new Date(now - i * 24 * 60 * 60 * 1000);\n    const dateStr = date.toISOString().split('T')[0];\n    last7Days.push(dateStr);\n    activityByDay.set(dateStr, { count: 0, types: new Map() });\n  }\n\n  for (const memory of memories7d) {\n    const dateStr = new Date(memory.timestamp).toISOString().split('T')[0];\n    const activity = activityByDay.get(dateStr);\n    if (activity) {\n      activity.count++;\n      activity.types.set(memory.context_type, (activity.types.get(memory.context_type) || 0) + 1);\n    }\n  }\n\n  const recentActivity = last7Days.map(date => {\n    const activity = activityByDay.get(date)!;\n    return {\n      date,\n      count: activity.count,\n      types: Object.fromEntries(activity.types),\n    };\n  });\n\n  // Build analytics data\n  const analytics: AnalyticsData = {\n    overview: stats,\n    trends: {\n      memories_last_24h: memories24h.length,\n      memories_last_7d: memories7d.length,\n      memories_last_30d: memories30d.length,\n      most_active_types_24h: mostActiveTypes24h,\n    },\n    top_tags: topTags,\n    importance_distribution: importanceDist,\n    recent_activity: recentActivity,\n  };\n\n  // Format as readable text\n  return formatAnalytics(analytics);\n}\n\nfunction formatAnalytics(data: AnalyticsData): string {\n  const lines = [\n    '# Memory Analytics Dashboard',\n    '',\n    `**Workspace**: ${data.overview.workspace_path}`,\n    '',\n    '## Overview',\n    `- Total Memories: ${data.overview.total_memories}`,\n    `- Sessions: ${data.overview.total_sessions}`,\n    `- Important Memories (8): ${data.overview.important_count}`,\n    '',\n    '### Memories by Type',\n  ];\n\n  for (const [type, count] of Object.entries(data.overview.by_type)) {\n    if (count > 0) {\n      lines.push(`- ${type}: ${count}`);\n    }\n  }\n\n  lines.push('', '## Recent Activity Trends');\n  lines.push(`- Last 24 hours: ${data.trends.memories_last_24h} memories`);\n  lines.push(`- Last 7 days: ${data.trends.memories_last_7d} memories`);\n  lines.push(`- Last 30 days: ${data.trends.memories_last_30d} memories`);\n\n  if (data.trends.most_active_types_24h.length > 0) {\n    lines.push('', '### Most Active Types (24h)');\n    for (const { type, count } of data.trends.most_active_types_24h) {\n      lines.push(`- ${type}: ${count}`);\n    }\n  }\n\n  if (data.top_tags.length > 0) {\n    lines.push('', '## Top Tags');\n    for (const { tag, count } of data.top_tags) {\n      lines.push(`- ${tag}: ${count}`);\n    }\n  }\n\n  lines.push('', '## Importance Distribution');\n  lines.push(`- Critical (9-10): ${data.importance_distribution.critical}`);\n  lines.push(`- High (7-8): ${data.importance_distribution.high}`);\n  lines.push(`- Medium (5-6): ${data.importance_distribution.medium}`);\n  lines.push(`- Low (1-4): ${data.importance_distribution.low}`);\n\n  lines.push('', '## Activity Last 7 Days');\n  for (const activity of data.recent_activity) {\n    const typeSummary = Object.entries(activity.types)\n      .map(([type, count]) => `${type}:${count}`)\n      .join(', ');\n    lines.push(`- ${activity.date}: ${activity.count} memories ${typeSummary ? `(${typeSummary})` : ''}`);\n  }\n\n  return lines.join('\\n');\n}\n","import type { MemoryEntry } from '../types.js';\n\n/**\n * Format workspace context for Claude to read\n */\nexport function formatWorkspaceContext(\n  workspacePath: string,\n  directives: MemoryEntry[],\n  decisions: MemoryEntry[],\n  patterns: MemoryEntry[]\n): string {\n  const sections: string[] = [];\n\n  // Header\n  sections.push(`# Workspace Context: ${workspacePath}`);\n  sections.push('');\n  sections.push('*Critical information to remember for this project*');\n  sections.push('');\n\n  // Directives (sorted by importance)\n  if (directives.length > 0) {\n    sections.push('##  Critical Directives');\n    sections.push('');\n    const sorted = directives.sort((a, b) => b.importance - a.importance);\n    for (const dir of sorted.slice(0, 10)) {\n      sections.push(`- **[Importance: ${dir.importance}/10]** ${dir.content}`);\n      if (dir.tags.length > 0) {\n        sections.push(`  *Tags: ${dir.tags.join(', ')}*`);\n      }\n    }\n    sections.push('');\n  }\n\n  // Decisions (sorted by importance)\n  if (decisions.length > 0) {\n    sections.push('##  Key Decisions');\n    sections.push('');\n    const sorted = decisions.sort((a, b) => b.importance - a.importance);\n    for (const dec of sorted.slice(0, 8)) {\n      const age = getAgeString(dec.timestamp);\n      sections.push(`- **[${age}]** ${dec.content}`);\n    }\n    sections.push('');\n  }\n\n  // Code Patterns (sorted by importance)\n  if (patterns.length > 0) {\n    sections.push('##  Code Patterns & Conventions');\n    sections.push('');\n    const sorted = patterns.sort((a, b) => b.importance - a.importance);\n    for (const pat of sorted.slice(0, 8)) {\n      sections.push(`- ${pat.content}`);\n      if (pat.tags.length > 0) {\n        sections.push(`  *Applies to: ${pat.tags.join(', ')}*`);\n      }\n    }\n    sections.push('');\n  }\n\n  if (directives.length === 0 && decisions.length === 0 && patterns.length === 0) {\n    sections.push('*No critical context stored yet. As we work, I\\'ll remember important patterns and decisions.*');\n  }\n\n  sections.push('');\n  sections.push('---');\n  sections.push('*This context is automatically injected to help me remember important project conventions and decisions.*');\n\n  return sections.join('\\n');\n}\n\n/**\n * Format memories for concise display\n */\nexport function formatMemoriesCompact(memories: MemoryEntry[]): string {\n  if (memories.length === 0) {\n    return '*No relevant memories found*';\n  }\n\n  const lines: string[] = [];\n\n  for (const mem of memories) {\n    const age = getAgeString(mem.timestamp);\n    const importance = ''.repeat(Math.min(mem.importance, 5));\n    lines.push(`[${age}] ${importance} ${mem.summary || mem.content.substring(0, 80)}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Get human-readable age string\n */\nfunction getAgeString(timestamp: number): string {\n  const ageMs = Date.now() - timestamp;\n  const ageMinutes = Math.floor(ageMs / (1000 * 60));\n  const ageHours = Math.floor(ageMs / (1000 * 60 * 60));\n  const ageDays = Math.floor(ageMs / (1000 * 60 * 60 * 24));\n\n  if (ageDays > 0) {\n    return `${ageDays}d ago`;\n  } else if (ageHours > 0) {\n    return `${ageHours}h ago`;\n  } else if (ageMinutes > 0) {\n    return `${ageMinutes}m ago`;\n  } else {\n    return 'just now';\n  }\n}\n","import { MemoryStore } from '../redis/memory-store.js';\nimport { formatWorkspaceContext } from './formatters.js';\n\nconst memoryStore = new MemoryStore();\n\nexport const prompts = {\n  workspace_context: {\n    name: 'workspace_context',\n    description: 'Critical workspace context: directives, decisions, and code patterns',\n    arguments: [],\n    handler: async () => {\n      // Get important memories\n      const directives = await memoryStore.getMemoriesByType('directive');\n      const decisions = await memoryStore.getMemoriesByType('decision');\n      const patterns = await memoryStore.getMemoriesByType('code_pattern');\n\n      // Filter to high-importance only\n      const importantDirectives = directives.filter(d => d.importance >= 8);\n      const importantDecisions = decisions.filter(d => d.importance >= 7);\n      const importantPatterns = patterns.filter(p => p.importance >= 7);\n\n      // Get workspace path from memoryStore\n      const stats = await memoryStore.getSummaryStats();\n      const workspacePath = stats.workspace_path;\n\n      // Format for Claude\n      const contextText = formatWorkspaceContext(\n        workspacePath,\n        importantDirectives,\n        importantDecisions,\n        importantPatterns\n      );\n\n      return {\n        description: 'Workspace-specific context and conventions',\n        messages: [\n          {\n            role: 'user' as const,\n            content: {\n              type: 'text' as const,\n              text: contextText,\n            },\n          },\n        ],\n      };\n    },\n  },\n};\n\n// Export list for MCP server\nexport async function listPrompts() {\n  return Object.values(prompts).map(p => ({\n    name: p.name,\n    description: p.description,\n    arguments: p.arguments,\n  }));\n}\n\n// Export getter for MCP server\nexport async function getPrompt(name: string) {\n  const prompt = prompts[name as keyof typeof prompts];\n  if (!prompt) {\n    throw new Error(`Unknown prompt: ${name}`);\n  }\n\n  return await prompt.handler();\n}\n"],"mappings":"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","names":["z","McpError","ErrorCode","globalData","wsData","z","Anthropic","z","memoryStore","zodToJsonSchema","McpError","ErrorCode","z","zodToJsonSchemaInner","McpError","ErrorCode","memoryStore","McpError","ErrorCode","memoryStore"]}