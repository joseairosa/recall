{"version":3,"sources":["../src/index.ts","../src/redis/client.ts","../src/tools/index.ts","../src/redis/memory-store.ts","../src/embeddings/generator.ts","../src/types.ts","../src/tools/context-tools.ts","../src/analysis/conversation-analyzer.ts","../src/tools/export-import-tools.ts","../node_modules/zod-to-json-schema/dist/esm/Options.js","../node_modules/zod-to-json-schema/dist/esm/Refs.js","../node_modules/zod-to-json-schema/dist/esm/errorMessages.js","../node_modules/zod-to-json-schema/dist/esm/getRelativePath.js","../node_modules/zod-to-json-schema/dist/esm/selectParser.js","../node_modules/zod-to-json-schema/dist/esm/parsers/any.js","../node_modules/zod-to-json-schema/dist/esm/parsers/array.js","../node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js","../node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js","../node_modules/zod-to-json-schema/dist/esm/parsers/branded.js","../node_modules/zod-to-json-schema/dist/esm/parsers/catch.js","../node_modules/zod-to-json-schema/dist/esm/parsers/date.js","../node_modules/zod-to-json-schema/dist/esm/parsers/default.js","../node_modules/zod-to-json-schema/dist/esm/parsers/effects.js","../node_modules/zod-to-json-schema/dist/esm/parsers/enum.js","../node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js","../node_modules/zod-to-json-schema/dist/esm/parsers/literal.js","../node_modules/zod-to-json-schema/dist/esm/parsers/record.js","../node_modules/zod-to-json-schema/dist/esm/parsers/string.js","../node_modules/zod-to-json-schema/dist/esm/parsers/map.js","../node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js","../node_modules/zod-to-json-schema/dist/esm/parsers/never.js","../node_modules/zod-to-json-schema/dist/esm/parsers/null.js","../node_modules/zod-to-json-schema/dist/esm/parsers/union.js","../node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js","../node_modules/zod-to-json-schema/dist/esm/parsers/number.js","../node_modules/zod-to-json-schema/dist/esm/parsers/object.js","../node_modules/zod-to-json-schema/dist/esm/parsers/optional.js","../node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js","../node_modules/zod-to-json-schema/dist/esm/parsers/promise.js","../node_modules/zod-to-json-schema/dist/esm/parsers/set.js","../node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js","../node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js","../node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js","../node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js","../node_modules/zod-to-json-schema/dist/esm/parseDef.js","../node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js","../src/tools/relationship-tools.ts","../src/tools/version-tools.ts","../src/tools/template-tools.ts","../src/tools/category-tools.ts","../src/resources/index.ts","../src/resources/analytics.ts","../src/prompts/formatters.ts","../src/prompts/index.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  ReadResourceRequestSchema,\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport { checkRedisConnection, closeRedisClient } from './redis/client.js';\nimport { tools } from './tools/index.js';\nimport { resources } from './resources/index.js';\nimport { listPrompts, getPrompt } from './prompts/index.js';\n\n// Create server instance\nconst server = new Server(\n  {\n    name: '@joseairosa/recall',\n    version: '1.5.0',\n  },\n  {\n    capabilities: {\n      resources: {},\n      tools: {},\n      prompts: {},\n    },\n  }\n);\n\n// List available tools\nserver.setRequestHandler(ListToolsRequestSchema, async () => {\n  return {\n    tools: Object.entries(tools).map(([name, tool]) => ({\n      name,\n      description: tool.description,\n      inputSchema: tool.inputSchema,\n    })),\n  };\n});\n\n// Handle tool calls\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  const { name, arguments: args } = request.params;\n\n  const tool = tools[name as keyof typeof tools];\n  if (!tool) {\n    throw new Error(`Unknown tool: ${name}`);\n  }\n\n  return await tool.handler(args as any);\n});\n\n// List available resources\nserver.setRequestHandler(ListResourcesRequestSchema, async () => {\n  return {\n    resources: [\n      {\n        uri: 'memory://recent',\n        name: 'Recent Memories',\n        description: 'Get the most recent memories (default: 50)',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://by-type/{type}',\n        name: 'Memories by Type',\n        description: 'Get memories filtered by context type (directive, information, heading, decision, code_pattern, requirement, error, todo, insight, preference)',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://by-tag/{tag}',\n        name: 'Memories by Tag',\n        description: 'Get memories filtered by tag',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://important',\n        name: 'Important Memories',\n        description: 'Get high-importance memories (importance >= 8)',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://session/{session_id}',\n        name: 'Session Memories',\n        description: 'Get all memories in a specific session',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://sessions',\n        name: 'All Sessions',\n        description: 'Get list of all sessions',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://summary',\n        name: 'Memory Summary',\n        description: 'Get overall summary statistics',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'memory://search',\n        name: 'Search Memories',\n        description: 'Search memories using semantic similarity. Requires query parameter \"q\"',\n        mimeType: 'application/json',\n      },\n    ],\n  };\n});\n\n// Handle resource reads\nserver.setRequestHandler(ReadResourceRequestSchema, async (request) => {\n  const uriString = request.params.uri;\n  const uri = new URL(uriString);\n\n  // For memory:// URIs, resource name is hostname + pathname\n  const resourcePath = uri.hostname + uri.pathname;\n\n  // Match resource patterns\n  if (resourcePath === 'recent') {\n    return await resources['memory://recent'].handler(uri);\n  }\n\n  if (resourcePath === 'important') {\n    return await resources['memory://important'].handler(uri);\n  }\n\n  if (resourcePath === 'sessions') {\n    return await resources['memory://sessions'].handler(uri);\n  }\n\n  if (resourcePath === 'summary') {\n    return await resources['memory://summary'].handler(uri);\n  }\n\n  if (resourcePath === 'search') {\n    return await resources['memory://search'].handler(uri);\n  }\n\n  if (resourcePath === 'analytics') {\n    return await resources['memory://analytics'].handler(uri);\n  }\n\n  // Pattern matching for parameterized resources\n  const typeMatch = resourcePath.match(/^by-type\\/(.+)$/);\n  if (typeMatch) {\n    return await resources['memory://by-type/{type}'].handler(uri, { type: typeMatch[1] });\n  }\n\n  const tagMatch = resourcePath.match(/^by-tag\\/(.+)$/);\n  if (tagMatch) {\n    return await resources['memory://by-tag/{tag}'].handler(uri, { tag: tagMatch[1] });\n  }\n\n  const sessionMatch = resourcePath.match(/^session\\/(.+)$/);\n  if (sessionMatch) {\n    return await resources['memory://session/{session_id}'].handler(uri, { session_id: sessionMatch[1] });\n  }\n\n  throw new Error(`Unknown resource: ${request.params.uri}`);\n});\n\n// List available prompts\nserver.setRequestHandler(ListPromptsRequestSchema, async () => {\n  const promptsList = await listPrompts();\n  return {\n    prompts: promptsList,\n  };\n});\n\n// Get prompt\nserver.setRequestHandler(GetPromptRequestSchema, async (request) => {\n  const promptResult = await getPrompt(request.params.name);\n  return promptResult;\n});\n\n// Start server\nasync function main() {\n  // Check Redis connection\n  console.error('Checking Redis connection...');\n  const isConnected = await checkRedisConnection();\n\n  if (!isConnected) {\n    console.error('ERROR: Failed to connect to Redis');\n    console.error('Please ensure Redis is running and REDIS_URL is set correctly');\n    process.exit(1);\n  }\n\n  console.error('Redis connection successful');\n\n  // Create transport\n  const transport = new StdioServerTransport();\n\n  // Connect server to transport\n  await server.connect(transport);\n\n  console.error('Recall MCP Server started successfully');\n  console.error('Listening on stdio...');\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.error('\\nShutting down...');\n  await closeRedisClient();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  console.error('\\nShutting down...');\n  await closeRedisClient();\n  process.exit(0);\n});\n\n// Start the server\nmain().catch((error) => {\n  console.error('Fatal error:', error);\n  process.exit(1);\n});\n","import Redis from 'ioredis';\n\nlet redisClient: Redis | null = null;\n\nexport function getRedisClient(): Redis {\n  if (!redisClient) {\n    const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';\n\n    redisClient = new Redis(redisUrl, {\n      maxRetriesPerRequest: 3,\n      retryStrategy(times) {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      reconnectOnError(err) {\n        const targetError = 'READONLY';\n        if (err.message.includes(targetError)) {\n          // Reconnect on READONLY errors\n          return true;\n        }\n        return false;\n      },\n    });\n\n    redisClient.on('error', (err) => {\n      console.error('Redis Client Error:', err);\n    });\n\n    redisClient.on('connect', () => {\n      console.error('Redis Client Connected');\n    });\n\n    redisClient.on('ready', () => {\n      console.error('Redis Client Ready');\n    });\n  }\n\n  return redisClient;\n}\n\nexport async function closeRedisClient(): Promise<void> {\n  if (redisClient) {\n    await redisClient.quit();\n    redisClient = null;\n  }\n}\n\n// Health check\nexport async function checkRedisConnection(): Promise<boolean> {\n  try {\n    const client = getRedisClient();\n    const result = await client.ping();\n    return result === 'PONG';\n  } catch (error) {\n    console.error('Redis connection check failed:', error);\n    return false;\n  }\n}\n","import { z } from 'zod';\nimport { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport {\n  CreateMemorySchema,\n  BatchCreateMemoriesSchema,\n  UpdateMemorySchema,\n  DeleteMemorySchema,\n  SearchMemorySchema,\n  OrganizeSessionSchema,\n  ConvertToGlobalSchema,\n  ConvertToWorkspaceSchema,\n} from '../types.js';\nimport {\n  recall_relevant_context,\n  analyze_and_remember,\n  summarize_session,\n} from './context-tools.js';\nimport {\n  exportMemories,\n  importMemories,\n  findDuplicates,\n  consolidateMemories,\n} from './export-import-tools.js';\nimport {\n  ExportMemoriesSchema,\n  ImportMemoriesSchema,\n  FindDuplicatesSchema,\n  ConsolidateMemoriesSchema,\n} from '../types.js';\nimport { relationshipTools } from './relationship-tools.js';\nimport { versionTools } from './version-tools.js';\nimport { templateTools } from './template-tools.js';\nimport { categoryTools } from './category-tools.js';\n\nconst memoryStore = new MemoryStore();\n\nexport const tools = {\n  // Context management tools\n  recall_relevant_context,\n  analyze_and_remember,\n  summarize_session,\n\n  // Export/Import tools\n  export_memories: {\n    description: 'Export memories to JSON format with optional filtering',\n    inputSchema: zodToJsonSchema(ExportMemoriesSchema),\n    handler: async (args: z.infer<typeof ExportMemoriesSchema>) => {\n      try {\n        return await exportMemories(args);\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to export memories: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  import_memories: {\n    description: 'Import memories from JSON export data',\n    inputSchema: zodToJsonSchema(ImportMemoriesSchema),\n    handler: async (args: z.infer<typeof ImportMemoriesSchema>) => {\n      try {\n        return await importMemories(args);\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to import memories: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  find_duplicates: {\n    description: 'Find and optionally merge duplicate memories based on similarity',\n    inputSchema: zodToJsonSchema(FindDuplicatesSchema),\n    handler: async (args: z.infer<typeof FindDuplicatesSchema>) => {\n      try {\n        return await findDuplicates(args);\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to find duplicates: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  consolidate_memories: {\n    description: 'Manually consolidate multiple memories into one',\n    inputSchema: zodToJsonSchema(ConsolidateMemoriesSchema),\n    handler: async (args: z.infer<typeof ConsolidateMemoriesSchema>) => {\n      try {\n        return await consolidateMemories(args);\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to consolidate memories: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  // Original memory tools\n  store_memory: {\n    description: 'Store a new memory/context entry for long-term persistence',\n    inputSchema: zodToJsonSchema(CreateMemorySchema),\n    handler: async (args: z.infer<typeof CreateMemorySchema>) => {\n      try {\n        const memory = await memoryStore.createMemory(args);\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                memory_id: memory.id,\n                timestamp: memory.timestamp,\n                summary: memory.summary,\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to store memory: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  store_batch_memories: {\n    description: 'Store multiple memories in a batch operation',\n    inputSchema: zodToJsonSchema(BatchCreateMemoriesSchema),\n    handler: async (args: z.infer<typeof BatchCreateMemoriesSchema>) => {\n      try {\n        const memories = await memoryStore.createMemories(args.memories);\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                count: memories.length,\n                memory_ids: memories.map(m => m.id),\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to store memories: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  update_memory: {\n    description: 'Update an existing memory entry',\n    inputSchema: zodToJsonSchema(UpdateMemorySchema),\n    handler: async (args: z.infer<typeof UpdateMemorySchema>) => {\n      try {\n        const { memory_id, ...updates } = args;\n        const memory = await memoryStore.updateMemory(memory_id, updates);\n\n        if (!memory) {\n          throw new McpError(ErrorCode.InvalidRequest, `Memory ${memory_id} not found`);\n        }\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                memory_id: memory.id,\n                updated_at: Date.now(),\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to update memory: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  delete_memory: {\n    description: 'Delete a memory entry',\n    inputSchema: zodToJsonSchema(DeleteMemorySchema),\n    handler: async (args: z.infer<typeof DeleteMemorySchema>) => {\n      try {\n        const success = await memoryStore.deleteMemory(args.memory_id);\n\n        if (!success) {\n          throw new McpError(ErrorCode.InvalidRequest, `Memory ${args.memory_id} not found`);\n        }\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                memory_id: args.memory_id,\n                deleted_at: Date.now(),\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to delete memory: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  search_memories: {\n    description: 'Search memories using semantic similarity with advanced filters (v1.5.0: category, fuzzy, regex)',\n    inputSchema: zodToJsonSchema(SearchMemorySchema),\n    handler: async (args: z.infer<typeof SearchMemorySchema>) => {\n      try {\n        const results = await memoryStore.searchMemories(\n          args.query,\n          args.limit,\n          args.min_importance,\n          args.context_types,\n          args.category,\n          args.fuzzy,\n          args.regex\n        );\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                query: args.query,\n                count: results.length,\n                filters: {\n                  category: args.category,\n                  fuzzy: args.fuzzy,\n                  regex: args.regex,\n                  min_importance: args.min_importance,\n                  context_types: args.context_types,\n                },\n                results: results.map(r => ({\n                  memory_id: r.id,\n                  content: r.content,\n                  summary: r.summary,\n                  context_type: r.context_type,\n                  importance: r.importance,\n                  tags: r.tags,\n                  category: r.category,\n                  similarity: r.similarity,\n                  timestamp: r.timestamp,\n                })),\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to search memories: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  organize_session: {\n    description: 'Create a session snapshot grouping related memories',\n    inputSchema: zodToJsonSchema(OrganizeSessionSchema),\n    handler: async (args: z.infer<typeof OrganizeSessionSchema>) => {\n      try {\n        const session = await memoryStore.createSession(\n          args.session_name,\n          args.memory_ids,\n          args.summary\n        );\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                session_id: session.session_id,\n                session_name: session.session_name,\n                memory_count: session.memory_count,\n                created_at: session.created_at,\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to organize session: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  // Global memory conversion tools\n  convert_to_global: {\n    description: 'Convert a workspace-specific memory to global (accessible across all workspaces)',\n    inputSchema: zodToJsonSchema(ConvertToGlobalSchema),\n    handler: async (args: z.infer<typeof ConvertToGlobalSchema>) => {\n      try {\n        const result = await memoryStore.convertToGlobal(args.memory_id);\n\n        if (!result) {\n          throw new McpError(\n            ErrorCode.InvalidRequest,\n            `Memory not found: ${args.memory_id}`\n          );\n        }\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                memory_id: result.id,\n                is_global: result.is_global,\n                content: result.content,\n                message: 'Memory converted to global successfully',\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to convert memory to global: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  convert_to_workspace: {\n    description: 'Convert a global memory to workspace-specific',\n    inputSchema: zodToJsonSchema(ConvertToWorkspaceSchema),\n    handler: async (args: z.infer<typeof ConvertToWorkspaceSchema>) => {\n      try {\n        const result = await memoryStore.convertToWorkspace(\n          args.memory_id,\n          args.workspace_id\n        );\n\n        if (!result) {\n          throw new McpError(\n            ErrorCode.InvalidRequest,\n            `Memory not found: ${args.memory_id}`\n          );\n        }\n\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                memory_id: result.id,\n                is_global: result.is_global,\n                workspace_id: result.workspace_id,\n                content: result.content,\n                message: 'Memory converted to workspace-specific successfully',\n              }, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Failed to convert memory to workspace: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n\n  // Relationship tools (v1.4.0)\n  ...relationshipTools,\n\n  // Version history tools (v1.5.0)\n  ...versionTools,\n\n  // Template tools (v1.5.0)\n  ...templateTools,\n\n  // Category tools (v1.5.0)\n  ...categoryTools,\n};\n\n// Helper function to convert Zod schema to JSON Schema\nfunction zodToJsonSchema(schema: z.ZodType): any {\n  // Simple conversion - in production you'd use @anatine/zod-to-json-schema\n  if (schema instanceof z.ZodObject) {\n    const shape = schema._def.shape();\n    const properties: any = {};\n    const required: string[] = [];\n\n    for (const [key, value] of Object.entries(shape)) {\n      properties[key] = zodToJsonSchemaInner(value as z.ZodType);\n      if (!(value as any).isOptional()) {\n        required.push(key);\n      }\n    }\n\n    return {\n      type: 'object',\n      properties,\n      required,\n    };\n  }\n\n  return zodToJsonSchemaInner(schema);\n}\n\nfunction zodToJsonSchemaInner(schema: z.ZodType): any {\n  if (schema instanceof z.ZodString) {\n    const result: any = { type: 'string' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodNumber) {\n    const result: any = { type: 'number' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodBoolean) {\n    const result: any = { type: 'boolean' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodArray) {\n    const result: any = {\n      type: 'array',\n      items: zodToJsonSchemaInner(schema.element),\n    };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodEnum) {\n    const result: any = {\n      type: 'string',\n      enum: schema.options,\n    };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodOptional) {\n    return zodToJsonSchemaInner(schema.unwrap());\n  }\n\n  if (schema instanceof z.ZodDefault) {\n    const inner = zodToJsonSchemaInner(schema._def.innerType);\n    inner.default = schema._def.defaultValue();\n    return inner;\n  }\n\n  if (schema instanceof z.ZodObject) {\n    return zodToJsonSchema(schema);\n  }\n\n  return { type: 'string' };\n}\n","import { ulid } from 'ulid';\nimport type { Redis } from 'ioredis';\nimport { getRedisClient } from './client.js';\nimport { generateEmbedding, cosineSimilarity } from '../embeddings/generator.js';\nimport { RedisKeys, createWorkspaceId, getWorkspaceMode, WorkspaceMode, type MemoryEntry, type CreateMemory, type SessionInfo, type ContextType, type MemoryRelationship, type RelationshipType, type RelatedMemoryResult, type MemoryGraph, type MemoryGraphNode } from '../types.js';\n\nexport class MemoryStore {\n  private redis: Redis;\n  private workspaceId: string;\n  private workspacePath: string;\n\n  constructor(workspacePath?: string) {\n    this.redis = getRedisClient();\n    this.workspacePath = workspacePath || process.cwd();\n    this.workspaceId = createWorkspaceId(this.workspacePath);\n\n    // Log workspace info for debugging\n    console.error(`[MemoryStore] Workspace: ${this.workspacePath}`);\n    console.error(`[MemoryStore] Workspace ID: ${this.workspaceId}`);\n  }\n\n  // Store a new memory\n  async createMemory(data: CreateMemory): Promise<MemoryEntry> {\n    const id = ulid();\n    const timestamp = Date.now();\n\n    // Generate embedding for the content\n    const embedding = await generateEmbedding(data.content);\n\n    // Auto-generate summary if not provided\n    const summary = data.summary || this.generateSummary(data.content);\n\n    // Calculate expiration if TTL provided\n    let expiresAt: number | undefined;\n    if (data.ttl_seconds) {\n      expiresAt = timestamp + (data.ttl_seconds * 1000);\n    }\n\n    const isGlobal = data.is_global || false;\n\n    const memory: MemoryEntry = {\n      id,\n      timestamp,\n      context_type: data.context_type,\n      content: data.content,\n      summary,\n      tags: data.tags,\n      importance: data.importance,\n      session_id: data.session_id,\n      embedding,\n      ttl_seconds: data.ttl_seconds,\n      expires_at: expiresAt,\n      is_global: isGlobal,\n      workspace_id: isGlobal ? '' : this.workspaceId,\n      category: data.category, // v1.5.0\n    };\n\n    // Store in Redis (workspace or global based on is_global flag)\n    const pipeline = this.redis.pipeline();\n\n    // Main memory hash\n    const memoryKey = isGlobal\n      ? RedisKeys.globalMemory(id)\n      : RedisKeys.memory(this.workspaceId, id);\n\n    pipeline.hset(memoryKey, this.serializeMemory(memory));\n\n    // Set TTL on the hash if specified\n    if (data.ttl_seconds) {\n      pipeline.expire(memoryKey, data.ttl_seconds);\n    }\n\n    // Add to global set\n    if (isGlobal) {\n      pipeline.sadd(RedisKeys.globalMemories(), id);\n      pipeline.zadd(RedisKeys.globalTimeline(), timestamp, id);\n      pipeline.sadd(RedisKeys.globalByType(data.context_type), id);\n\n      for (const tag of data.tags) {\n        pipeline.sadd(RedisKeys.globalByTag(tag), id);\n      }\n\n      if (data.importance >= 8) {\n        pipeline.zadd(RedisKeys.globalImportant(), data.importance, id);\n      }\n\n      // Add to category index if specified (v1.5.0)\n      if (data.category) {\n        pipeline.set(RedisKeys.globalMemoryCategory(id), data.category);\n        pipeline.sadd(RedisKeys.globalCategory(data.category), id);\n        pipeline.zadd(RedisKeys.globalCategories(), timestamp, data.category);\n      }\n    } else {\n      pipeline.sadd(RedisKeys.memories(this.workspaceId), id);\n      pipeline.zadd(RedisKeys.timeline(this.workspaceId), timestamp, id);\n      pipeline.sadd(RedisKeys.byType(this.workspaceId, data.context_type), id);\n\n      for (const tag of data.tags) {\n        pipeline.sadd(RedisKeys.byTag(this.workspaceId, tag), id);\n      }\n\n      if (data.importance >= 8) {\n        pipeline.zadd(RedisKeys.important(this.workspaceId), data.importance, id);\n      }\n\n      // Add to category index if specified (v1.5.0)\n      if (data.category) {\n        pipeline.set(RedisKeys.memoryCategory(this.workspaceId, id), data.category);\n        pipeline.sadd(RedisKeys.category(this.workspaceId, data.category), id);\n        pipeline.zadd(RedisKeys.categories(this.workspaceId), timestamp, data.category);\n      }\n    }\n\n    await pipeline.exec();\n\n    return memory;\n  }\n\n  // Batch create memories\n  async createMemories(memories: CreateMemory[]): Promise<MemoryEntry[]> {\n    const results: MemoryEntry[] = [];\n\n    for (const memoryData of memories) {\n      const memory = await this.createMemory(memoryData);\n      results.push(memory);\n    }\n\n    return results;\n  }\n\n  // Get memory by ID (checks both workspace and global)\n  async getMemory(id: string, isGlobal?: boolean): Promise<MemoryEntry | null> {\n    // If we know it's global, check global first\n    if (isGlobal === true) {\n      const globalData = await this.redis.hgetall(RedisKeys.globalMemory(id));\n      if (globalData && Object.keys(globalData).length > 0) {\n        return this.deserializeMemory(globalData);\n      }\n      return null;\n    }\n\n    // If we know it's workspace, check workspace only\n    if (isGlobal === false) {\n      const wsData = await this.redis.hgetall(RedisKeys.memory(this.workspaceId, id));\n      if (wsData && Object.keys(wsData).length > 0) {\n        return this.deserializeMemory(wsData);\n      }\n      return null;\n    }\n\n    // If unknown, check workspace first, then global\n    const wsData = await this.redis.hgetall(RedisKeys.memory(this.workspaceId, id));\n    if (wsData && Object.keys(wsData).length > 0) {\n      return this.deserializeMemory(wsData);\n    }\n\n    const globalData = await this.redis.hgetall(RedisKeys.globalMemory(id));\n    if (globalData && Object.keys(globalData).length > 0) {\n      return this.deserializeMemory(globalData);\n    }\n\n    return null;\n  }\n\n  // Get multiple memories by IDs\n  async getMemories(ids: string[]): Promise<MemoryEntry[]> {\n    const memories: MemoryEntry[] = [];\n\n    for (const id of ids) {\n      const memory = await this.getMemory(id);\n      if (memory) {\n        memories.push(memory);\n      }\n    }\n\n    return memories;\n  }\n\n  // Get recent memories (respects workspace mode)\n  async getRecentMemories(limit: number = 50): Promise<MemoryEntry[]> {\n    const mode = getWorkspaceMode();\n\n    if (mode === WorkspaceMode.GLOBAL) {\n      // Global mode: only global memories\n      const ids = await this.redis.zrevrange(RedisKeys.globalTimeline(), 0, limit - 1);\n      return this.getMemories(ids);\n    } else if (mode === WorkspaceMode.ISOLATED) {\n      // Isolated mode: only workspace memories\n      const ids = await this.redis.zrevrange(RedisKeys.timeline(this.workspaceId), 0, limit - 1);\n      return this.getMemories(ids);\n    } else {\n      // Hybrid mode: merge workspace + global\n      const wsIds = await this.redis.zrevrange(RedisKeys.timeline(this.workspaceId), 0, limit - 1);\n      const globalIds = await this.redis.zrevrange(RedisKeys.globalTimeline(), 0, limit - 1);\n\n      const allMemories = await this.getMemories([...wsIds, ...globalIds]);\n\n      // Sort by timestamp descending\n      allMemories.sort((a, b) => b.timestamp - a.timestamp);\n\n      return allMemories.slice(0, limit);\n    }\n  }\n\n  // Get memories by type (respects workspace mode)\n  async getMemoriesByType(type: ContextType, limit?: number): Promise<MemoryEntry[]> {\n    const mode = getWorkspaceMode();\n    let ids: string[] = [];\n\n    if (mode === WorkspaceMode.GLOBAL) {\n      ids = await this.redis.smembers(RedisKeys.globalByType(type));\n    } else if (mode === WorkspaceMode.ISOLATED) {\n      ids = await this.redis.smembers(RedisKeys.byType(this.workspaceId, type));\n    } else {\n      // Hybrid: merge both\n      const wsIds = await this.redis.smembers(RedisKeys.byType(this.workspaceId, type));\n      const globalIds = await this.redis.smembers(RedisKeys.globalByType(type));\n      ids = [...new Set([...wsIds, ...globalIds])]; // Deduplicate\n    }\n\n    const memories = await this.getMemories(ids);\n\n    // Sort by timestamp descending\n    memories.sort((a, b) => b.timestamp - a.timestamp);\n\n    return limit ? memories.slice(0, limit) : memories;\n  }\n\n  // Get memories by tag (respects workspace mode)\n  async getMemoriesByTag(tag: string, limit?: number): Promise<MemoryEntry[]> {\n    const mode = getWorkspaceMode();\n    let ids: string[] = [];\n\n    if (mode === WorkspaceMode.GLOBAL) {\n      ids = await this.redis.smembers(RedisKeys.globalByTag(tag));\n    } else if (mode === WorkspaceMode.ISOLATED) {\n      ids = await this.redis.smembers(RedisKeys.byTag(this.workspaceId, tag));\n    } else {\n      // Hybrid: merge both\n      const wsIds = await this.redis.smembers(RedisKeys.byTag(this.workspaceId, tag));\n      const globalIds = await this.redis.smembers(RedisKeys.globalByTag(tag));\n      ids = [...new Set([...wsIds, ...globalIds])]; // Deduplicate\n    }\n\n    const memories = await this.getMemories(ids);\n\n    // Sort by timestamp descending\n    memories.sort((a, b) => b.timestamp - a.timestamp);\n\n    return limit ? memories.slice(0, limit) : memories;\n  }\n\n  // Get important memories (respects workspace mode)\n  async getImportantMemories(minImportance: number = 8, limit?: number): Promise<MemoryEntry[]> {\n    const mode = getWorkspaceMode();\n    let results: string[] = [];\n\n    if (mode === WorkspaceMode.GLOBAL) {\n      results = await this.redis.zrevrangebyscore(\n        RedisKeys.globalImportant(),\n        10,\n        minImportance,\n        'LIMIT',\n        0,\n        limit || 100\n      );\n    } else if (mode === WorkspaceMode.ISOLATED) {\n      results = await this.redis.zrevrangebyscore(\n        RedisKeys.important(this.workspaceId),\n        10,\n        minImportance,\n        'LIMIT',\n        0,\n        limit || 100\n      );\n    } else {\n      // Hybrid: get from both and merge\n      const wsResults = await this.redis.zrevrangebyscore(\n        RedisKeys.important(this.workspaceId),\n        10,\n        minImportance,\n        'LIMIT',\n        0,\n        limit || 100\n      );\n      const globalResults = await this.redis.zrevrangebyscore(\n        RedisKeys.globalImportant(),\n        10,\n        minImportance,\n        'LIMIT',\n        0,\n        limit || 100\n      );\n\n      const allMemories = await this.getMemories([...wsResults, ...globalResults]);\n      // Sort by importance descending\n      allMemories.sort((a, b) => b.importance - a.importance);\n      return allMemories.slice(0, limit || 100);\n    }\n\n    return this.getMemories(results);\n  }\n\n  // Update memory (handles both workspace and global)\n  async updateMemory(id: string, updates: Partial<CreateMemory>): Promise<MemoryEntry | null> {\n    const existing = await this.getMemory(id);\n    if (!existing) {\n      return null;\n    }\n\n    // Create version before updating (v1.5.0)\n    await this.createVersion(existing, 'user', 'Memory updated');\n\n    const pipeline = this.redis.pipeline();\n\n    // Update content and regenerate embedding if content changed\n    let embedding = existing.embedding;\n    if (updates.content && updates.content !== existing.content) {\n      embedding = await generateEmbedding(updates.content);\n    }\n\n    const updated: MemoryEntry = {\n      ...existing,\n      ...updates,\n      embedding,\n      summary: updates.summary || (updates.content ? this.generateSummary(updates.content) : existing.summary),\n    };\n\n    const isGlobal = existing.is_global;\n\n    // Update hash (use appropriate key based on is_global)\n    const memoryKey = isGlobal\n      ? RedisKeys.globalMemory(id)\n      : RedisKeys.memory(this.workspaceId, id);\n\n    pipeline.hset(memoryKey, this.serializeMemory(updated));\n\n    // Update type index if changed\n    if (updates.context_type && updates.context_type !== existing.context_type) {\n      if (isGlobal) {\n        pipeline.srem(RedisKeys.globalByType(existing.context_type), id);\n        pipeline.sadd(RedisKeys.globalByType(updates.context_type), id);\n      } else {\n        pipeline.srem(RedisKeys.byType(this.workspaceId, existing.context_type), id);\n        pipeline.sadd(RedisKeys.byType(this.workspaceId, updates.context_type), id);\n      }\n    }\n\n    // Update tag indexes if changed\n    if (updates.tags) {\n      // Remove from old tags\n      for (const tag of existing.tags) {\n        if (!updates.tags.includes(tag)) {\n          if (isGlobal) {\n            pipeline.srem(RedisKeys.globalByTag(tag), id);\n          } else {\n            pipeline.srem(RedisKeys.byTag(this.workspaceId, tag), id);\n          }\n        }\n      }\n      // Add to new tags\n      for (const tag of updates.tags) {\n        if (!existing.tags.includes(tag)) {\n          if (isGlobal) {\n            pipeline.sadd(RedisKeys.globalByTag(tag), id);\n          } else {\n            pipeline.sadd(RedisKeys.byTag(this.workspaceId, tag), id);\n          }\n        }\n      }\n    }\n\n    // Update importance index if changed\n    if (updates.importance !== undefined) {\n      if (existing.importance >= 8) {\n        if (isGlobal) {\n          pipeline.zrem(RedisKeys.globalImportant(), id);\n        } else {\n          pipeline.zrem(RedisKeys.important(this.workspaceId), id);\n        }\n      }\n      if (updates.importance >= 8) {\n        if (isGlobal) {\n          pipeline.zadd(RedisKeys.globalImportant(), updates.importance, id);\n        } else {\n          pipeline.zadd(RedisKeys.important(this.workspaceId), updates.importance, id);\n        }\n      }\n    }\n\n    await pipeline.exec();\n\n    return updated;\n  }\n\n  // Delete memory (handles both workspace and global)\n  async deleteMemory(id: string): Promise<boolean> {\n    const memory = await this.getMemory(id);\n    if (!memory) {\n      return false;\n    }\n\n    const pipeline = this.redis.pipeline();\n    const isGlobal = memory.is_global;\n\n    // Remove from all indexes (use appropriate keys based on is_global)\n    if (isGlobal) {\n      pipeline.del(RedisKeys.globalMemory(id));\n      pipeline.srem(RedisKeys.globalMemories(), id);\n      pipeline.zrem(RedisKeys.globalTimeline(), id);\n      pipeline.srem(RedisKeys.globalByType(memory.context_type), id);\n\n      for (const tag of memory.tags) {\n        pipeline.srem(RedisKeys.globalByTag(tag), id);\n      }\n\n      if (memory.importance >= 8) {\n        pipeline.zrem(RedisKeys.globalImportant(), id);\n      }\n    } else {\n      pipeline.del(RedisKeys.memory(this.workspaceId, id));\n      pipeline.srem(RedisKeys.memories(this.workspaceId), id);\n      pipeline.zrem(RedisKeys.timeline(this.workspaceId), id);\n      pipeline.srem(RedisKeys.byType(this.workspaceId, memory.context_type), id);\n\n      for (const tag of memory.tags) {\n        pipeline.srem(RedisKeys.byTag(this.workspaceId, tag), id);\n      }\n\n      if (memory.importance >= 8) {\n        pipeline.zrem(RedisKeys.important(this.workspaceId), id);\n      }\n    }\n\n    await pipeline.exec();\n\n    return true;\n  }\n\n  // Semantic search (respects workspace mode with global memory weighting)\n  async searchMemories(\n    query: string,\n    limit: number = 10,\n    minImportance?: number,\n    contextTypes?: ContextType[],\n    category?: string,\n    fuzzy: boolean = false,\n    regex?: string\n  ): Promise<Array<MemoryEntry & { similarity: number }>> {\n    // Generate embedding for query\n    const queryEmbedding = await generateEmbedding(query);\n\n    const mode = getWorkspaceMode();\n    let memories: MemoryEntry[] = [];\n\n    // Get all memories based on workspace mode\n    if (mode === WorkspaceMode.GLOBAL) {\n      // Global mode: only global memories\n      let ids: string[];\n      if (contextTypes && contextTypes.length > 0) {\n        const sets = contextTypes.map(type => RedisKeys.globalByType(type));\n        ids = await this.redis.sunion(...sets);\n      } else {\n        ids = await this.redis.smembers(RedisKeys.globalMemories());\n      }\n      memories = await this.getMemories(ids);\n    } else if (mode === WorkspaceMode.ISOLATED) {\n      // Isolated mode: only workspace memories\n      let ids: string[];\n      if (contextTypes && contextTypes.length > 0) {\n        const sets = contextTypes.map(type => RedisKeys.byType(this.workspaceId, type));\n        ids = await this.redis.sunion(...sets);\n      } else {\n        ids = await this.redis.smembers(RedisKeys.memories(this.workspaceId));\n      }\n      memories = await this.getMemories(ids);\n    } else {\n      // Hybrid mode: merge workspace + global\n      let wsIds: string[];\n      let globalIds: string[];\n\n      if (contextTypes && contextTypes.length > 0) {\n        const wsSets = contextTypes.map(type => RedisKeys.byType(this.workspaceId, type));\n        const globalSets = contextTypes.map(type => RedisKeys.globalByType(type));\n        wsIds = await this.redis.sunion(...wsSets);\n        globalIds = await this.redis.sunion(...globalSets);\n      } else {\n        wsIds = await this.redis.smembers(RedisKeys.memories(this.workspaceId));\n        globalIds = await this.redis.smembers(RedisKeys.globalMemories());\n      }\n\n      memories = await this.getMemories([...wsIds, ...globalIds]);\n    }\n\n    // Filter by importance if specified\n    let filtered = memories;\n    if (minImportance !== undefined) {\n      filtered = memories.filter(m => m.importance >= minImportance);\n    }\n\n    // Filter by category if specified (v1.5.0)\n    if (category) {\n      filtered = filtered.filter(m => m.category === category);\n    }\n\n    // Apply regex filter if specified (v1.5.0)\n    if (regex) {\n      try {\n        const regexPattern = new RegExp(regex, 'i');\n        filtered = filtered.filter(m => regexPattern.test(m.content));\n      } catch (error) {\n        // Invalid regex, skip filtering\n        console.error('Invalid regex pattern:', error);\n      }\n    }\n\n    // Calculate similarities\n    const withSimilarity = filtered.map(memory => {\n      let baseSimilarity = memory.embedding ? cosineSimilarity(queryEmbedding, memory.embedding) : 0;\n\n      // Fuzzy search boost (v1.5.0) - boost exact word matches\n      if (fuzzy) {\n        const queryWords = query.toLowerCase().split(/\\s+/);\n        const contentWords = memory.content.toLowerCase().split(/\\s+/);\n        const matchCount = queryWords.filter(qw => contentWords.some(cw => cw.includes(qw))).length;\n        const fuzzyBoost = (matchCount / queryWords.length) * 0.2; // Up to 20% boost\n        baseSimilarity = Math.min(1, baseSimilarity + fuzzyBoost);\n      }\n\n      // In hybrid mode, weight global memories slightly lower (0.9x) to prefer local context\n      const similarity = (mode === WorkspaceMode.HYBRID && memory.is_global)\n        ? baseSimilarity * 0.9\n        : baseSimilarity;\n\n      return {\n        ...memory,\n        similarity,\n      };\n    });\n\n    // Sort by similarity descending\n    withSimilarity.sort((a, b) => b.similarity - a.similarity);\n\n    return withSimilarity.slice(0, limit);\n  }\n\n  // Create session\n  async createSession(name: string, memoryIds: string[], summary?: string): Promise<SessionInfo> {\n    const sessionId = ulid();\n    const timestamp = Date.now();\n\n    // Verify all memory IDs exist\n    const validIds: string[] = [];\n    for (const id of memoryIds) {\n      const exists = await this.redis.exists(RedisKeys.memory(this.workspaceId, id));\n      if (exists) {\n        validIds.push(id);\n      }\n    }\n\n    const session: SessionInfo = {\n      session_id: sessionId,\n      session_name: name,\n      created_at: timestamp,\n      memory_count: validIds.length,\n      summary,\n      memory_ids: validIds,\n    };\n\n    // Store session\n    await this.redis.hset(RedisKeys.session(this.workspaceId, sessionId), {\n      session_id: sessionId,\n      session_name: name,\n      created_at: timestamp.toString(),\n      memory_count: validIds.length.toString(),\n      summary: summary || '',\n      memory_ids: JSON.stringify(validIds),\n    });\n\n    await this.redis.sadd(RedisKeys.sessions(this.workspaceId), sessionId);\n\n    return session;\n  }\n\n  // Get session\n  async getSession(sessionId: string): Promise<SessionInfo | null> {\n    const data = await this.redis.hgetall(RedisKeys.session(this.workspaceId, sessionId));\n\n    if (!data || Object.keys(data).length === 0) {\n      return null;\n    }\n\n    return {\n      session_id: data.session_id,\n      session_name: data.session_name,\n      created_at: parseInt(data.created_at, 10),\n      memory_count: parseInt(data.memory_count, 10),\n      summary: data.summary || undefined,\n      memory_ids: JSON.parse(data.memory_ids),\n    };\n  }\n\n  // Get all sessions\n  async getAllSessions(): Promise<SessionInfo[]> {\n    const ids = await this.redis.smembers(RedisKeys.sessions(this.workspaceId));\n    const sessions: SessionInfo[] = [];\n\n    for (const id of ids) {\n      const session = await this.getSession(id);\n      if (session) {\n        sessions.push(session);\n      }\n    }\n\n    return sessions.sort((a, b) => b.created_at - a.created_at);\n  }\n\n  // Get memories in session\n  async getSessionMemories(sessionId: string): Promise<MemoryEntry[]> {\n    const session = await this.getSession(sessionId);\n    if (!session) {\n      return [];\n    }\n\n    return this.getMemories(session.memory_ids);\n  }\n\n  // Generate summary stats\n  async getSummaryStats(): Promise<{\n    total_memories: number;\n    by_type: Record<ContextType, number>;\n    total_sessions: number;\n    important_count: number;\n    workspace_path: string;\n  }> {\n    const totalMemories = await this.redis.scard(RedisKeys.memories(this.workspaceId));\n    const totalSessions = await this.redis.scard(RedisKeys.sessions(this.workspaceId));\n    const importantCount = await this.redis.zcard(RedisKeys.important(this.workspaceId));\n\n    const byType: Record<string, number> = {};\n    const types: ContextType[] = ['directive', 'information', 'heading', 'decision', 'code_pattern', 'requirement', 'error', 'todo', 'insight', 'preference'];\n\n    for (const type of types) {\n      byType[type] = await this.redis.scard(RedisKeys.byType(this.workspaceId, type));\n    }\n\n    return {\n      total_memories: totalMemories,\n      by_type: byType as Record<ContextType, number>,\n      total_sessions: totalSessions,\n      important_count: importantCount,\n      workspace_path: this.workspacePath,\n    };\n  }\n\n  // Merge multiple memories into one\n  async mergeMemories(memoryIds: string[], keepId?: string): Promise<MemoryEntry | null> {\n    // Get all memories to merge\n    const memories = await this.getMemories(memoryIds);\n\n    if (memories.length === 0) {\n      return null;\n    }\n\n    // Determine which memory to keep\n    const toKeep = keepId\n      ? memories.find(m => m.id === keepId)\n      : memories.reduce((prev, current) =>\n          current.importance > prev.importance ? current : prev\n        );\n\n    if (!toKeep) {\n      return null;\n    }\n\n    // Merge content, tags, and metadata\n    const allTags = new Set<string>();\n    const contentParts: string[] = [];\n\n    for (const memory of memories) {\n      if (memory.id !== toKeep.id) {\n        contentParts.push(memory.content);\n      }\n      memory.tags.forEach(tag => allTags.add(tag));\n    }\n\n    // Create merged content\n    const mergedContent = contentParts.length > 0\n      ? `${toKeep.content}\\n\\n--- Merged content ---\\n${contentParts.join('\\n\\n')}`\n      : toKeep.content;\n\n    // Update the memory to keep with merged data\n    const updated = await this.updateMemory(toKeep.id, {\n      content: mergedContent,\n      tags: Array.from(allTags),\n      importance: Math.max(...memories.map(m => m.importance)),\n    });\n\n    // Delete the other memories\n    for (const memory of memories) {\n      if (memory.id !== toKeep.id) {\n        await this.deleteMemory(memory.id);\n      }\n    }\n\n    return updated;\n  }\n\n  // Helper: Generate summary from content (first 100 chars)\n  private generateSummary(content: string): string {\n    return content.length > 100 ? content.substring(0, 100) + '...' : content;\n  }\n\n  // Helper: Serialize memory for Redis\n  private serializeMemory(memory: MemoryEntry): Record<string, string> {\n    return {\n      id: memory.id,\n      timestamp: memory.timestamp.toString(),\n      context_type: memory.context_type,\n      content: memory.content,\n      summary: memory.summary || '',\n      tags: JSON.stringify(memory.tags),\n      importance: memory.importance.toString(),\n      session_id: memory.session_id || '',\n      embedding: JSON.stringify(memory.embedding || []),\n      ttl_seconds: memory.ttl_seconds?.toString() || '',\n      expires_at: memory.expires_at?.toString() || '',\n      is_global: memory.is_global ? 'true' : 'false',\n      workspace_id: memory.workspace_id || '',\n      category: memory.category || '', // v1.5.0\n    };\n  }\n\n  // Helper: Deserialize memory from Redis\n  private deserializeMemory(data: Record<string, string>): MemoryEntry {\n    return {\n      id: data.id,\n      timestamp: parseInt(data.timestamp, 10),\n      context_type: data.context_type as ContextType,\n      content: data.content,\n      summary: data.summary || undefined,\n      tags: JSON.parse(data.tags || '[]'),\n      importance: parseInt(data.importance, 10),\n      session_id: data.session_id || undefined,\n      embedding: JSON.parse(data.embedding || '[]'),\n      ttl_seconds: data.ttl_seconds ? parseInt(data.ttl_seconds, 10) : undefined,\n      expires_at: data.expires_at ? parseInt(data.expires_at, 10) : undefined,\n      is_global: data.is_global === 'true',\n      workspace_id: data.workspace_id || '',\n      category: data.category || undefined, // v1.5.0\n    };\n  }\n\n  // Convert workspace memory to global\n  async convertToGlobal(memoryId: string): Promise<MemoryEntry | null> {\n    const memory = await this.getMemory(memoryId);\n    if (!memory) {\n      return null;\n    }\n\n    // Already global\n    if (memory.is_global) {\n      return memory;\n    }\n\n    const pipeline = this.redis.pipeline();\n\n    // Delete from workspace indexes\n    pipeline.del(RedisKeys.memory(this.workspaceId, memoryId));\n    pipeline.srem(RedisKeys.memories(this.workspaceId), memoryId);\n    pipeline.zrem(RedisKeys.timeline(this.workspaceId), memoryId);\n    pipeline.srem(RedisKeys.byType(this.workspaceId, memory.context_type), memoryId);\n\n    for (const tag of memory.tags) {\n      pipeline.srem(RedisKeys.byTag(this.workspaceId, tag), memoryId);\n    }\n\n    if (memory.importance >= 8) {\n      pipeline.zrem(RedisKeys.important(this.workspaceId), memoryId);\n    }\n\n    // Update memory to global\n    const globalMemory: MemoryEntry = {\n      ...memory,\n      is_global: true,\n      workspace_id: '',\n    };\n\n    // Add to global indexes\n    pipeline.hset(RedisKeys.globalMemory(memoryId), this.serializeMemory(globalMemory));\n    pipeline.sadd(RedisKeys.globalMemories(), memoryId);\n    pipeline.zadd(RedisKeys.globalTimeline(), memory.timestamp, memoryId);\n    pipeline.sadd(RedisKeys.globalByType(memory.context_type), memoryId);\n\n    for (const tag of memory.tags) {\n      pipeline.sadd(RedisKeys.globalByTag(tag), memoryId);\n    }\n\n    if (memory.importance >= 8) {\n      pipeline.zadd(RedisKeys.globalImportant(), memory.importance, memoryId);\n    }\n\n    await pipeline.exec();\n\n    return globalMemory;\n  }\n\n  // Convert global memory to workspace\n  async convertToWorkspace(memoryId: string, targetWorkspaceId?: string): Promise<MemoryEntry | null> {\n    const memory = await this.getMemory(memoryId);\n    if (!memory) {\n      return null;\n    }\n\n    // Already workspace-specific\n    if (!memory.is_global) {\n      return memory;\n    }\n\n    const workspaceId = targetWorkspaceId || this.workspaceId;\n    const pipeline = this.redis.pipeline();\n\n    // Delete from global indexes\n    pipeline.del(RedisKeys.globalMemory(memoryId));\n    pipeline.srem(RedisKeys.globalMemories(), memoryId);\n    pipeline.zrem(RedisKeys.globalTimeline(), memoryId);\n    pipeline.srem(RedisKeys.globalByType(memory.context_type), memoryId);\n\n    for (const tag of memory.tags) {\n      pipeline.srem(RedisKeys.globalByTag(tag), memoryId);\n    }\n\n    if (memory.importance >= 8) {\n      pipeline.zrem(RedisKeys.globalImportant(), memoryId);\n    }\n\n    // Update memory to workspace-specific\n    const workspaceMemory: MemoryEntry = {\n      ...memory,\n      is_global: false,\n      workspace_id: workspaceId,\n    };\n\n    // Add to workspace indexes\n    pipeline.hset(RedisKeys.memory(workspaceId, memoryId), this.serializeMemory(workspaceMemory));\n    pipeline.sadd(RedisKeys.memories(workspaceId), memoryId);\n    pipeline.zadd(RedisKeys.timeline(workspaceId), memory.timestamp, memoryId);\n    pipeline.sadd(RedisKeys.byType(workspaceId, memory.context_type), memoryId);\n\n    for (const tag of memory.tags) {\n      pipeline.sadd(RedisKeys.byTag(workspaceId, tag), memoryId);\n    }\n\n    if (memory.importance >= 8) {\n      pipeline.zadd(RedisKeys.important(workspaceId), memory.importance, memoryId);\n    }\n\n    await pipeline.exec();\n\n    return workspaceMemory;\n  }\n\n  // ============================================================================\n  // Memory Relationships (v1.4.0)\n  // ============================================================================\n\n  // Serialize relationship for Redis storage\n  private serializeRelationship(relationship: MemoryRelationship): Record<string, string> {\n    return {\n      id: relationship.id,\n      from_memory_id: relationship.from_memory_id,\n      to_memory_id: relationship.to_memory_id,\n      relationship_type: relationship.relationship_type,\n      created_at: relationship.created_at,\n      metadata: relationship.metadata ? JSON.stringify(relationship.metadata) : '',\n    };\n  }\n\n  // Deserialize relationship from Redis\n  private deserializeRelationship(data: Record<string, string>): MemoryRelationship {\n    return {\n      id: data.id,\n      from_memory_id: data.from_memory_id,\n      to_memory_id: data.to_memory_id,\n      relationship_type: data.relationship_type as RelationshipType,\n      created_at: data.created_at,\n      metadata: data.metadata ? JSON.parse(data.metadata) : undefined,\n    };\n  }\n\n  // Create a relationship between two memories\n  async createRelationship(\n    fromMemoryId: string,\n    toMemoryId: string,\n    relationshipType: RelationshipType,\n    metadata?: Record<string, unknown>\n  ): Promise<MemoryRelationship> {\n    // Validate both memories exist\n    const fromMemory = await this.getMemory(fromMemoryId);\n    const toMemory = await this.getMemory(toMemoryId);\n\n    if (!fromMemory) {\n      throw new Error(`Source memory not found: ${fromMemoryId}`);\n    }\n    if (!toMemory) {\n      throw new Error(`Target memory not found: ${toMemoryId}`);\n    }\n\n    // Prevent self-references\n    if (fromMemoryId === toMemoryId) {\n      throw new Error('Cannot create relationship to self');\n    }\n\n    // Check if relationship already exists\n    const existing = await this.findRelationship(fromMemoryId, toMemoryId, relationshipType);\n    if (existing) {\n      return existing; // Idempotent\n    }\n\n    const id = ulid();\n    const relationship: MemoryRelationship = {\n      id,\n      from_memory_id: fromMemoryId,\n      to_memory_id: toMemoryId,\n      relationship_type: relationshipType,\n      created_at: new Date().toISOString(),\n      metadata,\n    };\n\n    // Determine if this is a global relationship (both memories are global)\n    const isGlobal = fromMemory.is_global && toMemory.is_global;\n\n    const pipeline = this.redis.pipeline();\n\n    if (isGlobal) {\n      pipeline.hset(RedisKeys.globalRelationship(id), this.serializeRelationship(relationship));\n      pipeline.sadd(RedisKeys.globalRelationships(), id);\n      pipeline.sadd(RedisKeys.globalMemoryRelationships(fromMemoryId), id);\n      pipeline.sadd(RedisKeys.globalMemoryRelationshipsOut(fromMemoryId), id);\n      pipeline.sadd(RedisKeys.globalMemoryRelationshipsIn(toMemoryId), id);\n    } else {\n      pipeline.hset(RedisKeys.relationship(this.workspaceId, id), this.serializeRelationship(relationship));\n      pipeline.sadd(RedisKeys.relationships(this.workspaceId), id);\n      pipeline.sadd(RedisKeys.memoryRelationships(this.workspaceId, fromMemoryId), id);\n      pipeline.sadd(RedisKeys.memoryRelationshipsOut(this.workspaceId, fromMemoryId), id);\n      pipeline.sadd(RedisKeys.memoryRelationshipsIn(this.workspaceId, toMemoryId), id);\n    }\n\n    await pipeline.exec();\n\n    return relationship;\n  }\n\n  // Find existing relationship\n  private async findRelationship(\n    fromMemoryId: string,\n    toMemoryId: string,\n    relationshipType: RelationshipType\n  ): Promise<MemoryRelationship | null> {\n    // Get all relationships for from memory\n    const relationshipIds = await this.getMemoryRelationshipIds(fromMemoryId, 'outgoing');\n\n    for (const relId of relationshipIds) {\n      const rel = await this.getRelationship(relId);\n      if (\n        rel &&\n        rel.from_memory_id === fromMemoryId &&\n        rel.to_memory_id === toMemoryId &&\n        rel.relationship_type === relationshipType\n      ) {\n        return rel;\n      }\n    }\n\n    return null;\n  }\n\n  // Get a single relationship by ID\n  async getRelationship(relationshipId: string): Promise<MemoryRelationship | null> {\n    // Try workspace first\n    const wsData = await this.redis.hgetall(RedisKeys.relationship(this.workspaceId, relationshipId));\n    if (wsData && Object.keys(wsData).length > 0) {\n      return this.deserializeRelationship(wsData);\n    }\n\n    // Try global\n    const globalData = await this.redis.hgetall(RedisKeys.globalRelationship(relationshipId));\n    if (globalData && Object.keys(globalData).length > 0) {\n      return this.deserializeRelationship(globalData);\n    }\n\n    return null;\n  }\n\n  // Get relationship IDs for a memory\n  private async getMemoryRelationshipIds(\n    memoryId: string,\n    direction: 'outgoing' | 'incoming' | 'both' = 'both'\n  ): Promise<string[]> {\n    const mode = getWorkspaceMode();\n    const ids = new Set<string>();\n\n    // Helper to add IDs from a Redis key\n    const addIds = async (key: string) => {\n      const keyIds = await this.redis.smembers(key);\n      keyIds.forEach(id => ids.add(id));\n    };\n\n    // Workspace relationships\n    if (mode === WorkspaceMode.ISOLATED || mode === WorkspaceMode.HYBRID) {\n      if (direction === 'outgoing' || direction === 'both') {\n        await addIds(RedisKeys.memoryRelationshipsOut(this.workspaceId, memoryId));\n      }\n      if (direction === 'incoming' || direction === 'both') {\n        await addIds(RedisKeys.memoryRelationshipsIn(this.workspaceId, memoryId));\n      }\n    }\n\n    // Global relationships\n    if (mode === WorkspaceMode.GLOBAL || mode === WorkspaceMode.HYBRID) {\n      if (direction === 'outgoing' || direction === 'both') {\n        await addIds(RedisKeys.globalMemoryRelationshipsOut(memoryId));\n      }\n      if (direction === 'incoming' || direction === 'both') {\n        await addIds(RedisKeys.globalMemoryRelationshipsIn(memoryId));\n      }\n    }\n\n    return Array.from(ids);\n  }\n\n  // Get all relationships for a memory\n  async getMemoryRelationships(\n    memoryId: string,\n    direction: 'outgoing' | 'incoming' | 'both' = 'both'\n  ): Promise<MemoryRelationship[]> {\n    const relationshipIds = await this.getMemoryRelationshipIds(memoryId, direction);\n    const relationships: MemoryRelationship[] = [];\n\n    for (const relId of relationshipIds) {\n      const rel = await this.getRelationship(relId);\n      if (rel) {\n        relationships.push(rel);\n      }\n    }\n\n    return relationships;\n  }\n\n  // Get related memories with graph traversal\n  async getRelatedMemories(\n    memoryId: string,\n    options: {\n      relationshipTypes?: RelationshipType[];\n      depth?: number;\n      direction?: 'outgoing' | 'incoming' | 'both';\n    } = {}\n  ): Promise<RelatedMemoryResult[]> {\n    const { relationshipTypes, depth = 1, direction = 'both' } = options;\n\n    const results: RelatedMemoryResult[] = [];\n    const visited = new Set<string>();\n\n    await this.traverseGraph(memoryId, depth, visited, results, relationshipTypes, direction, 0);\n\n    return results;\n  }\n\n  // Traverse relationship graph\n  private async traverseGraph(\n    memoryId: string,\n    maxDepth: number,\n    visited: Set<string>,\n    results: RelatedMemoryResult[],\n    relationshipTypes?: RelationshipType[],\n    direction: 'outgoing' | 'incoming' | 'both' = 'both',\n    currentDepth: number = 0\n  ): Promise<void> {\n    if (currentDepth >= maxDepth || visited.has(memoryId)) {\n      return;\n    }\n\n    visited.add(memoryId);\n\n    // Get relationships for this memory\n    const relationships = await this.getMemoryRelationships(memoryId, direction);\n\n    // Filter by type if specified\n    const filtered = relationshipTypes\n      ? relationships.filter(r => relationshipTypes.includes(r.relationship_type))\n      : relationships;\n\n    for (const relationship of filtered) {\n      const relatedMemoryId =\n        relationship.from_memory_id === memoryId\n          ? relationship.to_memory_id\n          : relationship.from_memory_id;\n\n      if (!visited.has(relatedMemoryId)) {\n        const memory = await this.getMemory(relatedMemoryId);\n        if (memory) {\n          results.push({\n            memory,\n            relationship,\n            depth: currentDepth + 1,\n          });\n\n          // Recurse if not at max depth\n          if (currentDepth + 1 < maxDepth) {\n            await this.traverseGraph(\n              relatedMemoryId,\n              maxDepth,\n              visited,\n              results,\n              relationshipTypes,\n              direction,\n              currentDepth + 1\n            );\n          }\n        }\n      }\n    }\n  }\n\n  // Delete a relationship\n  async deleteRelationship(relationshipId: string): Promise<boolean> {\n    const relationship = await this.getRelationship(relationshipId);\n    if (!relationship) {\n      return false;\n    }\n\n    // Check if global based on memories\n    const fromMemory = await this.getMemory(relationship.from_memory_id);\n    const isGlobal = fromMemory?.is_global || false;\n\n    const pipeline = this.redis.pipeline();\n\n    if (isGlobal) {\n      pipeline.del(RedisKeys.globalRelationship(relationshipId));\n      pipeline.srem(RedisKeys.globalRelationships(), relationshipId);\n      pipeline.srem(RedisKeys.globalMemoryRelationships(relationship.from_memory_id), relationshipId);\n      pipeline.srem(RedisKeys.globalMemoryRelationshipsOut(relationship.from_memory_id), relationshipId);\n      pipeline.srem(RedisKeys.globalMemoryRelationshipsIn(relationship.to_memory_id), relationshipId);\n    } else {\n      pipeline.del(RedisKeys.relationship(this.workspaceId, relationshipId));\n      pipeline.srem(RedisKeys.relationships(this.workspaceId), relationshipId);\n      pipeline.srem(RedisKeys.memoryRelationships(this.workspaceId, relationship.from_memory_id), relationshipId);\n      pipeline.srem(RedisKeys.memoryRelationshipsOut(this.workspaceId, relationship.from_memory_id), relationshipId);\n      pipeline.srem(RedisKeys.memoryRelationshipsIn(this.workspaceId, relationship.to_memory_id), relationshipId);\n    }\n\n    await pipeline.exec();\n\n    return true;\n  }\n\n  // Get full memory graph\n  async getMemoryGraph(\n    rootMemoryId: string,\n    maxDepth: number = 2,\n    maxNodes: number = 50\n  ): Promise<MemoryGraph> {\n    const nodes: Record<string, MemoryGraphNode> = {};\n    const visited = new Set<string>();\n    let maxDepthReached = 0;\n\n    await this.buildGraph(rootMemoryId, maxDepth, maxNodes, nodes, visited, 0);\n\n    // Track max depth actually reached\n    for (const node of Object.values(nodes)) {\n      maxDepthReached = Math.max(maxDepthReached, node.depth);\n    }\n\n    return {\n      root_memory_id: rootMemoryId,\n      nodes,\n      total_nodes: Object.keys(nodes).length,\n      max_depth_reached: maxDepthReached,\n    };\n  }\n\n  // Build graph recursively\n  private async buildGraph(\n    memoryId: string,\n    maxDepth: number,\n    maxNodes: number,\n    nodes: Record<string, MemoryGraphNode>,\n    visited: Set<string>,\n    currentDepth: number\n  ): Promise<void> {\n    if (currentDepth > maxDepth || visited.has(memoryId) || Object.keys(nodes).length >= maxNodes) {\n      return;\n    }\n\n    visited.add(memoryId);\n\n    const memory = await this.getMemory(memoryId);\n    if (!memory) {\n      return;\n    }\n\n    const relationships = await this.getMemoryRelationships(memoryId, 'both');\n\n    nodes[memoryId] = {\n      memory,\n      relationships,\n      depth: currentDepth,\n    };\n\n    // Recurse for related memories\n    for (const relationship of relationships) {\n      const relatedId =\n        relationship.from_memory_id === memoryId\n          ? relationship.to_memory_id\n          : relationship.from_memory_id;\n\n      if (!visited.has(relatedId) && Object.keys(nodes).length < maxNodes) {\n        await this.buildGraph(relatedId, maxDepth, maxNodes, nodes, visited, currentDepth + 1);\n      }\n    }\n  }\n\n  // ============================================================================\n  // Memory Versioning & History (v1.5.0)\n  // ============================================================================\n\n  private async createVersion(\n    memory: MemoryEntry,\n    createdBy: 'user' | 'system' = 'user',\n    changeReason?: string\n  ): Promise<string> {\n    const versionId = ulid();\n    const version: import('../types.js').MemoryVersion = {\n      version_id: versionId,\n      memory_id: memory.id,\n      content: memory.content,\n      context_type: memory.context_type,\n      importance: memory.importance,\n      tags: memory.tags,\n      summary: memory.summary,\n      created_at: new Date().toISOString(),\n      created_by: createdBy,\n      change_reason: changeReason,\n    };\n\n    const isGlobal = memory.is_global;\n    const timestamp = Date.now();\n\n    // Store version and add to sorted set\n    const pipeline = this.redis.pipeline();\n\n    if (isGlobal) {\n      pipeline.hset(\n        RedisKeys.globalMemoryVersion(memory.id, versionId),\n        version as unknown as Record<string, string>\n      );\n      pipeline.zadd(RedisKeys.globalMemoryVersions(memory.id), timestamp, versionId);\n    } else {\n      pipeline.hset(\n        RedisKeys.memoryVersion(this.workspaceId, memory.id, versionId),\n        version as unknown as Record<string, string>\n      );\n      pipeline.zadd(RedisKeys.memoryVersions(this.workspaceId, memory.id), timestamp, versionId);\n    }\n\n    // Enforce version limit (keep 50 most recent)\n    const versionsKey = isGlobal\n      ? RedisKeys.globalMemoryVersions(memory.id)\n      : RedisKeys.memoryVersions(this.workspaceId, memory.id);\n\n    pipeline.zremrangebyrank(versionsKey, 0, -51); // Keep last 50\n\n    await pipeline.exec();\n\n    return versionId;\n  }\n\n  async getMemoryHistory(memoryId: string, limit: number = 50): Promise<import('../types.js').MemoryVersion[]> {\n    const memory = await this.getMemory(memoryId);\n    if (!memory) {\n      return [];\n    }\n\n    const isGlobal = memory.is_global;\n    const versionsKey = isGlobal\n      ? RedisKeys.globalMemoryVersions(memoryId)\n      : RedisKeys.memoryVersions(this.workspaceId, memoryId);\n\n    // Get version IDs (most recent first)\n    const versionIds = await this.redis.zrevrange(versionsKey, 0, limit - 1);\n\n    if (versionIds.length === 0) {\n      return [];\n    }\n\n    // Fetch all versions\n    const versions: import('../types.js').MemoryVersion[] = [];\n    for (const versionId of versionIds) {\n      const versionKey = isGlobal\n        ? RedisKeys.globalMemoryVersion(memoryId, versionId)\n        : RedisKeys.memoryVersion(this.workspaceId, memoryId, versionId);\n\n      const versionData = await this.redis.hgetall(versionKey);\n      if (versionData && Object.keys(versionData).length > 0) {\n        versions.push({\n          version_id: versionData.version_id,\n          memory_id: versionData.memory_id,\n          content: versionData.content,\n          context_type: versionData.context_type as import('../types.js').ContextType,\n          importance: parseInt(versionData.importance, 10),\n          tags: versionData.tags ? JSON.parse(versionData.tags) : [],\n          summary: versionData.summary,\n          created_at: versionData.created_at,\n          created_by: versionData.created_by as 'user' | 'system',\n          change_reason: versionData.change_reason,\n        });\n      }\n    }\n\n    return versions;\n  }\n\n  async rollbackMemory(\n    memoryId: string,\n    versionId: string,\n    preserveRelationships: boolean = true\n  ): Promise<MemoryEntry | null> {\n    const memory = await this.getMemory(memoryId);\n    if (!memory) {\n      throw new Error('Memory not found');\n    }\n\n    // Get the target version\n    const isGlobal = memory.is_global;\n    const versionKey = isGlobal\n      ? RedisKeys.globalMemoryVersion(memoryId, versionId)\n      : RedisKeys.memoryVersion(this.workspaceId, memoryId, versionId);\n\n    const versionData = await this.redis.hgetall(versionKey);\n    if (!versionData || Object.keys(versionData).length === 0) {\n      throw new Error('Version not found');\n    }\n\n    // Save current state as a version before rollback\n    await this.createVersion(memory, 'system', `Before rollback to version ${versionId}`);\n\n    // Prepare rollback updates\n    const updates = {\n      content: versionData.content,\n      context_type: versionData.context_type as import('../types.js').ContextType,\n      importance: parseInt(versionData.importance, 10),\n      tags: versionData.tags ? JSON.parse(versionData.tags) : [],\n      summary: versionData.summary,\n    };\n\n    // Update the memory\n    const rolledBackMemory = await this.updateMemory(memoryId, updates);\n\n    if (rolledBackMemory) {\n      // Create a new version recording the rollback\n      await this.createVersion(rolledBackMemory, 'system', `Rolled back to version ${versionId}`);\n    }\n\n    return rolledBackMemory;\n  }\n\n  // ============================================================================\n  // Memory Templates (v1.5.0)\n  // ============================================================================\n\n  async createTemplate(data: import('../types.js').CreateTemplate): Promise<import('../types.js').MemoryTemplate> {\n    const templateId = ulid();\n    const template: import('../types.js').MemoryTemplate = {\n      template_id: templateId,\n      name: data.name,\n      description: data.description,\n      context_type: data.context_type,\n      content_template: data.content_template,\n      default_tags: data.default_tags,\n      default_importance: data.default_importance,\n      is_builtin: false,\n      created_at: new Date().toISOString(),\n    };\n\n    const pipeline = this.redis.pipeline();\n    pipeline.hset(RedisKeys.template(this.workspaceId, templateId), template as unknown as Record<string, string>);\n    pipeline.sadd(RedisKeys.templates(this.workspaceId), templateId);\n    await pipeline.exec();\n\n    return template;\n  }\n\n  async getTemplate(templateId: string): Promise<import('../types.js').MemoryTemplate | null> {\n    // Check workspace templates first\n    let templateData = await this.redis.hgetall(RedisKeys.template(this.workspaceId, templateId));\n\n    // Check builtin templates if not found\n    if (!templateData || Object.keys(templateData).length === 0) {\n      templateData = await this.redis.hgetall(RedisKeys.builtinTemplate(templateId));\n    }\n\n    if (!templateData || Object.keys(templateData).length === 0) {\n      return null;\n    }\n\n    return {\n      template_id: templateData.template_id,\n      name: templateData.name,\n      description: templateData.description,\n      context_type: templateData.context_type as import('../types.js').ContextType,\n      content_template: templateData.content_template,\n      default_tags: templateData.default_tags ? JSON.parse(templateData.default_tags) : [],\n      default_importance: parseInt(templateData.default_importance, 10),\n      is_builtin: templateData.is_builtin === 'true',\n      created_at: templateData.created_at,\n    };\n  }\n\n  async getAllTemplates(): Promise<import('../types.js').MemoryTemplate[]> {\n    const workspaceIds = await this.redis.smembers(RedisKeys.templates(this.workspaceId));\n    const builtinIds = await this.redis.smembers(RedisKeys.builtinTemplates());\n\n    const allIds = [...new Set([...workspaceIds, ...builtinIds])];\n    const templates: import('../types.js').MemoryTemplate[] = [];\n\n    for (const id of allIds) {\n      const template = await this.getTemplate(id);\n      if (template) {\n        templates.push(template);\n      }\n    }\n\n    return templates;\n  }\n\n  async createFromTemplate(\n    templateId: string,\n    variables: Record<string, string>,\n    additionalTags?: string[],\n    customImportance?: number,\n    isGlobal: boolean = false\n  ): Promise<MemoryEntry> {\n    const template = await this.getTemplate(templateId);\n    if (!template) {\n      throw new Error('Template not found');\n    }\n\n    // Replace variables in content template\n    let content = template.content_template;\n    for (const [key, value] of Object.entries(variables)) {\n      content = content.replace(new RegExp(`{{${key}}}`, 'g'), value);\n    }\n\n    // Check for unreplaced variables\n    const unreplacedVars = content.match(/{{(\\w+)}}/g);\n    if (unreplacedVars) {\n      throw new Error(`Missing variables: ${unreplacedVars.join(', ')}`);\n    }\n\n    // Create memory from template\n    const memoryData: import('../types.js').CreateMemory = {\n      content,\n      context_type: template.context_type,\n      tags: [...template.default_tags, ...(additionalTags || [])],\n      importance: customImportance !== undefined ? customImportance : template.default_importance,\n      is_global: isGlobal,\n    };\n\n    return this.createMemory(memoryData);\n  }\n\n  async deleteTemplate(templateId: string): Promise<boolean> {\n    const template = await this.getTemplate(templateId);\n    if (!template) {\n      return false;\n    }\n\n    if (template.is_builtin) {\n      throw new Error('Cannot delete builtin templates');\n    }\n\n    const pipeline = this.redis.pipeline();\n    pipeline.del(RedisKeys.template(this.workspaceId, templateId));\n    pipeline.srem(RedisKeys.templates(this.workspaceId), templateId);\n    await pipeline.exec();\n\n    return true;\n  }\n\n  // ============================================================================\n  // Memory Categories (v1.5.0)\n  // ============================================================================\n\n  async setMemoryCategory(memoryId: string, category: string): Promise<MemoryEntry | null> {\n    const memory = await this.getMemory(memoryId);\n    if (!memory) {\n      return null;\n    }\n\n    const isGlobal = memory.is_global;\n    const categoryKey = isGlobal\n      ? RedisKeys.globalMemoryCategory(memoryId)\n      : RedisKeys.memoryCategory(this.workspaceId, memoryId);\n    const categorySetKey = isGlobal\n      ? RedisKeys.globalCategory(category)\n      : RedisKeys.category(this.workspaceId, category);\n    const categoriesKey = isGlobal ? RedisKeys.globalCategories() : RedisKeys.categories(this.workspaceId);\n\n    // Remove from old category if exists\n    const oldCategory = await this.redis.get(categoryKey);\n    if (oldCategory) {\n      const oldCategorySetKey = isGlobal\n        ? RedisKeys.globalCategory(oldCategory)\n        : RedisKeys.category(this.workspaceId, oldCategory);\n      await this.redis.srem(oldCategorySetKey, memoryId);\n    }\n\n    const pipeline = this.redis.pipeline();\n\n    // Set new category\n    pipeline.set(categoryKey, category);\n    pipeline.sadd(categorySetKey, memoryId);\n    pipeline.zadd(categoriesKey, Date.now(), category); // Track last used\n\n    await pipeline.exec();\n\n    // Update memory object\n    memory.category = category;\n\n    // Also update the memory hash to include category\n    const memoryKey = isGlobal ? RedisKeys.globalMemory(memoryId) : RedisKeys.memory(this.workspaceId, memoryId);\n    await this.redis.hset(memoryKey, 'category', category);\n\n    return memory;\n  }\n\n  async getMemoriesByCategory(category: string): Promise<MemoryEntry[]> {\n    const mode = getWorkspaceMode();\n    const memoryIds: string[] = [];\n\n    if (mode === WorkspaceMode.ISOLATED || mode === WorkspaceMode.HYBRID) {\n      const workspaceIds = await this.redis.smembers(RedisKeys.category(this.workspaceId, category));\n      memoryIds.push(...workspaceIds);\n    }\n\n    if (mode === WorkspaceMode.GLOBAL || mode === WorkspaceMode.HYBRID) {\n      const globalIds = await this.redis.smembers(RedisKeys.globalCategory(category));\n      memoryIds.push(...globalIds);\n    }\n\n    return this.getMemories(memoryIds);\n  }\n\n  async getAllCategories(): Promise<import('../types.js').CategoryInfo[]> {\n    const mode = getWorkspaceMode();\n    const categoryNames: string[] = [];\n\n    if (mode === WorkspaceMode.ISOLATED || mode === WorkspaceMode.HYBRID) {\n      const workspaceCategories = await this.redis.zrange(RedisKeys.categories(this.workspaceId), 0, -1);\n      categoryNames.push(...workspaceCategories);\n    }\n\n    if (mode === WorkspaceMode.GLOBAL || mode === WorkspaceMode.HYBRID) {\n      const globalCategories = await this.redis.zrange(RedisKeys.globalCategories(), 0, -1);\n      categoryNames.push(...globalCategories);\n    }\n\n    // Deduplicate\n    const uniqueCategories = [...new Set(categoryNames)];\n\n    const categories: import('../types.js').CategoryInfo[] = [];\n    for (const category of uniqueCategories) {\n      const memories = await this.getMemoriesByCategory(category);\n      const lastUsed = await this.redis.zscore(\n        mode === WorkspaceMode.GLOBAL\n          ? RedisKeys.globalCategories()\n          : RedisKeys.categories(this.workspaceId),\n        category\n      );\n\n      categories.push({\n        category,\n        memory_count: memories.length,\n        created_at: new Date(parseInt(lastUsed || '0', 10)).toISOString(),\n        last_used: new Date(parseInt(lastUsed || '0', 10)).toISOString(),\n      });\n    }\n\n    return categories;\n  }\n}\n","import { query } from '@anthropic-ai/claude-agent-sdk';\n\n// Claude doesn't have a native embeddings API, so we'll use a lightweight approach:\n// Generate a semantic \"fingerprint\" by having Claude extract key concepts\nasync function generateSemanticFingerprint(text: string): Promise<string[]> {\n  try {\n    const prompt = `Extract 5-10 key concepts/keywords from this text. Return ONLY a comma-separated list, no explanations:\n\n${text}`;\n\n    const q = query({ prompt });\n\n    // Collect the response\n    let responseText = '';\n    for await (const message of q) {\n      if (message.type === 'assistant' && message.content) {\n        for (const block of message.content) {\n          if (block.type === 'text') {\n            responseText += block.text;\n          }\n        }\n      }\n    }\n\n    // Parse comma-separated keywords\n    const keywords = responseText\n      .split(',')\n      .map(k => k.trim().toLowerCase())\n      .filter(k => k.length > 0);\n\n    return keywords;\n  } catch (error) {\n    console.error('Error generating semantic fingerprint:', error);\n    throw error;\n  }\n}\n\n// Convert text to a simple vector representation using character n-grams and keywords\nexport async function generateEmbedding(text: string): Promise<number[]> {\n  try {\n    // Get semantic keywords from Claude\n    const keywords = await generateSemanticFingerprint(text);\n\n    // Create a simple vector representation\n    // This is a lightweight approach that combines:\n    // 1. Character trigrams (for text similarity)\n    // 2. Semantic keywords (from Claude)\n    const vector = createSimpleVector(text, keywords);\n\n    return vector;\n  } catch (error) {\n    console.error('Error generating embedding:', error);\n    throw error;\n  }\n}\n\nexport async function generateEmbeddings(texts: string[]): Promise<number[][]> {\n  try {\n    // Process in parallel\n    const embeddings = await Promise.all(\n      texts.map(text => generateEmbedding(text))\n    );\n    return embeddings;\n  } catch (error) {\n    console.error('Error generating embeddings:', error);\n    throw error;\n  }\n}\n\n// Create a simple 128-dimensional vector from text and keywords\nfunction createSimpleVector(text: string, keywords: string[]): number[] {\n  const VECTOR_SIZE = 128;\n  const vector = new Array(VECTOR_SIZE).fill(0);\n\n  // Normalize text\n  const normalized = text.toLowerCase();\n\n  // Part 1: Character trigrams (first 64 dimensions)\n  const trigrams = extractTrigrams(normalized);\n  for (let i = 0; i < Math.min(trigrams.length, 64); i++) {\n    const hash = simpleHash(trigrams[i]);\n    const index = hash % 64;\n    vector[index] += 1;\n  }\n\n  // Part 2: Keyword-based features (last 64 dimensions)\n  for (const keyword of keywords) {\n    const hash = simpleHash(keyword);\n    const index = 64 + (hash % 64);\n    vector[index] += 2; // Weight keywords higher\n  }\n\n  // Normalize the vector\n  const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\n  if (magnitude > 0) {\n    for (let i = 0; i < vector.length; i++) {\n      vector[i] /= magnitude;\n    }\n  }\n\n  return vector;\n}\n\n// Extract character trigrams from text\nfunction extractTrigrams(text: string): string[] {\n  const trigrams: string[] = [];\n  for (let i = 0; i < text.length - 2; i++) {\n    trigrams.push(text.substring(i, i + 3));\n  }\n  return trigrams;\n}\n\n// Simple hash function\nfunction simpleHash(str: string): number {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash);\n}\n\n// Cosine similarity calculation\nexport function cosineSimilarity(a: number[], b: number[]): number {\n  if (a.length !== b.length) {\n    throw new Error('Vectors must have the same length');\n  }\n\n  let dotProduct = 0;\n  let normA = 0;\n  let normB = 0;\n\n  for (let i = 0; i < a.length; i++) {\n    dotProduct += a[i] * b[i];\n    normA += a[i] * a[i];\n    normB += b[i] * b[i];\n  }\n\n  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n}\n","import { z } from 'zod';\n\n// Context types for different kinds of memory\nexport const ContextType = z.enum([\n  'directive',      // Instructions or commands\n  'information',    // General facts or knowledge\n  'heading',        // Section headers or organizational markers\n  'decision',       // Decisions made during work\n  'code_pattern',   // Code patterns or conventions\n  'requirement',    // Project requirements\n  'error',          // Error encountered and solution\n  'todo',           // Task or todo item\n  'insight',        // Key insight or realization\n  'preference',     // User preference\n]);\n\nexport type ContextType = z.infer<typeof ContextType>;\n\n// Memory entry schema\nexport const MemoryEntrySchema = z.object({\n  id: z.string().describe('ULID identifier'),\n  timestamp: z.number().describe('Unix timestamp in milliseconds'),\n  context_type: ContextType,\n  content: z.string().describe('The actual memory content'),\n  summary: z.string().optional().describe('Short summary for quick scanning'),\n  tags: z.array(z.string()).default([]).describe('Tags for categorization'),\n  importance: z.number().min(1).max(10).default(5).describe('Importance score 1-10'),\n  session_id: z.string().optional().describe('Optional session grouping'),\n  embedding: z.array(z.number()).optional().describe('Vector embedding'),\n  ttl_seconds: z.number().optional().describe('Time-to-live in seconds (auto-expires)'),\n  expires_at: z.number().optional().describe('Unix timestamp when memory expires'),\n  is_global: z.boolean().default(false).describe('If true, memory is accessible across all workspaces'),\n  workspace_id: z.string().describe('Workspace identifier (empty for global memories)'),\n  category: z.string().optional().describe('Category for organization (v1.5.0)'),\n});\n\nexport type MemoryEntry = z.infer<typeof MemoryEntrySchema>;\n\n// Input schema for creating memories\nexport const CreateMemorySchema = z.object({\n  content: z.string().min(1).describe('The memory content to store'),\n  context_type: ContextType.default('information'),\n  tags: z.array(z.string()).default([]).describe('Tags for categorization'),\n  importance: z.number().min(1).max(10).default(5).describe('Importance score 1-10'),\n  summary: z.string().optional().describe('Optional summary'),\n  session_id: z.string().optional().describe('Optional session ID'),\n  ttl_seconds: z.number().min(60).optional().describe('Time-to-live in seconds (minimum 60s)'),\n  is_global: z.boolean().default(false).describe('If true, memory is accessible across all workspaces'),\n  category: z.string().optional().describe('Category for organization (v1.5.0)'),\n});\n\nexport type CreateMemory = z.infer<typeof CreateMemorySchema>;\n\n// Batch create schema\nexport const BatchCreateMemoriesSchema = z.object({\n  memories: z.array(CreateMemorySchema).min(1).describe('Array of memories to store'),\n});\n\n// Update memory schema\nexport const UpdateMemorySchema = z.object({\n  memory_id: z.string().describe('ULID of memory to update'),\n  content: z.string().optional(),\n  context_type: ContextType.optional(),\n  tags: z.array(z.string()).optional(),\n  importance: z.number().min(1).max(10).optional(),\n  summary: z.string().optional(),\n  session_id: z.string().optional(),\n  category: z.string().optional().describe('Category for organization (v1.5.0)'),\n});\n\n// Delete memory schema\nexport const DeleteMemorySchema = z.object({\n  memory_id: z.string().describe('ULID of memory to delete'),\n});\n\n// Search schema\nexport const SearchMemorySchema = z.object({\n  query: z.string().describe('Search query'),\n  limit: z.number().min(1).max(100).default(10).describe('Number of results'),\n  min_importance: z.number().min(1).max(10).optional().describe('Filter by minimum importance'),\n  context_types: z.array(ContextType).optional().describe('Filter by context types'),\n  category: z.string().optional().describe('Filter by category (v1.5.0)'),\n  fuzzy: z.boolean().default(false).describe('Enable fuzzy search (v1.5.0)'),\n  regex: z.string().optional().describe('Regex pattern for advanced search (v1.5.0)'),\n});\n\n// Session organization schema\nexport const OrganizeSessionSchema = z.object({\n  session_name: z.string().describe('Name for the session'),\n  memory_ids: z.array(z.string()).min(1).describe('Array of memory IDs to include'),\n  summary: z.string().optional().describe('Optional session summary'),\n});\n\n// Session info\nexport interface SessionInfo {\n  session_id: string;\n  session_name: string;\n  created_at: number;\n  memory_count: number;\n  summary?: string;\n  memory_ids: string[];\n}\n\n// Workspace mode configuration\nexport enum WorkspaceMode {\n  ISOLATED = 'isolated',  // Default: workspace-only (current behavior)\n  GLOBAL = 'global',      // All memories shared across workspaces\n  HYBRID = 'hybrid'       // Support both global + workspace memories\n}\n\n// Workspace context\nexport interface WorkspaceContext {\n  workspace_path: string;\n  workspace_id: string; // Hash of the path for Redis keys\n  mode: WorkspaceMode;   // Workspace isolation mode\n}\n\n// Helper to create workspace ID from path\nexport function createWorkspaceId(path: string): string {\n  // Simple hash function for workspace path\n  let hash = 0;\n  for (let i = 0; i < path.length; i++) {\n    const char = path.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(36);\n}\n\n// Helper to get workspace mode from environment\nexport function getWorkspaceMode(): WorkspaceMode {\n  const mode = process.env.WORKSPACE_MODE?.toLowerCase();\n\n  switch (mode) {\n    case 'global':\n      return WorkspaceMode.GLOBAL;\n    case 'hybrid':\n      return WorkspaceMode.HYBRID;\n    case 'isolated':\n    default:\n      return WorkspaceMode.ISOLATED;\n  }\n}\n\n// Recall context schema (for proactive context retrieval)\nexport const RecallContextSchema = z.object({\n  current_task: z.string().describe('Description of what I\\'m currently working on'),\n  query: z.string().optional().describe('Optional specific search query'),\n  limit: z.number().min(1).max(20).default(5).describe('Number of results to return'),\n  min_importance: z.number().min(1).max(10).default(6).describe('Minimum importance threshold'),\n});\n\nexport type RecallContext = z.infer<typeof RecallContextSchema>;\n\n// Analyze conversation schema (for extracting structured memories)\nexport const AnalyzeConversationSchema = z.object({\n  conversation_text: z.string().min(1).describe('Conversation text to analyze and extract memories from'),\n  auto_categorize: z.boolean().default(true).describe('Automatically categorize extracted memories'),\n  auto_store: z.boolean().default(true).describe('Automatically store extracted memories'),\n});\n\nexport type AnalyzeConversation = z.infer<typeof AnalyzeConversationSchema>;\n\n// Summarize session schema\nexport const SummarizeSessionSchema = z.object({\n  session_name: z.string().optional().describe('Optional name for the session'),\n  auto_create_snapshot: z.boolean().default(true).describe('Automatically create session snapshot'),\n  lookback_minutes: z.number().default(60).describe('How many minutes back to look for memories'),\n});\n\nexport type SummarizeSession = z.infer<typeof SummarizeSessionSchema>;\n\n// Extracted memory from conversation analysis\nexport interface ExtractedMemory {\n  content: string;\n  context_type: ContextType;\n  importance: number;\n  tags: string[];\n  summary?: string;\n}\n\n// Analysis result\nexport interface AnalysisResult {\n  extracted_memories: ExtractedMemory[];\n  total_count: number;\n  stored_ids?: string[];\n}\n\n// Export memories schema\nexport const ExportMemoriesSchema = z.object({\n  format: z.enum(['json']).default('json').describe('Export format'),\n  include_embeddings: z.boolean().default(false).describe('Include vector embeddings in export'),\n  filter_by_type: z.array(ContextType).optional().describe('Only export specific types'),\n  min_importance: z.number().min(1).max(10).optional().describe('Only export above this importance'),\n});\n\nexport type ExportMemories = z.infer<typeof ExportMemoriesSchema>;\n\n// Import memories schema\nexport const ImportMemoriesSchema = z.object({\n  data: z.string().describe('JSON string of exported memories'),\n  overwrite_existing: z.boolean().default(false).describe('Overwrite if memory ID already exists'),\n  regenerate_embeddings: z.boolean().default(true).describe('Regenerate embeddings on import'),\n});\n\nexport type ImportMemories = z.infer<typeof ImportMemoriesSchema>;\n\n// Find duplicates schema\nexport const FindDuplicatesSchema = z.object({\n  similarity_threshold: z.number().min(0).max(1).default(0.85).describe('Similarity threshold (0-1)'),\n  auto_merge: z.boolean().default(false).describe('Automatically merge duplicates'),\n  keep_highest_importance: z.boolean().default(true).describe('When merging, keep highest importance'),\n});\n\nexport type FindDuplicates = z.infer<typeof FindDuplicatesSchema>;\n\n// Consolidate memories schema\nexport const ConsolidateMemoriesSchema = z.object({\n  memory_ids: z.array(z.string()).min(2).describe('Array of memory IDs to consolidate'),\n  keep_id: z.string().optional().describe('Optional ID of memory to keep (default: highest importance)'),\n});\n\nexport type ConsolidateMemories = z.infer<typeof ConsolidateMemoriesSchema>;\n\n// Duplicate group interface\nexport interface DuplicateGroup {\n  memories: MemoryEntry[];\n  similarity_score: number;\n}\n\n// Redis keys helper with workspace isolation and global support\nexport const RedisKeys = {\n  // Workspace-scoped keys\n  memory: (workspace: string, id: string) => `ws:${workspace}:memory:${id}`,\n  memories: (workspace: string) => `ws:${workspace}:memories:all`,\n  byType: (workspace: string, type: ContextType) => `ws:${workspace}:memories:type:${type}`,\n  byTag: (workspace: string, tag: string) => `ws:${workspace}:memories:tag:${tag}`,\n  timeline: (workspace: string) => `ws:${workspace}:memories:timeline`,\n  session: (workspace: string, id: string) => `ws:${workspace}:session:${id}`,\n  sessions: (workspace: string) => `ws:${workspace}:sessions:all`,\n  important: (workspace: string) => `ws:${workspace}:memories:important`,\n\n  // Global keys (workspace-independent)\n  globalMemory: (id: string) => `global:memory:${id}`,\n  globalMemories: () => `global:memories:all`,\n  globalByType: (type: ContextType) => `global:memories:type:${type}`,\n  globalByTag: (tag: string) => `global:memories:tag:${tag}`,\n  globalTimeline: () => `global:memories:timeline`,\n  globalImportant: () => `global:memories:important`,\n\n  // Relationship keys (v1.4.0)\n  relationship: (workspace: string, id: string) => `ws:${workspace}:relationship:${id}`,\n  relationships: (workspace: string) => `ws:${workspace}:relationships:all`,\n  memoryRelationships: (workspace: string, memoryId: string) =>\n    `ws:${workspace}:memory:${memoryId}:relationships`,\n  memoryRelationshipsOut: (workspace: string, memoryId: string) =>\n    `ws:${workspace}:memory:${memoryId}:relationships:out`,\n  memoryRelationshipsIn: (workspace: string, memoryId: string) =>\n    `ws:${workspace}:memory:${memoryId}:relationships:in`,\n\n  // Global relationship keys\n  globalRelationship: (id: string) => `global:relationship:${id}`,\n  globalRelationships: () => `global:relationships:all`,\n  globalMemoryRelationships: (memoryId: string) => `global:memory:${memoryId}:relationships`,\n  globalMemoryRelationshipsOut: (memoryId: string) => `global:memory:${memoryId}:relationships:out`,\n  globalMemoryRelationshipsIn: (memoryId: string) => `global:memory:${memoryId}:relationships:in`,\n\n  // Version history keys (v1.5.0)\n  memoryVersions: (workspace: string, memoryId: string) => `ws:${workspace}:memory:${memoryId}:versions`,\n  memoryVersion: (workspace: string, memoryId: string, versionId: string) =>\n    `ws:${workspace}:memory:${memoryId}:version:${versionId}`,\n  globalMemoryVersions: (memoryId: string) => `global:memory:${memoryId}:versions`,\n  globalMemoryVersion: (memoryId: string, versionId: string) => `global:memory:${memoryId}:version:${versionId}`,\n\n  // Template keys (v1.5.0)\n  template: (workspace: string, id: string) => `ws:${workspace}:template:${id}`,\n  templates: (workspace: string) => `ws:${workspace}:templates:all`,\n  builtinTemplates: () => `builtin:templates:all`,\n  builtinTemplate: (id: string) => `builtin:template:${id}`,\n\n  // Category keys (v1.5.0)\n  memoryCategory: (workspace: string, memoryId: string) => `ws:${workspace}:memory:${memoryId}:category`,\n  category: (workspace: string, category: string) => `ws:${workspace}:category:${category}`,\n  categories: (workspace: string) => `ws:${workspace}:categories:all`,\n  globalMemoryCategory: (memoryId: string) => `global:memory:${memoryId}:category`,\n  globalCategory: (category: string) => `global:category:${category}`,\n  globalCategories: () => `global:categories:all`,\n} as const;\n\n// Helper to get the appropriate key based on is_global flag\nexport function getMemoryKey(workspace: string, id: string, isGlobal: boolean): string {\n  return isGlobal ? RedisKeys.globalMemory(id) : RedisKeys.memory(workspace, id);\n}\n\n// Convert memory to global schema\nexport const ConvertToGlobalSchema = z.object({\n  memory_id: z.string().describe('ID of the memory to convert to global'),\n});\n\nexport type ConvertToGlobal = z.infer<typeof ConvertToGlobalSchema>;\n\n// Convert memory to workspace schema\nexport const ConvertToWorkspaceSchema = z.object({\n  memory_id: z.string().describe('ID of the global memory to convert to workspace-specific'),\n  workspace_id: z.string().optional().describe('Target workspace (default: current workspace)'),\n});\n\nexport type ConvertToWorkspace = z.infer<typeof ConvertToWorkspaceSchema>;\n\n// ============================================================================\n// Memory Relationships (v1.4.0)\n// ============================================================================\n\n// Relationship types\nexport enum RelationshipType {\n  RELATES_TO = 'relates_to',      // Generic connection\n  PARENT_OF = 'parent_of',         // Hierarchical (from is parent)\n  CHILD_OF = 'child_of',           // Hierarchical (from is child)\n  REFERENCES = 'references',       // From references to\n  SUPERSEDES = 'supersedes',       // From replaces to\n  IMPLEMENTS = 'implements',       // From implements to\n  EXAMPLE_OF = 'example_of',       // From is example of to\n}\n\n// Memory relationship schema\nexport const MemoryRelationshipSchema = z.object({\n  id: z.string().describe('Unique relationship identifier (ULID)'),\n  from_memory_id: z.string().describe('Source memory ID'),\n  to_memory_id: z.string().describe('Target memory ID'),\n  relationship_type: z.nativeEnum(RelationshipType).describe('Type of relationship'),\n  created_at: z.string().describe('ISO 8601 timestamp'),\n  metadata: z.record(z.unknown()).optional().describe('Optional metadata'),\n});\n\nexport type MemoryRelationship = z.infer<typeof MemoryRelationshipSchema>;\n\n// Link memories schema\nexport const LinkMemoriesSchema = z.object({\n  from_memory_id: z.string().describe('Source memory ID'),\n  to_memory_id: z.string().describe('Target memory ID'),\n  relationship_type: z.nativeEnum(RelationshipType).describe('Type of relationship'),\n  metadata: z.record(z.unknown()).optional().describe('Optional metadata'),\n});\n\nexport type LinkMemories = z.infer<typeof LinkMemoriesSchema>;\n\n// Get related memories schema\nexport const GetRelatedMemoriesSchema = z.object({\n  memory_id: z.string().describe('Memory ID to get relationships for'),\n  relationship_types: z.array(z.nativeEnum(RelationshipType)).optional().describe('Filter by relationship types'),\n  depth: z.number().min(1).max(5).default(1).describe('Traversal depth (1-5)'),\n  direction: z.enum(['outgoing', 'incoming', 'both']).default('both').describe('Relationship direction'),\n});\n\nexport type GetRelatedMemories = z.infer<typeof GetRelatedMemoriesSchema>;\n\n// Unlink memories schema\nexport const UnlinkMemoriesSchema = z.object({\n  relationship_id: z.string().describe('Relationship ID to remove'),\n});\n\nexport type UnlinkMemories = z.infer<typeof UnlinkMemoriesSchema>;\n\n// Get memory graph schema\nexport const GetMemoryGraphSchema = z.object({\n  memory_id: z.string().describe('Root memory ID for graph'),\n  max_depth: z.number().min(1).max(3).default(2).describe('Maximum graph depth'),\n  max_nodes: z.number().min(1).max(100).default(50).describe('Maximum nodes to return'),\n});\n\nexport type GetMemoryGraph = z.infer<typeof GetMemoryGraphSchema>;\n\n// Related memory result (with relationship context)\nexport interface RelatedMemoryResult {\n  memory: MemoryEntry;\n  relationship: MemoryRelationship;\n  depth: number;\n}\n\n// Memory graph node\nexport interface MemoryGraphNode {\n  memory: MemoryEntry;\n  relationships: MemoryRelationship[];\n  depth: number;\n}\n\n// Memory graph structure\nexport interface MemoryGraph {\n  root_memory_id: string;\n  nodes: Record<string, MemoryGraphNode>;\n  total_nodes: number;\n  max_depth_reached: number;\n}\n\n// ============================================================================\n// Memory Versioning & History (v1.5.0)\n// ============================================================================\n\n// Memory version schema\nexport const MemoryVersionSchema = z.object({\n  version_id: z.string().describe('Version identifier (ULID)'),\n  memory_id: z.string().describe('Memory this version belongs to'),\n  content: z.string().describe('Content at this version'),\n  context_type: ContextType,\n  importance: z.number().min(1).max(10),\n  tags: z.array(z.string()).default([]),\n  summary: z.string().optional(),\n  created_at: z.string().describe('ISO 8601 timestamp'),\n  created_by: z.enum(['user', 'system']).default('user').describe('Who created this version'),\n  change_reason: z.string().optional().describe('Reason for the change'),\n});\n\nexport type MemoryVersion = z.infer<typeof MemoryVersionSchema>;\n\n// Get memory history schema\nexport const GetMemoryHistorySchema = z.object({\n  memory_id: z.string().describe('Memory ID to get history for'),\n  limit: z.number().min(1).max(100).default(50).describe('Maximum versions to return'),\n});\n\nexport type GetMemoryHistory = z.infer<typeof GetMemoryHistorySchema>;\n\n// Rollback memory schema\nexport const RollbackMemorySchema = z.object({\n  memory_id: z.string().describe('Memory ID to rollback'),\n  version_id: z.string().describe('Version ID to rollback to'),\n  preserve_relationships: z.boolean().default(true).describe('Preserve current relationships after rollback'),\n});\n\nexport type RollbackMemory = z.infer<typeof RollbackMemorySchema>;\n\n// Memory diff result\nexport interface MemoryDiff {\n  version_from: MemoryVersion;\n  version_to: MemoryVersion;\n  content_diff: {\n    added: string[];\n    removed: string[];\n    unchanged: string[];\n  };\n  importance_change: number;\n  tags_added: string[];\n  tags_removed: string[];\n  context_type_changed: boolean;\n}\n\n// ============================================================================\n// Memory Templates (v1.5.0)\n// ============================================================================\n\n// Template schema\nexport const MemoryTemplateSchema = z.object({\n  template_id: z.string().describe('Template identifier (ULID)'),\n  name: z.string().describe('Template name'),\n  description: z.string().optional().describe('Template description'),\n  context_type: ContextType,\n  content_template: z.string().describe('Template content with {{placeholders}}'),\n  default_tags: z.array(z.string()).default([]),\n  default_importance: z.number().min(1).max(10).default(5),\n  is_builtin: z.boolean().default(false).describe('Built-in template (cannot be deleted)'),\n  created_at: z.string().describe('ISO 8601 timestamp'),\n});\n\nexport type MemoryTemplate = z.infer<typeof MemoryTemplateSchema>;\n\n// Create from template schema\nexport const CreateFromTemplateSchema = z.object({\n  template_id: z.string().describe('Template ID to use'),\n  variables: z.record(z.string()).describe('Variables to fill in template (key-value pairs)'),\n  tags: z.array(z.string()).optional().describe('Additional tags (merged with template defaults)'),\n  importance: z.number().min(1).max(10).optional().describe('Override template importance'),\n  is_global: z.boolean().default(false).describe('Create as global memory'),\n});\n\nexport type CreateFromTemplate = z.infer<typeof CreateFromTemplateSchema>;\n\n// Create template schema\nexport const CreateTemplateSchema = z.object({\n  name: z.string().min(1).describe('Template name'),\n  description: z.string().optional().describe('Template description'),\n  context_type: ContextType.default('information'),\n  content_template: z.string().min(1).describe('Template content with {{placeholders}}'),\n  default_tags: z.array(z.string()).default([]),\n  default_importance: z.number().min(1).max(10).default(5),\n});\n\nexport type CreateTemplate = z.infer<typeof CreateTemplateSchema>;\n\n// ============================================================================\n// Memory Categories (v1.5.0)\n// ============================================================================\n\n// Add category to memory schema (extends UpdateMemorySchema)\nexport const SetMemoryCategorySchema = z.object({\n  memory_id: z.string().describe('Memory ID'),\n  category: z.string().describe('Category name'),\n});\n\nexport type SetMemoryCategory = z.infer<typeof SetMemoryCategorySchema>;\n\n// List categories schema\nexport const ListCategoriesSchema = z.object({\n  include_counts: z.boolean().default(true).describe('Include memory counts per category'),\n});\n\nexport type ListCategories = z.infer<typeof ListCategoriesSchema>;\n\n// Category info\nexport interface CategoryInfo {\n  category: string;\n  memory_count?: number;\n  created_at: string;\n  last_used: string;\n}\n","import { z } from 'zod';\nimport { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport { ConversationAnalyzer } from '../analysis/conversation-analyzer.js';\nimport {\n  RecallContextSchema,\n  AnalyzeConversationSchema,\n  SummarizeSessionSchema,\n  type AnalysisResult,\n} from '../types.js';\n\nconst memoryStore = new MemoryStore();\nconst analyzer = new ConversationAnalyzer();\n\n/**\n * recall_relevant_context - Proactively retrieve relevant memories for current task\n */\nexport const recall_relevant_context = {\n  description: 'Proactively search memory for context relevant to current task. Use this when you need to recall patterns, decisions, or conventions.',\n  inputSchema: zodToJsonSchema(RecallContextSchema),\n  handler: async (args: z.infer<typeof RecallContextSchema>) => {\n    try {\n      // Enhance the search query\n      const enhancedQuery = await analyzer.enhanceQuery(args.current_task, args.query);\n\n      // Semantic search with filters\n      const results = await memoryStore.searchMemories(\n        enhancedQuery,\n        args.limit,\n        args.min_importance\n      );\n\n      // Format results for Claude to read\n      const formattedResults = results.map(r => ({\n        content: r.content,\n        summary: r.summary,\n        context_type: r.context_type,\n        importance: r.importance,\n        tags: r.tags,\n        similarity: Math.round(r.similarity * 100) / 100,\n      }));\n\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify({\n              current_task: args.current_task,\n              found: results.length,\n              relevant_memories: formattedResults,\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to recall context: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  },\n};\n\n/**\n * analyze_and_remember - Extract structured memories from conversation\n */\nexport const analyze_and_remember = {\n  description: 'Analyze conversation text and automatically extract and store important information (decisions, patterns, directives, etc.). Use this after important discussions.',\n  inputSchema: zodToJsonSchema(AnalyzeConversationSchema),\n  handler: async (args: z.infer<typeof AnalyzeConversationSchema>) => {\n    try {\n      // Analyze conversation to extract memories\n      const extracted = await analyzer.analyzeConversation(args.conversation_text);\n\n      const result: AnalysisResult = {\n        extracted_memories: extracted,\n        total_count: extracted.length,\n      };\n\n      // Auto-store if requested\n      if (args.auto_store && extracted.length > 0) {\n        const memories = await memoryStore.createMemories(\n          extracted.map(e => ({\n            content: e.content,\n            context_type: e.context_type,\n            importance: e.importance,\n            tags: e.tags,\n            summary: e.summary,\n          }))\n        );\n\n        result.stored_ids = memories.map(m => m.id);\n      }\n\n      // Format response\n      const response = {\n        success: true,\n        analyzed: result.total_count,\n        stored: result.stored_ids?.length || 0,\n        breakdown: {\n          directives: extracted.filter(e => e.context_type === 'directive').length,\n          decisions: extracted.filter(e => e.context_type === 'decision').length,\n          patterns: extracted.filter(e => e.context_type === 'code_pattern').length,\n          requirements: extracted.filter(e => e.context_type === 'requirement').length,\n          errors: extracted.filter(e => e.context_type === 'error').length,\n          insights: extracted.filter(e => e.context_type === 'insight').length,\n          other: extracted.filter(e => !['directive', 'decision', 'code_pattern', 'requirement', 'error', 'insight'].includes(e.context_type)).length,\n        },\n        memories: extracted.map(e => ({\n          content: e.content.substring(0, 100) + (e.content.length > 100 ? '...' : ''),\n          type: e.context_type,\n          importance: e.importance,\n        })),\n      };\n\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify(response, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to analyze conversation: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  },\n};\n\n/**\n * summarize_session - Create a session summary and snapshot\n */\nexport const summarize_session = {\n  description: 'Summarize the current work session and create a snapshot. Use this at the end of a work session to preserve context.',\n  inputSchema: zodToJsonSchema(SummarizeSessionSchema),\n  handler: async (args: z.infer<typeof SummarizeSessionSchema>) => {\n    try {\n      // Get recent memories from the lookback period\n      const lookbackMs = args.lookback_minutes * 60 * 1000;\n      const cutoffTime = Date.now() - lookbackMs;\n\n      const allRecent = await memoryStore.getRecentMemories(100);\n      const sessionMemories = allRecent.filter(m => m.timestamp >= cutoffTime);\n\n      if (sessionMemories.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: false,\n                message: 'No memories found in the specified lookback period',\n                lookback_minutes: args.lookback_minutes,\n              }, null, 2),\n            },\n          ],\n        };\n      }\n\n      // Generate summary using Claude\n      const summary = await analyzer.summarizeSession(\n        sessionMemories.map(m => ({\n          content: m.content,\n          context_type: m.context_type,\n          importance: m.importance,\n        }))\n      );\n\n      let sessionInfo = null;\n\n      // Create session snapshot if requested\n      if (args.auto_create_snapshot) {\n        const sessionName = args.session_name || `Session ${new Date().toISOString().split('T')[0]}`;\n        sessionInfo = await memoryStore.createSession(\n          sessionName,\n          sessionMemories.map(m => m.id),\n          summary\n        );\n      }\n\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              summary,\n              session_id: sessionInfo?.session_id,\n              session_name: sessionInfo?.session_name,\n              memory_count: sessionMemories.length,\n              lookback_minutes: args.lookback_minutes,\n              breakdown: {\n                directives: sessionMemories.filter(m => m.context_type === 'directive').length,\n                decisions: sessionMemories.filter(m => m.context_type === 'decision').length,\n                patterns: sessionMemories.filter(m => m.context_type === 'code_pattern').length,\n                insights: sessionMemories.filter(m => m.context_type === 'insight').length,\n              },\n            }, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to summarize session: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  },\n};\n\n// Helper function to convert Zod schema to JSON Schema (same as in tools/index.ts)\nfunction zodToJsonSchema(schema: z.ZodType): any {\n  if (schema instanceof z.ZodObject) {\n    const shape = schema._def.shape();\n    const properties: any = {};\n    const required: string[] = [];\n\n    for (const [key, value] of Object.entries(shape)) {\n      properties[key] = zodToJsonSchemaInner(value as z.ZodType);\n      if (!(value as any).isOptional()) {\n        required.push(key);\n      }\n    }\n\n    return {\n      type: 'object',\n      properties,\n      required,\n    };\n  }\n\n  return zodToJsonSchemaInner(schema);\n}\n\nfunction zodToJsonSchemaInner(schema: z.ZodType): any {\n  if (schema instanceof z.ZodString) {\n    const result: any = { type: 'string' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodNumber) {\n    const result: any = { type: 'number' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodBoolean) {\n    const result: any = { type: 'boolean' };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodArray) {\n    const result: any = {\n      type: 'array',\n      items: zodToJsonSchemaInner(schema.element),\n    };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodEnum) {\n    const result: any = {\n      type: 'string',\n      enum: schema.options,\n    };\n    if (schema.description) result.description = schema.description;\n    return result;\n  }\n\n  if (schema instanceof z.ZodOptional) {\n    return zodToJsonSchemaInner(schema.unwrap());\n  }\n\n  if (schema instanceof z.ZodDefault) {\n    const inner = zodToJsonSchemaInner(schema._def.innerType);\n    inner.default = schema._def.defaultValue();\n    return inner;\n  }\n\n  if (schema instanceof z.ZodObject) {\n    return zodToJsonSchema(schema);\n  }\n\n  return { type: 'string' };\n}\n","import { query } from '@anthropic-ai/claude-agent-sdk';\nimport type { ExtractedMemory, ContextType, AnalysisResult } from '../types.js';\n\nexport class ConversationAnalyzer {\n  constructor() {\n    // No API key needed - uses Claude Code subscription via the SDK\n  }\n\n  /**\n   * Analyze conversation and extract structured memories\n   */\n  async analyzeConversation(conversationText: string): Promise<ExtractedMemory[]> {\n    try {\n      const prompt = `Analyze this conversation and extract important information that should be remembered long-term.\n\nFor each important piece of information, output EXACTLY in this JSON format (one per line):\n{\"content\":\"the information\",\"type\":\"directive|information|decision|code_pattern|requirement|error|todo|insight|preference\",\"importance\":1-10,\"tags\":[\"tag1\",\"tag2\"],\"summary\":\"brief summary\"}\n\nGuidelines:\n- Extract directives (instructions to follow)\n- Extract decisions (choices made)\n- Extract code_patterns (coding conventions)\n- Extract requirements (project specs)\n- Extract errors (problems and solutions)\n- Extract insights (key realizations)\n- Extract preferences (user preferences)\n- Importance: 10=critical, 8-9=very important, 6-7=important, 1-5=nice to have\n- Tags: relevant keywords for categorization\n- Summary: max 50 chars\n\nConversation:\n${conversationText}\n\nOutput ONLY the JSON objects, one per line, no other text:`;\n\n      const q = query({ prompt });\n\n      // Collect the response\n      let responseText = '';\n      for await (const message of q) {\n        if (message.type === 'assistant' && message.content) {\n          for (const block of message.content) {\n            if (block.type === 'text') {\n              responseText += block.text;\n            }\n          }\n        }\n      }\n\n      // Parse JSON lines\n      const lines = responseText.split('\\n').filter(line => line.trim().startsWith('{'));\n      const extracted: ExtractedMemory[] = [];\n\n      for (const line of lines) {\n        try {\n          const parsed = JSON.parse(line.trim());\n\n          // Validate and normalize\n          if (parsed.content && parsed.type && parsed.importance) {\n            extracted.push({\n              content: parsed.content,\n              context_type: this.normalizeContextType(parsed.type),\n              importance: Math.min(10, Math.max(1, parseInt(parsed.importance))),\n              tags: Array.isArray(parsed.tags) ? parsed.tags : [],\n              summary: parsed.summary || undefined,\n            });\n          }\n        } catch (e) {\n          console.error('Failed to parse line:', line, e);\n          // Skip malformed JSON\n        }\n      }\n\n      return extracted;\n    } catch (error) {\n      console.error('Error analyzing conversation:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate a summary of a session\n   */\n  async summarizeSession(memories: Array<{ content: string; context_type: string; importance: number }>): Promise<string> {\n    try {\n      const memoriesText = memories\n        .sort((a, b) => b.importance - a.importance)\n        .map(m => `[${m.context_type}] ${m.content}`)\n        .join('\\n');\n\n      const prompt = `Summarize this work session in 2-3 sentences. Focus on what was accomplished, decided, or learned.\n\nSession memories:\n${memoriesText}\n\nSummary (2-3 sentences):`;\n\n      const q = query({ prompt });\n\n      // Collect the response\n      let responseText = '';\n      for await (const message of q) {\n        if (message.type === 'assistant' && message.content) {\n          for (const block of message.content) {\n            if (block.type === 'text') {\n              responseText += block.text;\n            }\n          }\n        }\n      }\n\n      return responseText.trim() || 'Session completed with multiple activities';\n    } catch (error) {\n      console.error('Error summarizing session:', error);\n      return 'Session summary unavailable';\n    }\n  }\n\n  /**\n   * Enhance a search query for better semantic matching\n   */\n  async enhanceQuery(currentTask: string, query?: string): Promise<string> {\n    const combined = query ? `${currentTask} ${query}` : currentTask;\n\n    // For now, just return the combined query\n    // Could use Claude to expand/enhance the query in the future\n    return combined;\n  }\n\n  /**\n   * Normalize context type strings from Claude\n   */\n  private normalizeContextType(type: string): ContextType {\n    const normalized = type.toLowerCase().trim();\n\n    const mapping: Record<string, ContextType> = {\n      'directive': 'directive',\n      'instruction': 'directive',\n      'command': 'directive',\n      'information': 'information',\n      'info': 'information',\n      'fact': 'information',\n      'heading': 'heading',\n      'section': 'heading',\n      'title': 'heading',\n      'decision': 'decision',\n      'choice': 'decision',\n      'code_pattern': 'code_pattern',\n      'pattern': 'code_pattern',\n      'convention': 'code_pattern',\n      'requirement': 'requirement',\n      'req': 'requirement',\n      'spec': 'requirement',\n      'error': 'error',\n      'bug': 'error',\n      'issue': 'error',\n      'todo': 'todo',\n      'task': 'todo',\n      'insight': 'insight',\n      'realization': 'insight',\n      'learning': 'insight',\n      'preference': 'preference',\n      'pref': 'preference',\n      'setting': 'preference',\n    };\n\n    return mapping[normalized] || 'information';\n  }\n}\n","import { z } from 'zod';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport {\n  ExportMemoriesSchema,\n  ImportMemoriesSchema,\n  FindDuplicatesSchema,\n  ConsolidateMemoriesSchema,\n  type ExportMemories,\n  type ImportMemories,\n  type FindDuplicates,\n  type ConsolidateMemories,\n  type MemoryEntry,\n  type DuplicateGroup,\n  type CreateMemory,\n} from '../types.js';\nimport { cosineSimilarity } from '../embeddings/generator.js';\n\n/**\n * Export memories to JSON format\n */\nexport async function exportMemories(\n  args: ExportMemories,\n  workspacePath?: string\n): Promise<{ content: Array<{ type: string; text: string }> }> {\n  const store = new MemoryStore(workspacePath);\n\n  // Get all memories or filtered subset\n  let memories: MemoryEntry[];\n\n  if (args.filter_by_type && args.filter_by_type.length > 0) {\n    // Get memories by types\n    const memoriesByType: MemoryEntry[] = [];\n    for (const type of args.filter_by_type) {\n      const typeMemories = await store.getMemoriesByType(type);\n      memoriesByType.push(...typeMemories);\n    }\n    // Deduplicate by ID\n    const uniqueMap = new Map<string, MemoryEntry>();\n    for (const memory of memoriesByType) {\n      uniqueMap.set(memory.id, memory);\n    }\n    memories = Array.from(uniqueMap.values());\n  } else {\n    // Get all memories via timeline\n    memories = await store.getRecentMemories(10000); // Large limit to get all\n  }\n\n  // Filter by importance if specified\n  if (args.min_importance !== undefined) {\n    memories = memories.filter(m => m.importance >= args.min_importance!);\n  }\n\n  // Remove embeddings if not requested\n  const exportData = memories.map(memory => {\n    if (!args.include_embeddings) {\n      const { embedding, ...rest } = memory;\n      return rest;\n    }\n    return memory;\n  });\n\n  const exportObject = {\n    version: '1.2.0',\n    exported_at: Date.now(),\n    memory_count: exportData.length,\n    memories: exportData,\n  };\n\n  const jsonString = JSON.stringify(exportObject, null, 2);\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: `Successfully exported ${exportData.length} memories\\n\\n${jsonString}`,\n      },\n    ],\n  };\n}\n\n/**\n * Import memories from JSON export\n */\nexport async function importMemories(\n  args: ImportMemories,\n  workspacePath?: string\n): Promise<{ content: Array<{ type: string; text: string }> }> {\n  const store = new MemoryStore(workspacePath);\n\n  let importData: any;\n  try {\n    importData = JSON.parse(args.data);\n  } catch (error) {\n    throw new Error(`Invalid JSON data: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  if (!importData.memories || !Array.isArray(importData.memories)) {\n    throw new Error('Invalid import format: missing memories array');\n  }\n\n  const results = {\n    imported: 0,\n    skipped: 0,\n    overwritten: 0,\n    errors: [] as string[],\n  };\n\n  for (const memoryData of importData.memories) {\n    try {\n      // Check if memory exists\n      const existing = await store.getMemory(memoryData.id);\n\n      if (existing && !args.overwrite_existing) {\n        results.skipped++;\n        continue;\n      }\n\n      // Prepare memory for creation\n      const createData: CreateMemory = {\n        content: memoryData.content,\n        context_type: memoryData.context_type,\n        tags: memoryData.tags || [],\n        importance: memoryData.importance || 5,\n        summary: memoryData.summary,\n        session_id: memoryData.session_id,\n        ttl_seconds: memoryData.ttl_seconds,\n      };\n\n      // Create or update memory\n      if (existing && args.overwrite_existing) {\n        await store.updateMemory(memoryData.id, createData);\n        results.overwritten++;\n      } else {\n        // For new imports, we'll create with the original ID by directly manipulating\n        // We need to recreate the memory with its original ID\n        // This is a special case for imports\n        const importedMemory: MemoryEntry = {\n          id: memoryData.id,\n          timestamp: memoryData.timestamp || Date.now(),\n          context_type: memoryData.context_type,\n          content: memoryData.content,\n          summary: memoryData.summary,\n          tags: memoryData.tags || [],\n          importance: memoryData.importance || 5,\n          session_id: memoryData.session_id,\n          embedding: args.regenerate_embeddings ? undefined : memoryData.embedding,\n          ttl_seconds: memoryData.ttl_seconds,\n          expires_at: memoryData.expires_at,\n        };\n\n        // If we need to regenerate embeddings, create normally\n        if (args.regenerate_embeddings) {\n          await store.createMemory(createData);\n        } else {\n          // Direct import preserving ID and embedding - we'll need a special method\n          // For now, create normally (this will generate new ID)\n          await store.createMemory(createData);\n        }\n        results.imported++;\n      }\n    } catch (error) {\n      results.errors.push(`Failed to import memory ${memoryData.id}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  const summary = [\n    `Import completed:`,\n    `- Imported: ${results.imported}`,\n    `- Overwritten: ${results.overwritten}`,\n    `- Skipped: ${results.skipped}`,\n    `- Errors: ${results.errors.length}`,\n  ];\n\n  if (results.errors.length > 0) {\n    summary.push('', 'Errors:', ...results.errors.slice(0, 10));\n    if (results.errors.length > 10) {\n      summary.push(`... and ${results.errors.length - 10} more errors`);\n    }\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: summary.join('\\n'),\n      },\n    ],\n  };\n}\n\n/**\n * Find duplicate memories based on similarity\n */\nexport async function findDuplicates(\n  args: FindDuplicates,\n  workspacePath?: string\n): Promise<{ content: Array<{ type: string; text: string }> }> {\n  const store = new MemoryStore(workspacePath);\n\n  // Get all memories\n  const memories = await store.getRecentMemories(10000);\n\n  // Group duplicates\n  const duplicateGroups: DuplicateGroup[] = [];\n  const processed = new Set<string>();\n\n  for (let i = 0; i < memories.length; i++) {\n    const memory1 = memories[i];\n\n    if (processed.has(memory1.id)) {\n      continue;\n    }\n\n    const similarMemories: MemoryEntry[] = [memory1];\n    let maxSimilarity = 0;\n\n    for (let j = i + 1; j < memories.length; j++) {\n      const memory2 = memories[j];\n\n      if (processed.has(memory2.id)) {\n        continue;\n      }\n\n      // Calculate similarity\n      if (memory1.embedding && memory2.embedding) {\n        const similarity = cosineSimilarity(memory1.embedding, memory2.embedding);\n\n        if (similarity >= args.similarity_threshold) {\n          similarMemories.push(memory2);\n          maxSimilarity = Math.max(maxSimilarity, similarity);\n          processed.add(memory2.id);\n        }\n      }\n    }\n\n    // If we found duplicates, add to groups\n    if (similarMemories.length > 1) {\n      duplicateGroups.push({\n        memories: similarMemories,\n        similarity_score: maxSimilarity,\n      });\n      processed.add(memory1.id);\n    }\n  }\n\n  // Auto-merge if requested\n  if (args.auto_merge && duplicateGroups.length > 0) {\n    let mergedCount = 0;\n\n    for (const group of duplicateGroups) {\n      try {\n        // Find memory to keep (highest importance)\n        const toKeep = args.keep_highest_importance\n          ? group.memories.reduce((prev, current) =>\n              current.importance > prev.importance ? current : prev\n            )\n          : group.memories[0];\n\n        // Merge tags from all memories\n        const allTags = new Set<string>();\n        for (const memory of group.memories) {\n          memory.tags.forEach(tag => allTags.add(tag));\n        }\n\n        // Update the memory to keep with merged tags\n        await store.updateMemory(toKeep.id, {\n          tags: Array.from(allTags),\n        });\n\n        // Delete the others\n        for (const memory of group.memories) {\n          if (memory.id !== toKeep.id) {\n            await store.deleteMemory(memory.id);\n            mergedCount++;\n          }\n        }\n      } catch (error) {\n        console.error(`Failed to merge duplicate group: ${error}`);\n      }\n    }\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Found ${duplicateGroups.length} duplicate groups and merged ${mergedCount} duplicate memories.`,\n        },\n      ],\n    };\n  }\n\n  // Just report duplicates\n  if (duplicateGroups.length === 0) {\n    return {\n      content: [\n        {\n          type: 'text',\n          text: 'No duplicate memories found.',\n        },\n      ],\n    };\n  }\n\n  const report = [\n    `Found ${duplicateGroups.length} duplicate groups:\\n`,\n  ];\n\n  for (let i = 0; i < duplicateGroups.length; i++) {\n    const group = duplicateGroups[i];\n    report.push(`Group ${i + 1} (similarity: ${group.similarity_score.toFixed(3)}):`);\n\n    for (const memory of group.memories) {\n      report.push(`  - ID: ${memory.id} | Importance: ${memory.importance} | Summary: ${memory.summary || memory.content.substring(0, 50)}`);\n    }\n    report.push('');\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: report.join('\\n'),\n      },\n    ],\n  };\n}\n\n/**\n * Consolidate multiple memories into one\n */\nexport async function consolidateMemories(\n  args: ConsolidateMemories,\n  workspacePath?: string\n): Promise<{ content: Array<{ type: string; text: string }> }> {\n  const store = new MemoryStore(workspacePath);\n\n  const result = await store.mergeMemories(args.memory_ids, args.keep_id);\n\n  if (!result) {\n    return {\n      content: [\n        {\n          type: 'text',\n          text: 'Failed to consolidate memories. Check that all memory IDs exist.',\n        },\n      ],\n    };\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: `Successfully consolidated ${args.memory_ids.length} memories into ID: ${result.id}\\n\\nMerged Memory:\\n- Content: ${result.summary || result.content.substring(0, 100)}\\n- Tags: ${result.tags.join(', ')}\\n- Importance: ${result.importance}`,\n      },\n    ],\n  };\n}\n\n// Tool definitions for MCP\nexport const exportImportTools = {\n  export_memories: {\n    description: 'Export memories to JSON format with optional filtering',\n    inputSchema: ExportMemoriesSchema,\n    handler: exportMemories,\n  },\n  import_memories: {\n    description: 'Import memories from JSON export data',\n    inputSchema: ImportMemoriesSchema,\n    handler: importMemories,\n  },\n  find_duplicates: {\n    description: 'Find and optionally merge duplicate memories based on similarity',\n    inputSchema: FindDuplicatesSchema,\n    handler: findDuplicates,\n  },\n  consolidate_memories: {\n    description: 'Manually consolidate multiple memories into one',\n    inputSchema: ConsolidateMemoriesSchema,\n    handler: consolidateMemories,\n  },\n};\n","export const ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nexport const jsonDescription = (jsonSchema, def) => {\n    if (def.description) {\n        try {\n            return {\n                ...jsonSchema,\n                ...JSON.parse(def.description),\n            };\n        }\n        catch { }\n    }\n    return jsonSchema;\n};\nexport const defaultOptions = {\n    name: undefined,\n    $refStrategy: \"root\",\n    basePath: [\"#\"],\n    effectStrategy: \"input\",\n    pipeStrategy: \"all\",\n    dateStrategy: \"format:date-time\",\n    mapStrategy: \"entries\",\n    removeAdditionalStrategy: \"passthrough\",\n    allowedAdditionalProperties: true,\n    rejectedAdditionalProperties: false,\n    definitionPath: \"definitions\",\n    target: \"jsonSchema7\",\n    strictUnions: false,\n    definitions: {},\n    errorMessages: false,\n    markdownDescription: false,\n    patternStrategy: \"escape\",\n    applyRegexFlags: false,\n    emailStrategy: \"format:email\",\n    base64Strategy: \"contentEncoding:base64\",\n    nameStrategy: \"ref\",\n    openAiAnyTypeName: \"OpenAiAnyType\"\n};\nexport const getDefaultOptions = (options) => (typeof options === \"string\"\n    ? {\n        ...defaultOptions,\n        name: options,\n    }\n    : {\n        ...defaultOptions,\n        ...options,\n    });\n","import { getDefaultOptions } from \"./Options.js\";\nexport const getRefs = (options) => {\n    const _options = getDefaultOptions(options);\n    const currentPath = _options.name !== undefined\n        ? [..._options.basePath, _options.definitionPath, _options.name]\n        : _options.basePath;\n    return {\n        ..._options,\n        flags: { hasReferencedOpenAiAnyType: false },\n        currentPath: currentPath,\n        propertyPath: undefined,\n        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n            def._def,\n            {\n                def: def._def,\n                path: [..._options.basePath, _options.definitionPath, name],\n                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n                jsonSchema: undefined,\n            },\n        ])),\n    };\n};\n","export function addErrorMessage(res, key, errorMessage, refs) {\n    if (!refs?.errorMessages)\n        return;\n    if (errorMessage) {\n        res.errorMessage = {\n            ...res.errorMessage,\n            [key]: errorMessage,\n        };\n    }\n}\nexport function setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n    res[key] = value;\n    addErrorMessage(res, key, errorMessage, refs);\n}\n","export const getRelativePath = (pathA, pathB) => {\n    let i = 0;\n    for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i])\n            break;\n    }\n    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\n","import { ZodFirstPartyTypeKind } from \"zod\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nimport { parseArrayDef } from \"./parsers/array.js\";\nimport { parseBigintDef } from \"./parsers/bigint.js\";\nimport { parseBooleanDef } from \"./parsers/boolean.js\";\nimport { parseBrandedDef } from \"./parsers/branded.js\";\nimport { parseCatchDef } from \"./parsers/catch.js\";\nimport { parseDateDef } from \"./parsers/date.js\";\nimport { parseDefaultDef } from \"./parsers/default.js\";\nimport { parseEffectsDef } from \"./parsers/effects.js\";\nimport { parseEnumDef } from \"./parsers/enum.js\";\nimport { parseIntersectionDef } from \"./parsers/intersection.js\";\nimport { parseLiteralDef } from \"./parsers/literal.js\";\nimport { parseMapDef } from \"./parsers/map.js\";\nimport { parseNativeEnumDef } from \"./parsers/nativeEnum.js\";\nimport { parseNeverDef } from \"./parsers/never.js\";\nimport { parseNullDef } from \"./parsers/null.js\";\nimport { parseNullableDef } from \"./parsers/nullable.js\";\nimport { parseNumberDef } from \"./parsers/number.js\";\nimport { parseObjectDef } from \"./parsers/object.js\";\nimport { parseOptionalDef } from \"./parsers/optional.js\";\nimport { parsePipelineDef } from \"./parsers/pipeline.js\";\nimport { parsePromiseDef } from \"./parsers/promise.js\";\nimport { parseRecordDef } from \"./parsers/record.js\";\nimport { parseSetDef } from \"./parsers/set.js\";\nimport { parseStringDef } from \"./parsers/string.js\";\nimport { parseTupleDef } from \"./parsers/tuple.js\";\nimport { parseUndefinedDef } from \"./parsers/undefined.js\";\nimport { parseUnionDef } from \"./parsers/union.js\";\nimport { parseUnknownDef } from \"./parsers/unknown.js\";\nimport { parseReadonlyDef } from \"./parsers/readonly.js\";\nexport const selectParser = (def, typeName, refs) => {\n    switch (typeName) {\n        case ZodFirstPartyTypeKind.ZodString:\n            return parseStringDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNumber:\n            return parseNumberDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodObject:\n            return parseObjectDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBigInt:\n            return parseBigintDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBoolean:\n            return parseBooleanDef();\n        case ZodFirstPartyTypeKind.ZodDate:\n            return parseDateDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUndefined:\n            return parseUndefinedDef(refs);\n        case ZodFirstPartyTypeKind.ZodNull:\n            return parseNullDef(refs);\n        case ZodFirstPartyTypeKind.ZodArray:\n            return parseArrayDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUnion:\n        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n            return parseUnionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodIntersection:\n            return parseIntersectionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodTuple:\n            return parseTupleDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodRecord:\n            return parseRecordDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLiteral:\n            return parseLiteralDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodEnum:\n            return parseEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNativeEnum:\n            return parseNativeEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNullable:\n            return parseNullableDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodOptional:\n            return parseOptionalDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodMap:\n            return parseMapDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodSet:\n            return parseSetDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLazy:\n            return () => def.getter()._def;\n        case ZodFirstPartyTypeKind.ZodPromise:\n            return parsePromiseDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNaN:\n        case ZodFirstPartyTypeKind.ZodNever:\n            return parseNeverDef(refs);\n        case ZodFirstPartyTypeKind.ZodEffects:\n            return parseEffectsDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodAny:\n            return parseAnyDef(refs);\n        case ZodFirstPartyTypeKind.ZodUnknown:\n            return parseUnknownDef(refs);\n        case ZodFirstPartyTypeKind.ZodDefault:\n            return parseDefaultDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBranded:\n            return parseBrandedDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodReadonly:\n            return parseReadonlyDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodCatch:\n            return parseCatchDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodPipeline:\n            return parsePipelineDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodFunction:\n        case ZodFirstPartyTypeKind.ZodVoid:\n        case ZodFirstPartyTypeKind.ZodSymbol:\n            return undefined;\n        default:\n            /* c8 ignore next */\n            return ((_) => undefined)(typeName);\n    }\n};\n","import { getRelativePath } from \"../getRelativePath.js\";\nexport function parseAnyDef(refs) {\n    if (refs.target !== \"openAi\") {\n        return {};\n    }\n    const anyDefinitionPath = [\n        ...refs.basePath,\n        refs.definitionPath,\n        refs.openAiAnyTypeName,\n    ];\n    refs.flags.hasReferencedOpenAiAnyType = true;\n    return {\n        $ref: refs.$refStrategy === \"relative\"\n            ? getRelativePath(anyDefinitionPath, refs.currentPath)\n            : anyDefinitionPath.join(\"/\"),\n    };\n}\n","import { ZodFirstPartyTypeKind } from \"zod\";\nimport { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseArrayDef(def, refs) {\n    const res = {\n        type: \"array\",\n    };\n    if (def.type?._def &&\n        def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n        res.items = parseDef(def.type._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\"],\n        });\n    }\n    if (def.minLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n    }\n    if (def.maxLength) {\n        setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n    }\n    if (def.exactLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n        setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n    }\n    return res;\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseBigintDef(def, refs) {\n    const res = {\n        type: \"integer\",\n        format: \"int64\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","export function parseBooleanDef() {\n    return {\n        type: \"boolean\",\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseBrandedDef(_def, refs) {\n    return parseDef(_def.type._def, refs);\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseCatchDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseDateDef(def, refs, overrideDateStrategy) {\n    const strategy = overrideDateStrategy ?? refs.dateStrategy;\n    if (Array.isArray(strategy)) {\n        return {\n            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n        };\n    }\n    switch (strategy) {\n        case \"string\":\n        case \"format:date-time\":\n            return {\n                type: \"string\",\n                format: \"date-time\",\n            };\n        case \"format:date\":\n            return {\n                type: \"string\",\n                format: \"date\",\n            };\n        case \"integer\":\n            return integerDateParser(def, refs);\n    }\n}\nconst integerDateParser = (def, refs) => {\n    const res = {\n        type: \"integer\",\n        format: \"unix-time\",\n    };\n    if (refs.target === \"openApi3\") {\n        return res;\n    }\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                setResponseValueAndErrors(res, \"minimum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n            case \"max\":\n                setResponseValueAndErrors(res, \"maximum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n        }\n    }\n    return res;\n};\n","import { parseDef } from \"../parseDef.js\";\nexport function parseDefaultDef(_def, refs) {\n    return {\n        ...parseDef(_def.innerType._def, refs),\n        default: _def.defaultValue(),\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseEffectsDef(_def, refs) {\n    return refs.effectStrategy === \"input\"\n        ? parseDef(_def.schema._def, refs)\n        : parseAnyDef(refs);\n}\n","export function parseEnumDef(def) {\n    return {\n        type: \"string\",\n        enum: Array.from(def.values),\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = (type) => {\n    if (\"type\" in type && type.type === \"string\")\n        return false;\n    return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n    const allOf = [\n        parseDef(def.left._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n        }),\n        parseDef(def.right._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n        }),\n    ].filter((x) => !!x);\n    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n        ? { unevaluatedProperties: false }\n        : undefined;\n    const mergedAllOf = [];\n    // If either of the schemas is an allOf, merge them into a single allOf\n    allOf.forEach((schema) => {\n        if (isJsonSchema7AllOfType(schema)) {\n            mergedAllOf.push(...schema.allOf);\n            if (schema.unevaluatedProperties === undefined) {\n                // If one of the schemas has no unevaluatedProperties set,\n                // the merged schema should also have no unevaluatedProperties set\n                unevaluatedProperties = undefined;\n            }\n        }\n        else {\n            let nestedSchema = schema;\n            if (\"additionalProperties\" in schema &&\n                schema.additionalProperties === false) {\n                const { additionalProperties, ...rest } = schema;\n                nestedSchema = rest;\n            }\n            else {\n                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n                unevaluatedProperties = undefined;\n            }\n            mergedAllOf.push(nestedSchema);\n        }\n    });\n    return mergedAllOf.length\n        ? {\n            allOf: mergedAllOf,\n            ...unevaluatedProperties,\n        }\n        : undefined;\n}\n","export function parseLiteralDef(def, refs) {\n    const parsedType = typeof def.value;\n    if (parsedType !== \"bigint\" &&\n        parsedType !== \"number\" &&\n        parsedType !== \"boolean\" &&\n        parsedType !== \"string\") {\n        return {\n            type: Array.isArray(def.value) ? \"array\" : \"object\",\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        return {\n            type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n            enum: [def.value],\n        };\n    }\n    return {\n        type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n        const: def.value,\n    };\n}\n","import { ZodFirstPartyTypeKind, } from \"zod\";\nimport { parseDef } from \"../parseDef.js\";\nimport { parseStringDef } from \"./string.js\";\nimport { parseBrandedDef } from \"./branded.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseRecordDef(def, refs) {\n    if (refs.target === \"openAi\") {\n        console.warn(\"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.\");\n    }\n    if (refs.target === \"openApi3\" &&\n        def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            type: \"object\",\n            required: def.keyType._def.values,\n            properties: def.keyType._def.values.reduce((acc, key) => ({\n                ...acc,\n                [key]: parseDef(def.valueType._def, {\n                    ...refs,\n                    currentPath: [...refs.currentPath, \"properties\", key],\n                }) ?? parseAnyDef(refs),\n            }), {}),\n            additionalProperties: refs.rejectedAdditionalProperties,\n        };\n    }\n    const schema = {\n        type: \"object\",\n        additionalProperties: parseDef(def.valueType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        }) ?? refs.allowedAdditionalProperties,\n    };\n    if (refs.target === \"openApi3\") {\n        return schema;\n    }\n    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.checks?.length) {\n        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            ...schema,\n            propertyNames: {\n                enum: def.keyType._def.values,\n            },\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&\n        def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.type._def.checks?.length) {\n        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    return schema;\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex = undefined;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: /^[cC][^\\s-]{8,}$/,\n    cuid2: /^[0-9a-z]+$/,\n    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    emoji: () => {\n        if (emojiRegex === undefined) {\n            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n        }\n        return emojiRegex;\n    },\n    /**\n     * Unused\n     */\n    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n    /**\n     * Unused\n     */\n    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n    /**\n     * Unused\n     */\n    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n    jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"date\":\n                    addFormat(res, \"date\", check.message, refs);\n                    break;\n                case \"time\":\n                    addFormat(res, \"time\", check.message, refs);\n                    break;\n                case \"duration\":\n                    addFormat(res, \"duration\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"base64url\":\n                    addPattern(res, zodPatterns.base64url, check.message, refs);\n                    break;\n                case \"jwt\":\n                    addPattern(res, zodPatterns.jwt, check.message, refs);\n                    break;\n                case \"cidr\": {\n                    if (check.version !== \"v6\") {\n                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji(), check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"base64\": {\n                    switch (refs.base64Strategy) {\n                        case \"format:binary\": {\n                            addFormat(res, \"binary\", check.message, refs);\n                            break;\n                        }\n                        case \"contentEncoding:base64\": {\n                            setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                            break;\n                        }\n                        case \"pattern:zod\": {\n                            addPattern(res, zodPatterns.base64, check.message, refs);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case \"nanoid\": {\n                    addPattern(res, zodPatterns.nanoid, check.message, refs);\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    break;\n                default:\n                    /* c8 ignore next */\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n    return refs.patternStrategy === \"escape\"\n        ? escapeNonAlphaNumeric(literal)\n        : literal;\n}\nconst ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n    let result = \"\";\n    for (let i = 0; i < source.length; i++) {\n        if (!ALPHA_NUMERIC.has(source[i])) {\n            result += \"\\\\\";\n        }\n        result += source[i];\n    }\n    return result;\n}\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(schema, value, message, refs) {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n}\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(schema, regex, message, refs) {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: stringifyRegExpWithFlags(regex, refs),\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n    }\n}\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex, refs) {\n    if (!refs.applyRegexFlags || !regex.flags) {\n        return regex.source;\n    }\n    // Currently handled flags\n    const flags = {\n        i: regex.flags.includes(\"i\"),\n        m: regex.flags.includes(\"m\"),\n        s: regex.flags.includes(\"s\"), // `.` matches newlines\n    };\n    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n    let pattern = \"\";\n    let isEscaped = false;\n    let inCharGroup = false;\n    let inCharRange = false;\n    for (let i = 0; i < source.length; i++) {\n        if (isEscaped) {\n            pattern += source[i];\n            isEscaped = false;\n            continue;\n        }\n        if (flags.i) {\n            if (inCharGroup) {\n                if (source[i].match(/[a-z]/)) {\n                    if (inCharRange) {\n                        pattern += source[i];\n                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n                        inCharRange = false;\n                    }\n                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n                        pattern += source[i];\n                        inCharRange = true;\n                    }\n                    else {\n                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n                    }\n                    continue;\n                }\n            }\n            else if (source[i].match(/[a-z]/)) {\n                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n                continue;\n            }\n        }\n        if (flags.m) {\n            if (source[i] === \"^\") {\n                pattern += `(^|(?<=[\\r\\n]))`;\n                continue;\n            }\n            else if (source[i] === \"$\") {\n                pattern += `($|(?=[\\r\\n]))`;\n                continue;\n            }\n        }\n        if (flags.s && source[i] === \".\") {\n            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n            continue;\n        }\n        pattern += source[i];\n        if (source[i] === \"\\\\\") {\n            isEscaped = true;\n        }\n        else if (inCharGroup && source[i] === \"]\") {\n            inCharGroup = false;\n        }\n        else if (!inCharGroup && source[i] === \"[\") {\n            inCharGroup = true;\n        }\n    }\n    try {\n        new RegExp(pattern);\n    }\n    catch {\n        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n        return regex.source;\n    }\n    return pattern;\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseRecordDef } from \"./record.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseMapDef(def, refs) {\n    if (refs.mapStrategy === \"record\") {\n        return parseRecordDef(def, refs);\n    }\n    const keys = parseDef(def.keyType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"],\n    }) || parseAnyDef(refs);\n    const values = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"],\n    }) || parseAnyDef(refs);\n    return {\n        type: \"array\",\n        maxItems: 125,\n        items: {\n            type: \"array\",\n            items: [keys, values],\n            minItems: 2,\n            maxItems: 2,\n        },\n    };\n}\n","export function parseNativeEnumDef(def) {\n    const object = def.values;\n    const actualKeys = Object.keys(def.values).filter((key) => {\n        return typeof object[object[key]] !== \"number\";\n    });\n    const actualValues = actualKeys.map((key) => object[key]);\n    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n    return {\n        type: parsedTypes.length === 1\n            ? parsedTypes[0] === \"string\"\n                ? \"string\"\n                : \"number\"\n            : [\"string\", \"number\"],\n        enum: actualValues,\n    };\n}\n","import { parseAnyDef } from \"./any.js\";\nexport function parseNeverDef(refs) {\n    return refs.target === \"openAi\"\n        ? undefined\n        : {\n            not: parseAnyDef({\n                ...refs,\n                currentPath: [...refs.currentPath, \"not\"],\n            }),\n        };\n}\n","export function parseNullDef(refs) {\n    return refs.target === \"openApi3\"\n        ? {\n            enum: [\"null\"],\n            nullable: true,\n        }\n        : {\n            type: \"null\",\n        };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nexport function parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n    }))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n","import { parseDef } from \"../parseDef.js\";\nimport { primitiveMappings } from \"./union.js\";\nexport function parseNullableDef(def, refs) {\n    if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) &&\n        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n        if (refs.target === \"openApi3\") {\n            return {\n                type: primitiveMappings[def.innerType._def.typeName],\n                nullable: true,\n            };\n        }\n        return {\n            type: [\n                primitiveMappings[def.innerType._def.typeName],\n                \"null\",\n            ],\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        const base = parseDef(def.innerType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath],\n        });\n        if (base && \"$ref\" in base)\n            return { allOf: [base], nullable: true };\n        return base && { ...base, nullable: true };\n    }\n    const base = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n    });\n    return base && { anyOf: [base, { type: \"null\" }] };\n}\n","import { addErrorMessage, setResponseValueAndErrors, } from \"../errorMessages.js\";\nexport function parseNumberDef(def, refs) {\n    const res = {\n        type: \"number\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"int\":\n                res.type = \"integer\";\n                addErrorMessage(res, \"type\", check.message, refs);\n                break;\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseObjectDef(def, refs) {\n    const forceOptionalIntoNullable = refs.target === \"openAi\";\n    const result = {\n        type: \"object\",\n        properties: {},\n    };\n    const required = [];\n    const shape = def.shape();\n    for (const propName in shape) {\n        let propDef = shape[propName];\n        if (propDef === undefined || propDef._def === undefined) {\n            continue;\n        }\n        let propOptional = safeIsOptional(propDef);\n        if (propOptional && forceOptionalIntoNullable) {\n            if (propDef._def.typeName === \"ZodOptional\") {\n                propDef = propDef._def.innerType;\n            }\n            if (!propDef.isNullable()) {\n                propDef = propDef.nullable();\n            }\n            propOptional = false;\n        }\n        const parsedDef = parseDef(propDef._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"properties\", propName],\n            propertyPath: [...refs.currentPath, \"properties\", propName],\n        });\n        if (parsedDef === undefined) {\n            continue;\n        }\n        result.properties[propName] = parsedDef;\n        if (!propOptional) {\n            required.push(propName);\n        }\n    }\n    if (required.length) {\n        result.required = required;\n    }\n    const additionalProperties = decideAdditionalProperties(def, refs);\n    if (additionalProperties !== undefined) {\n        result.additionalProperties = additionalProperties;\n    }\n    return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n    if (def.catchall._def.typeName !== \"ZodNever\") {\n        return parseDef(def.catchall._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        });\n    }\n    switch (def.unknownKeys) {\n        case \"passthrough\":\n            return refs.allowedAdditionalProperties;\n        case \"strict\":\n            return refs.rejectedAdditionalProperties;\n        case \"strip\":\n            return refs.removeAdditionalStrategy === \"strict\"\n                ? refs.allowedAdditionalProperties\n                : refs.rejectedAdditionalProperties;\n    }\n}\nfunction safeIsOptional(schema) {\n    try {\n        return schema.isOptional();\n    }\n    catch {\n        return true;\n    }\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport const parseOptionalDef = (def, refs) => {\n    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n        return parseDef(def.innerType._def, refs);\n    }\n    const innerSchema = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n    });\n    return innerSchema\n        ? {\n            anyOf: [\n                {\n                    not: parseAnyDef(refs),\n                },\n                innerSchema,\n            ],\n        }\n        : parseAnyDef(refs);\n};\n","import { parseDef } from \"../parseDef.js\";\nexport const parsePipelineDef = (def, refs) => {\n    if (refs.pipeStrategy === \"input\") {\n        return parseDef(def.in._def, refs);\n    }\n    else if (refs.pipeStrategy === \"output\") {\n        return parseDef(def.out._def, refs);\n    }\n    const a = parseDef(def.in._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    });\n    const b = parseDef(def.out._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n    });\n    return {\n        allOf: [a, b].filter((x) => x !== undefined),\n    };\n};\n","import { parseDef } from \"../parseDef.js\";\nexport function parsePromiseDef(def, refs) {\n    return parseDef(def.type._def, refs);\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseSetDef(def, refs) {\n    const items = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\"],\n    });\n    const schema = {\n        type: \"array\",\n        uniqueItems: true,\n        items,\n    };\n    if (def.minSize) {\n        setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n    }\n    if (def.maxSize) {\n        setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n    }\n    return schema;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseTupleDef(def, refs) {\n    if (def.rest) {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n            additionalItems: parseDef(def.rest._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalItems\"],\n            }),\n        };\n    }\n    else {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            maxItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n        };\n    }\n}\n","import { parseAnyDef } from \"./any.js\";\nexport function parseUndefinedDef(refs) {\n    return {\n        not: parseAnyDef(refs),\n    };\n}\n","import { parseAnyDef } from \"./any.js\";\nexport function parseUnknownDef(refs) {\n    return parseAnyDef(refs);\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseReadonlyDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n","import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nimport { getRelativePath } from \"./getRelativePath.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== ignoreOverride) {\n            return overrideResult;\n        }\n    }\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n    const jsonSchema = typeof jsonSchemaOrGetter === \"function\"\n        ? parseDef(jsonSchemaOrGetter(), refs)\n        : jsonSchemaOrGetter;\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    if (refs.postProcess) {\n        const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n        newItem.jsonSchema = jsonSchema;\n        return postProcessResult;\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return parseAnyDef(refs);\n            }\n            return refs.$refStrategy === \"seen\" ? parseAnyDef(refs) : undefined;\n        }\n    }\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n","import { parseDef } from \"./parseDef.js\";\nimport { getRefs } from \"./Refs.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nconst zodToJsonSchema = (schema, options) => {\n    const refs = getRefs(options);\n    let definitions = typeof options === \"object\" && options.definitions\n        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({\n            ...acc,\n            [name]: parseDef(schema._def, {\n                ...refs,\n                currentPath: [...refs.basePath, refs.definitionPath, name],\n            }, true) ?? parseAnyDef(refs),\n        }), {})\n        : undefined;\n    const name = typeof options === \"string\"\n        ? options\n        : options?.nameStrategy === \"title\"\n            ? undefined\n            : options?.name;\n    const main = parseDef(schema._def, name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n        }, false) ?? parseAnyDef(refs);\n    const title = typeof options === \"object\" &&\n        options.name !== undefined &&\n        options.nameStrategy === \"title\"\n        ? options.name\n        : undefined;\n    if (title !== undefined) {\n        main.title = title;\n    }\n    if (refs.flags.hasReferencedOpenAiAnyType) {\n        if (!definitions) {\n            definitions = {};\n        }\n        if (!definitions[refs.openAiAnyTypeName]) {\n            definitions[refs.openAiAnyTypeName] = {\n                // Skipping \"object\" as no properties can be defined and additionalProperties must be \"false\"\n                type: [\"string\", \"number\", \"integer\", \"boolean\", \"array\", \"null\"],\n                items: {\n                    $ref: refs.$refStrategy === \"relative\"\n                        ? \"1\"\n                        : [\n                            ...refs.basePath,\n                            refs.definitionPath,\n                            refs.openAiAnyTypeName,\n                        ].join(\"/\"),\n                },\n            };\n        }\n    }\n    const combined = name === undefined\n        ? definitions\n            ? {\n                ...main,\n                [refs.definitionPath]: definitions,\n            }\n            : main\n        : {\n            $ref: [\n                ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n                refs.definitionPath,\n                name,\n            ].join(\"/\"),\n            [refs.definitionPath]: {\n                ...definitions,\n                [name]: main,\n            },\n        };\n    if (refs.target === \"jsonSchema7\") {\n        combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n    }\n    else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n        combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n    }\n    if (refs.target === \"openAi\" &&\n        (\"anyOf\" in combined ||\n            \"oneOf\" in combined ||\n            \"allOf\" in combined ||\n            (\"type\" in combined && Array.isArray(combined.type)))) {\n        console.warn(\"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\");\n    }\n    return combined;\n};\nexport { zodToJsonSchema };\n","import { z } from 'zod';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nimport { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport {\n  LinkMemoriesSchema,\n  GetRelatedMemoriesSchema,\n  UnlinkMemoriesSchema,\n  GetMemoryGraphSchema,\n  type LinkMemories,\n  type GetRelatedMemories,\n  type UnlinkMemories,\n  type GetMemoryGraph,\n} from '../types.js';\n\nconst memoryStore = new MemoryStore();\n\nexport const relationshipTools = {\n  link_memories: {\n    description: 'Create a relationship between two memories',\n    inputSchema: zodToJsonSchema(LinkMemoriesSchema),\n    handler: async (args: z.infer<typeof LinkMemoriesSchema>) => {\n      try {\n        const relationship = await memoryStore.createRelationship(\n          args.from_memory_id,\n          args.to_memory_id,\n          args.relationship_type,\n          args.metadata\n        );\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              relationship_id: relationship.id,\n              from_memory_id: relationship.from_memory_id,\n              to_memory_id: relationship.to_memory_id,\n              relationship_type: relationship.relationship_type,\n              created_at: relationship.created_at,\n              message: `Successfully linked memories with ${relationship.relationship_type} relationship`,\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to link memories: ${errorMessage}`);\n      }\n    },\n  },\n\n  get_related_memories: {\n    description: 'Get memories related to a given memory with graph traversal',\n    inputSchema: zodToJsonSchema(GetRelatedMemoriesSchema),\n    handler: async (args: z.infer<typeof GetRelatedMemoriesSchema>) => {\n      try {\n        const results = await memoryStore.getRelatedMemories(args.memory_id, {\n          relationshipTypes: args.relationship_types,\n          depth: args.depth,\n          direction: args.direction,\n        });\n\n        // Format results for display\n        const formatted = results.map(result => ({\n          memory_id: result.memory.id,\n          content: result.memory.content,\n          summary: result.memory.summary,\n          context_type: result.memory.context_type,\n          importance: result.memory.importance,\n          tags: result.memory.tags,\n          is_global: result.memory.is_global,\n          relationship: {\n            id: result.relationship.id,\n            type: result.relationship.relationship_type,\n            from: result.relationship.from_memory_id,\n            to: result.relationship.to_memory_id,\n          },\n          depth: result.depth,\n        }));\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              root_memory_id: args.memory_id,\n              total_related: results.length,\n              max_depth: args.depth,\n              direction: args.direction,\n              related_memories: formatted,\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to get related memories: ${errorMessage}`);\n      }\n    },\n  },\n\n  unlink_memories: {\n    description: 'Remove a relationship between memories',\n    inputSchema: zodToJsonSchema(UnlinkMemoriesSchema),\n    handler: async (args: z.infer<typeof UnlinkMemoriesSchema>) => {\n      try {\n        const deleted = await memoryStore.deleteRelationship(args.relationship_id);\n\n        if (!deleted) {\n          throw new McpError(ErrorCode.InvalidRequest, `Relationship not found: ${args.relationship_id}`);\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              relationship_id: args.relationship_id,\n              message: 'Relationship removed successfully',\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to unlink memories: ${errorMessage}`);\n      }\n    },\n  },\n\n  get_memory_graph: {\n    description: 'Get a graph of related memories starting from a root memory',\n    inputSchema: zodToJsonSchema(GetMemoryGraphSchema),\n    handler: async (args: z.infer<typeof GetMemoryGraphSchema>) => {\n      try {\n        const graph = await memoryStore.getMemoryGraph(\n          args.memory_id,\n          args.max_depth,\n          args.max_nodes\n        );\n\n        // Format graph for display\n        const formattedNodes = Object.fromEntries(\n          Object.entries(graph.nodes).map(([memoryId, node]) => [\n            memoryId,\n            {\n              memory_id: node.memory.id,\n              content: node.memory.content,\n              summary: node.memory.summary,\n              context_type: node.memory.context_type,\n              importance: node.memory.importance,\n              tags: node.memory.tags,\n              is_global: node.memory.is_global,\n              depth: node.depth,\n              relationships: node.relationships.map(rel => ({\n                id: rel.id,\n                type: rel.relationship_type,\n                from: rel.from_memory_id,\n                to: rel.to_memory_id,\n              })),\n            },\n          ])\n        );\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              root_memory_id: graph.root_memory_id,\n              total_nodes: graph.total_nodes,\n              max_depth_reached: graph.max_depth_reached,\n              nodes: formattedNodes,\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to get memory graph: ${errorMessage}`);\n      }\n    },\n  },\n};\n","import { z } from 'zod';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nimport { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport {\n  GetMemoryHistorySchema,\n  RollbackMemorySchema,\n} from '../types.js';\n\nconst memoryStore = new MemoryStore();\n\nexport const versionTools = {\n  get_memory_history: {\n    description: 'Get the version history of a memory',\n    inputSchema: zodToJsonSchema(GetMemoryHistorySchema),\n    handler: async (args: z.infer<typeof GetMemoryHistorySchema>) => {\n      try {\n        const versions = await memoryStore.getMemoryHistory(args.memory_id, args.limit);\n\n        if (versions.length === 0) {\n          return {\n            content: [{\n              type: 'text' as const,\n              text: JSON.stringify({\n                success: true,\n                memory_id: args.memory_id,\n                versions: [],\n                total_versions: 0,\n                message: 'No version history found for this memory',\n              }, null, 2),\n            }],\n          };\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              memory_id: args.memory_id,\n              versions,\n              total_versions: versions.length,\n              oldest_version: versions[versions.length - 1]?.created_at,\n              newest_version: versions[0]?.created_at,\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to get memory history: ${errorMessage}`);\n      }\n    },\n  },\n\n  rollback_memory: {\n    description: 'Rollback a memory to a previous version',\n    inputSchema: zodToJsonSchema(RollbackMemorySchema),\n    handler: async (args: z.infer<typeof RollbackMemorySchema>) => {\n      try {\n        const rolledBackMemory = await memoryStore.rollbackMemory(\n          args.memory_id,\n          args.version_id,\n          args.preserve_relationships\n        );\n\n        if (!rolledBackMemory) {\n          throw new McpError(ErrorCode.InternalError, 'Failed to rollback memory');\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              memory: {\n                id: rolledBackMemory.id,\n                content: rolledBackMemory.content,\n                context_type: rolledBackMemory.context_type,\n                importance: rolledBackMemory.importance,\n                tags: rolledBackMemory.tags,\n                summary: rolledBackMemory.summary,\n                category: rolledBackMemory.category,\n              },\n              rolled_back_to: args.version_id,\n              preserve_relationships: args.preserve_relationships,\n              message: `Successfully rolled back memory to version ${args.version_id}`,\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to rollback memory: ${errorMessage}`);\n      }\n    },\n  },\n};\n","import { z } from 'zod';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nimport { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport {\n  CreateTemplateSchema,\n  CreateFromTemplateSchema,\n} from '../types.js';\n\nconst memoryStore = new MemoryStore();\n\nexport const templateTools = {\n  create_template: {\n    description: 'Create a new memory template with placeholders',\n    inputSchema: zodToJsonSchema(CreateTemplateSchema),\n    handler: async (args: z.infer<typeof CreateTemplateSchema>) => {\n      try {\n        const template = await memoryStore.createTemplate(args);\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              template: {\n                template_id: template.template_id,\n                name: template.name,\n                description: template.description,\n                context_type: template.context_type,\n                content_template: template.content_template,\n                default_tags: template.default_tags,\n                default_importance: template.default_importance,\n                created_at: template.created_at,\n              },\n              message: `Successfully created template \"${template.name}\"`,\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to create template: ${errorMessage}`);\n      }\n    },\n  },\n\n  create_from_template: {\n    description: 'Create a new memory from a template by filling in variables',\n    inputSchema: zodToJsonSchema(CreateFromTemplateSchema),\n    handler: async (args: z.infer<typeof CreateFromTemplateSchema>) => {\n      try {\n        const memory = await memoryStore.createFromTemplate(\n          args.template_id,\n          args.variables,\n          args.tags,\n          args.importance,\n          args.is_global\n        );\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              memory: {\n                id: memory.id,\n                content: memory.content,\n                context_type: memory.context_type,\n                importance: memory.importance,\n                tags: memory.tags,\n                summary: memory.summary,\n                category: memory.category,\n                is_global: memory.is_global,\n              },\n              template_id: args.template_id,\n              message: 'Successfully created memory from template',\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to create from template: ${errorMessage}`);\n      }\n    },\n  },\n\n  list_templates: {\n    description: 'List all available memory templates (workspace + builtin)',\n    inputSchema: zodToJsonSchema(z.object({})),\n    handler: async () => {\n      try {\n        const templates = await memoryStore.getAllTemplates();\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              templates: templates.map(t => ({\n                template_id: t.template_id,\n                name: t.name,\n                description: t.description,\n                context_type: t.context_type,\n                content_template: t.content_template,\n                default_tags: t.default_tags,\n                default_importance: t.default_importance,\n                is_builtin: t.is_builtin,\n                created_at: t.created_at,\n              })),\n              total: templates.length,\n              builtin_count: templates.filter(t => t.is_builtin).length,\n              workspace_count: templates.filter(t => !t.is_builtin).length,\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to list templates: ${errorMessage}`);\n      }\n    },\n  },\n};\n","import { z } from 'zod';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nimport { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport {\n  SetMemoryCategorySchema,\n  ListCategoriesSchema,\n} from '../types.js';\n\nconst memoryStore = new MemoryStore();\n\nexport const categoryTools = {\n  set_memory_category: {\n    description: 'Set or update the category of a memory',\n    inputSchema: zodToJsonSchema(SetMemoryCategorySchema),\n    handler: async (args: z.infer<typeof SetMemoryCategorySchema>) => {\n      try {\n        const memory = await memoryStore.setMemoryCategory(args.memory_id, args.category);\n\n        if (!memory) {\n          throw new McpError(ErrorCode.InvalidRequest, 'Memory not found');\n        }\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              memory: {\n                id: memory.id,\n                category: memory.category,\n                content: memory.content.substring(0, 100) + '...',\n              },\n              message: `Successfully set category to \"${args.category}\"`,\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to set category: ${errorMessage}`);\n      }\n    },\n  },\n\n  list_categories: {\n    description: 'List all categories with memory counts',\n    inputSchema: zodToJsonSchema(ListCategoriesSchema),\n    handler: async (args: z.infer<typeof ListCategoriesSchema>) => {\n      try {\n        const categories = await memoryStore.getAllCategories();\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              categories: categories.map(c => ({\n                category: c.category,\n                memory_count: args.include_counts ? c.memory_count : undefined,\n                last_used: c.last_used,\n              })),\n              total_categories: categories.length,\n              total_memories: categories.reduce((sum, c) => sum + (c.memory_count || 0), 0),\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to list categories: ${errorMessage}`);\n      }\n    },\n  },\n\n  get_memories_by_category: {\n    description: 'Get all memories in a specific category',\n    inputSchema: zodToJsonSchema(z.object({\n      category: z.string().describe('Category name'),\n      limit: z.number().min(1).max(100).default(50).describe('Maximum memories to return'),\n    })),\n    handler: async (args: { category: string; limit: number }) => {\n      try {\n        const memories = await memoryStore.getMemoriesByCategory(args.category);\n        const limited = memories.slice(0, args.limit);\n\n        return {\n          content: [{\n            type: 'text' as const,\n            text: JSON.stringify({\n              success: true,\n              category: args.category,\n              memories: limited.map(m => ({\n                id: m.id,\n                content: m.content.substring(0, 100) + (m.content.length > 100 ? '...' : ''),\n                context_type: m.context_type,\n                importance: m.importance,\n                tags: m.tags,\n                summary: m.summary,\n                is_global: m.is_global,\n              })),\n              total_in_category: memories.length,\n              returned: limited.length,\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        if (error instanceof McpError) throw error;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        throw new McpError(ErrorCode.InternalError, `Failed to get memories by category: ${errorMessage}`);\n      }\n    },\n  },\n};\n","import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';\nimport { MemoryStore } from '../redis/memory-store.js';\nimport type { ContextType } from '../types.js';\nimport { getAnalytics } from './analytics.js';\nimport { getWorkspaceMode, WorkspaceMode, RedisKeys } from '../types.js';\nimport { getRedisClient } from '../redis/client.js';\n\nconst memoryStore = new MemoryStore();\nconst redis = getRedisClient();\n\nexport const resources = {\n  'memory://recent': {\n    name: 'Recent Memories',\n    description: 'Get the most recent memories (default: 50)',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const limit = parseInt(uri.searchParams.get('limit') || '50', 10);\n      const memories = await memoryStore.getRecentMemories(limit);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                count: memories.length,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  context_type: m.context_type,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                  session_id: m.session_id,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://by-type/{type}': {\n    name: 'Memories by Type',\n    description: 'Get memories filtered by context type',\n    mimeType: 'application/json',\n    handler: async (uri: URL, params: { type: string }) => {\n      const type = params.type as ContextType;\n      const limit = uri.searchParams.get('limit') ? parseInt(uri.searchParams.get('limit')!, 10) : undefined;\n\n      const memories = await memoryStore.getMemoriesByType(type, limit);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                context_type: type,\n                count: memories.length,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://by-tag/{tag}': {\n    name: 'Memories by Tag',\n    description: 'Get memories filtered by tag',\n    mimeType: 'application/json',\n    handler: async (uri: URL, params: { tag: string }) => {\n      const { tag } = params;\n      const limit = uri.searchParams.get('limit') ? parseInt(uri.searchParams.get('limit')!, 10) : undefined;\n\n      const memories = await memoryStore.getMemoriesByTag(tag, limit);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                tag,\n                count: memories.length,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  context_type: m.context_type,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://important': {\n    name: 'Important Memories',\n    description: 'Get high-importance memories (importance >= 8)',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const minImportance = parseInt(uri.searchParams.get('min') || '8', 10);\n      const limit = uri.searchParams.get('limit') ? parseInt(uri.searchParams.get('limit')!, 10) : undefined;\n\n      const memories = await memoryStore.getImportantMemories(minImportance, limit);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                min_importance: minImportance,\n                count: memories.length,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  context_type: m.context_type,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://session/{session_id}': {\n    name: 'Session Memories',\n    description: 'Get all memories in a specific session',\n    mimeType: 'application/json',\n    handler: async (uri: URL, params: { session_id: string }) => {\n      const { session_id } = params;\n      const session = await memoryStore.getSession(session_id);\n\n      if (!session) {\n        throw new McpError(ErrorCode.InvalidRequest, `Session ${session_id} not found`);\n      }\n\n      const memories = await memoryStore.getSessionMemories(session_id);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                session_id: session.session_id,\n                session_name: session.session_name,\n                created_at: session.created_at,\n                summary: session.summary,\n                count: memories.length,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  context_type: m.context_type,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://sessions': {\n    name: 'All Sessions',\n    description: 'Get list of all sessions',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const sessions = await memoryStore.getAllSessions();\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                count: sessions.length,\n                sessions: sessions.map(s => ({\n                  session_id: s.session_id,\n                  session_name: s.session_name,\n                  created_at: s.created_at,\n                  memory_count: s.memory_count,\n                  summary: s.summary,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://summary': {\n    name: 'Memory Summary',\n    description: 'Get overall summary statistics of stored memories',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const stats = await memoryStore.getSummaryStats();\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(stats, null, 2),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://search': {\n    name: 'Search Memories',\n    description: 'Search memories using semantic similarity',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const query = uri.searchParams.get('q');\n      if (!query) {\n        throw new McpError(ErrorCode.InvalidRequest, 'Query parameter \"q\" is required');\n      }\n\n      const limit = parseInt(uri.searchParams.get('limit') || '10', 10);\n      const minImportance = uri.searchParams.get('min_importance')\n        ? parseInt(uri.searchParams.get('min_importance')!, 10)\n        : undefined;\n\n      const results = await memoryStore.searchMemories(query, limit, minImportance);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                query,\n                count: results.length,\n                results: results.map(r => ({\n                  memory_id: r.id,\n                  content: r.content,\n                  summary: r.summary,\n                  context_type: r.context_type,\n                  importance: r.importance,\n                  tags: r.tags,\n                  similarity: r.similarity,\n                  timestamp: r.timestamp,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://analytics': {\n    name: 'Memory Analytics',\n    description: 'Get detailed analytics about memory usage and trends',\n    mimeType: 'text/markdown',\n    handler: async (uri: URL) => {\n      const analytics = await getAnalytics();\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'text/markdown',\n            text: analytics,\n          },\n        ],\n      };\n    },\n  },\n\n  // Global memory resources (v1.3.0)\n  'memory://global/recent': {\n    name: 'Recent Global Memories',\n    description: 'Get the most recent global memories (cross-workspace)',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const mode = getWorkspaceMode();\n      if (mode === WorkspaceMode.ISOLATED) {\n        throw new McpError(\n          ErrorCode.InvalidRequest,\n          'Global memories are not available in isolated mode. Set WORKSPACE_MODE=hybrid or global to access global memories.'\n        );\n      }\n\n      const limit = parseInt(uri.searchParams.get('limit') || '50', 10);\n      const ids = await redis.zrevrange(RedisKeys.globalTimeline(), 0, limit - 1);\n      const memories = await memoryStore.getMemories(ids);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                count: memories.length,\n                workspace_mode: mode,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  context_type: m.context_type,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                  is_global: m.is_global,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://global/by-type/{type}': {\n    name: 'Global Memories by Type',\n    description: 'Get global memories filtered by context type',\n    mimeType: 'application/json',\n    handler: async (uri: URL, params: { type: string }) => {\n      const mode = getWorkspaceMode();\n      if (mode === WorkspaceMode.ISOLATED) {\n        throw new McpError(\n          ErrorCode.InvalidRequest,\n          'Global memories are not available in isolated mode. Set WORKSPACE_MODE=hybrid or global to access global memories.'\n        );\n      }\n\n      const type = params.type as ContextType;\n      const limit = uri.searchParams.get('limit') ? parseInt(uri.searchParams.get('limit')!, 10) : undefined;\n\n      const ids = await redis.smembers(RedisKeys.globalByType(type));\n      const allMemories = await memoryStore.getMemories(ids);\n\n      // Sort by timestamp descending\n      allMemories.sort((a, b) => b.timestamp - a.timestamp);\n      const memories = limit ? allMemories.slice(0, limit) : allMemories;\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                context_type: type,\n                count: memories.length,\n                workspace_mode: mode,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                  is_global: m.is_global,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://global/by-tag/{tag}': {\n    name: 'Global Memories by Tag',\n    description: 'Get global memories filtered by tag',\n    mimeType: 'application/json',\n    handler: async (uri: URL, params: { tag: string }) => {\n      const mode = getWorkspaceMode();\n      if (mode === WorkspaceMode.ISOLATED) {\n        throw new McpError(\n          ErrorCode.InvalidRequest,\n          'Global memories are not available in isolated mode. Set WORKSPACE_MODE=hybrid or global to access global memories.'\n        );\n      }\n\n      const { tag } = params;\n      const limit = uri.searchParams.get('limit') ? parseInt(uri.searchParams.get('limit')!, 10) : undefined;\n\n      const ids = await redis.smembers(RedisKeys.globalByTag(tag));\n      const allMemories = await memoryStore.getMemories(ids);\n\n      // Sort by timestamp descending\n      allMemories.sort((a, b) => b.timestamp - a.timestamp);\n      const memories = limit ? allMemories.slice(0, limit) : allMemories;\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                tag,\n                count: memories.length,\n                workspace_mode: mode,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  context_type: m.context_type,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                  is_global: m.is_global,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://global/important': {\n    name: 'Important Global Memories',\n    description: 'Get high-importance global memories (importance >= 8)',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const mode = getWorkspaceMode();\n      if (mode === WorkspaceMode.ISOLATED) {\n        throw new McpError(\n          ErrorCode.InvalidRequest,\n          'Global memories are not available in isolated mode. Set WORKSPACE_MODE=hybrid or global to access global memories.'\n        );\n      }\n\n      const minImportance = parseInt(uri.searchParams.get('min') || '8', 10);\n      const limit = uri.searchParams.get('limit') ? parseInt(uri.searchParams.get('limit')!, 10) : undefined;\n\n      const results = await redis.zrevrangebyscore(\n        RedisKeys.globalImportant(),\n        10,\n        minImportance,\n        'LIMIT',\n        0,\n        limit || 100\n      );\n\n      const memories = await memoryStore.getMemories(results);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                min_importance: minImportance,\n                count: memories.length,\n                workspace_mode: mode,\n                memories: memories.map(m => ({\n                  memory_id: m.id,\n                  content: m.content,\n                  summary: m.summary,\n                  context_type: m.context_type,\n                  importance: m.importance,\n                  tags: m.tags,\n                  timestamp: m.timestamp,\n                  is_global: m.is_global,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://global/search': {\n    name: 'Search Global Memories',\n    description: 'Search global memories using semantic similarity',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const mode = getWorkspaceMode();\n      if (mode === WorkspaceMode.ISOLATED) {\n        throw new McpError(\n          ErrorCode.InvalidRequest,\n          'Global memories are not available in isolated mode. Set WORKSPACE_MODE=hybrid or global to access global memories.'\n        );\n      }\n\n      const query = uri.searchParams.get('q');\n      if (!query) {\n        throw new McpError(ErrorCode.InvalidRequest, 'Query parameter \"q\" is required');\n      }\n\n      const limit = parseInt(uri.searchParams.get('limit') || '10', 10);\n\n      // Temporarily switch to global mode for search\n      const originalMode = process.env.WORKSPACE_MODE;\n      process.env.WORKSPACE_MODE = 'global';\n\n      try {\n        const results = await memoryStore.searchMemories(query, limit);\n\n        return {\n          contents: [\n            {\n              uri: uri.toString(),\n              mimeType: 'application/json',\n              text: JSON.stringify(\n                {\n                  query,\n                  count: results.length,\n                  workspace_mode: mode,\n                  results: results.map(r => ({\n                    memory_id: r.id,\n                    content: r.content,\n                    summary: r.summary,\n                    context_type: r.context_type,\n                    importance: r.importance,\n                    tags: r.tags,\n                    similarity: r.similarity,\n                    timestamp: r.timestamp,\n                    is_global: r.is_global,\n                  })),\n                },\n                null,\n                2\n              ),\n            },\n          ],\n        };\n      } finally {\n        // Restore original mode\n        if (originalMode) {\n          process.env.WORKSPACE_MODE = originalMode;\n        } else {\n          delete process.env.WORKSPACE_MODE;\n        }\n      }\n    },\n  },\n\n  // ============================================================================\n  // Relationship Resources (v1.4.0)\n  // ============================================================================\n\n  'memory://relationships': {\n    name: 'All Memory Relationships',\n    description: 'List all memory relationships in the current workspace',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const limit = parseInt(uri.searchParams.get('limit') || '100', 10);\n      const mode = getWorkspaceMode();\n\n      // Get all relationship IDs based on mode\n      let relationshipIds: string[] = [];\n\n      if (mode === WorkspaceMode.ISOLATED || mode === WorkspaceMode.HYBRID) {\n        const workspaceIds = await redis.smembers(RedisKeys.relationships(memoryStore['workspaceId']));\n        relationshipIds.push(...workspaceIds);\n      }\n\n      if (mode === WorkspaceMode.GLOBAL || mode === WorkspaceMode.HYBRID) {\n        const globalIds = await redis.smembers(RedisKeys.globalRelationships());\n        relationshipIds.push(...globalIds);\n      }\n\n      // Limit results\n      relationshipIds = relationshipIds.slice(0, limit);\n\n      // Fetch relationships\n      const relationships = await Promise.all(\n        relationshipIds.map(async id => {\n          const rel = await memoryStore.getRelationship(id);\n          return rel;\n        })\n      );\n\n      const validRelationships = relationships.filter((r): r is NonNullable<typeof r> => r !== null);\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                count: validRelationships.length,\n                workspace_mode: mode,\n                relationships: validRelationships.map(r => ({\n                  id: r.id,\n                  from_memory_id: r.from_memory_id,\n                  to_memory_id: r.to_memory_id,\n                  relationship_type: r.relationship_type,\n                  created_at: r.created_at,\n                  metadata: r.metadata,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://memory/{id}/related': {\n    name: 'Related Memories',\n    description: 'Get memories related to a specific memory',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const memoryId = uri.pathname.split('/')[2];\n      if (!memoryId) {\n        throw new McpError(ErrorCode.InvalidRequest, 'Memory ID is required');\n      }\n\n      const depth = parseInt(uri.searchParams.get('depth') || '1', 10);\n      const direction = (uri.searchParams.get('direction') || 'both') as 'outgoing' | 'incoming' | 'both';\n\n      const results = await memoryStore.getRelatedMemories(memoryId, {\n        depth,\n        direction,\n      });\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                root_memory_id: memoryId,\n                total_related: results.length,\n                depth,\n                direction,\n                related_memories: results.map(r => ({\n                  memory_id: r.memory.id,\n                  content: r.memory.content,\n                  summary: r.memory.summary,\n                  context_type: r.memory.context_type,\n                  importance: r.memory.importance,\n                  tags: r.memory.tags,\n                  is_global: r.memory.is_global,\n                  relationship: {\n                    id: r.relationship.id,\n                    type: r.relationship.relationship_type,\n                    from: r.relationship.from_memory_id,\n                    to: r.relationship.to_memory_id,\n                  },\n                  depth: r.depth,\n                })),\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n\n  'memory://graph/{id}': {\n    name: 'Memory Graph',\n    description: 'Get a graph of related memories starting from a root memory',\n    mimeType: 'application/json',\n    handler: async (uri: URL) => {\n      const memoryId = uri.pathname.split('/')[2];\n      if (!memoryId) {\n        throw new McpError(ErrorCode.InvalidRequest, 'Memory ID is required');\n      }\n\n      const maxDepth = parseInt(uri.searchParams.get('depth') || '2', 10);\n      const maxNodes = parseInt(uri.searchParams.get('max_nodes') || '50', 10);\n\n      const graph = await memoryStore.getMemoryGraph(memoryId, maxDepth, maxNodes);\n\n      // Format graph for display\n      const formattedNodes = Object.fromEntries(\n        Object.entries(graph.nodes).map(([nodeId, node]) => [\n          nodeId,\n          {\n            memory_id: node.memory.id,\n            content: node.memory.content,\n            summary: node.memory.summary,\n            context_type: node.memory.context_type,\n            importance: node.memory.importance,\n            tags: node.memory.tags,\n            is_global: node.memory.is_global,\n            depth: node.depth,\n            relationships: node.relationships.map(rel => ({\n              id: rel.id,\n              type: rel.relationship_type,\n              from: rel.from_memory_id,\n              to: rel.to_memory_id,\n            })),\n          },\n        ])\n      );\n\n      return {\n        contents: [\n          {\n            uri: uri.toString(),\n            mimeType: 'application/json',\n            text: JSON.stringify(\n              {\n                root_memory_id: graph.root_memory_id,\n                total_nodes: graph.total_nodes,\n                max_depth_reached: graph.max_depth_reached,\n                nodes: formattedNodes,\n              },\n              null,\n              2\n            ),\n          },\n        ],\n      };\n    },\n  },\n};\n","import { MemoryStore } from '../redis/memory-store.js';\nimport type { MemoryEntry } from '../types.js';\n\nexport interface AnalyticsData {\n  overview: {\n    total_memories: number;\n    by_type: Record<string, number>;\n    total_sessions: number;\n    important_count: number;\n    workspace_path: string;\n  };\n  trends: {\n    memories_last_24h: number;\n    memories_last_7d: number;\n    memories_last_30d: number;\n    most_active_types_24h: Array<{ type: string; count: number }>;\n  };\n  top_tags: Array<{ tag: string; count: number }>;\n  importance_distribution: {\n    critical: number; // 9-10\n    high: number; // 7-8\n    medium: number; // 5-6\n    low: number; // 1-4\n  };\n  recent_activity: Array<{\n    date: string;\n    count: number;\n    types: Record<string, number>;\n  }>;\n}\n\nexport async function getAnalytics(workspacePath?: string): Promise<string> {\n  const store = new MemoryStore(workspacePath);\n\n  // Get summary stats\n  const stats = await store.getSummaryStats();\n\n  // Get recent memories for trend analysis\n  const recentMemories = await store.getRecentMemories(1000);\n\n  // Calculate time-based trends\n  const now = Date.now();\n  const day24h = now - 24 * 60 * 60 * 1000;\n  const day7d = now - 7 * 24 * 60 * 60 * 1000;\n  const day30d = now - 30 * 24 * 60 * 60 * 1000;\n\n  const memories24h = recentMemories.filter(m => m.timestamp >= day24h);\n  const memories7d = recentMemories.filter(m => m.timestamp >= day7d);\n  const memories30d = recentMemories.filter(m => m.timestamp >= day30d);\n\n  // Most active types in last 24h\n  const typeCount24h = new Map<string, number>();\n  for (const memory of memories24h) {\n    typeCount24h.set(memory.context_type, (typeCount24h.get(memory.context_type) || 0) + 1);\n  }\n  const mostActiveTypes24h = Array.from(typeCount24h.entries())\n    .map(([type, count]) => ({ type, count }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 5);\n\n  // Tag frequency\n  const tagCount = new Map<string, number>();\n  for (const memory of recentMemories) {\n    for (const tag of memory.tags) {\n      tagCount.set(tag, (tagCount.get(tag) || 0) + 1);\n    }\n  }\n  const topTags = Array.from(tagCount.entries())\n    .map(([tag, count]) => ({ tag, count }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 10);\n\n  // Importance distribution\n  const importanceDist = {\n    critical: recentMemories.filter(m => m.importance >= 9).length,\n    high: recentMemories.filter(m => m.importance >= 7 && m.importance < 9).length,\n    medium: recentMemories.filter(m => m.importance >= 5 && m.importance < 7).length,\n    low: recentMemories.filter(m => m.importance < 5).length,\n  };\n\n  // Recent activity by day (last 7 days)\n  const activityByDay = new Map<string, { count: number; types: Map<string, number> }>();\n  const last7Days = [];\n  for (let i = 6; i >= 0; i--) {\n    const date = new Date(now - i * 24 * 60 * 60 * 1000);\n    const dateStr = date.toISOString().split('T')[0];\n    last7Days.push(dateStr);\n    activityByDay.set(dateStr, { count: 0, types: new Map() });\n  }\n\n  for (const memory of memories7d) {\n    const dateStr = new Date(memory.timestamp).toISOString().split('T')[0];\n    const activity = activityByDay.get(dateStr);\n    if (activity) {\n      activity.count++;\n      activity.types.set(memory.context_type, (activity.types.get(memory.context_type) || 0) + 1);\n    }\n  }\n\n  const recentActivity = last7Days.map(date => {\n    const activity = activityByDay.get(date)!;\n    return {\n      date,\n      count: activity.count,\n      types: Object.fromEntries(activity.types),\n    };\n  });\n\n  // Build analytics data\n  const analytics: AnalyticsData = {\n    overview: stats,\n    trends: {\n      memories_last_24h: memories24h.length,\n      memories_last_7d: memories7d.length,\n      memories_last_30d: memories30d.length,\n      most_active_types_24h: mostActiveTypes24h,\n    },\n    top_tags: topTags,\n    importance_distribution: importanceDist,\n    recent_activity: recentActivity,\n  };\n\n  // Format as readable text\n  return formatAnalytics(analytics);\n}\n\nfunction formatAnalytics(data: AnalyticsData): string {\n  const lines = [\n    '# Memory Analytics Dashboard',\n    '',\n    `**Workspace**: ${data.overview.workspace_path}`,\n    '',\n    '## Overview',\n    `- Total Memories: ${data.overview.total_memories}`,\n    `- Sessions: ${data.overview.total_sessions}`,\n    `- Important Memories (8): ${data.overview.important_count}`,\n    '',\n    '### Memories by Type',\n  ];\n\n  for (const [type, count] of Object.entries(data.overview.by_type)) {\n    if (count > 0) {\n      lines.push(`- ${type}: ${count}`);\n    }\n  }\n\n  lines.push('', '## Recent Activity Trends');\n  lines.push(`- Last 24 hours: ${data.trends.memories_last_24h} memories`);\n  lines.push(`- Last 7 days: ${data.trends.memories_last_7d} memories`);\n  lines.push(`- Last 30 days: ${data.trends.memories_last_30d} memories`);\n\n  if (data.trends.most_active_types_24h.length > 0) {\n    lines.push('', '### Most Active Types (24h)');\n    for (const { type, count } of data.trends.most_active_types_24h) {\n      lines.push(`- ${type}: ${count}`);\n    }\n  }\n\n  if (data.top_tags.length > 0) {\n    lines.push('', '## Top Tags');\n    for (const { tag, count } of data.top_tags) {\n      lines.push(`- ${tag}: ${count}`);\n    }\n  }\n\n  lines.push('', '## Importance Distribution');\n  lines.push(`- Critical (9-10): ${data.importance_distribution.critical}`);\n  lines.push(`- High (7-8): ${data.importance_distribution.high}`);\n  lines.push(`- Medium (5-6): ${data.importance_distribution.medium}`);\n  lines.push(`- Low (1-4): ${data.importance_distribution.low}`);\n\n  lines.push('', '## Activity Last 7 Days');\n  for (const activity of data.recent_activity) {\n    const typeSummary = Object.entries(activity.types)\n      .map(([type, count]) => `${type}:${count}`)\n      .join(', ');\n    lines.push(`- ${activity.date}: ${activity.count} memories ${typeSummary ? `(${typeSummary})` : ''}`);\n  }\n\n  return lines.join('\\n');\n}\n","import type { MemoryEntry } from '../types.js';\n\n/**\n * Format workspace context for Claude to read\n */\nexport function formatWorkspaceContext(\n  workspacePath: string,\n  directives: MemoryEntry[],\n  decisions: MemoryEntry[],\n  patterns: MemoryEntry[]\n): string {\n  const sections: string[] = [];\n\n  // Header\n  sections.push(`# Workspace Context: ${workspacePath}`);\n  sections.push('');\n  sections.push('*Critical information to remember for this project*');\n  sections.push('');\n\n  // Directives (sorted by importance)\n  if (directives.length > 0) {\n    sections.push('##  Critical Directives');\n    sections.push('');\n    const sorted = directives.sort((a, b) => b.importance - a.importance);\n    for (const dir of sorted.slice(0, 10)) {\n      sections.push(`- **[Importance: ${dir.importance}/10]** ${dir.content}`);\n      if (dir.tags.length > 0) {\n        sections.push(`  *Tags: ${dir.tags.join(', ')}*`);\n      }\n    }\n    sections.push('');\n  }\n\n  // Decisions (sorted by importance)\n  if (decisions.length > 0) {\n    sections.push('##  Key Decisions');\n    sections.push('');\n    const sorted = decisions.sort((a, b) => b.importance - a.importance);\n    for (const dec of sorted.slice(0, 8)) {\n      const age = getAgeString(dec.timestamp);\n      sections.push(`- **[${age}]** ${dec.content}`);\n    }\n    sections.push('');\n  }\n\n  // Code Patterns (sorted by importance)\n  if (patterns.length > 0) {\n    sections.push('##  Code Patterns & Conventions');\n    sections.push('');\n    const sorted = patterns.sort((a, b) => b.importance - a.importance);\n    for (const pat of sorted.slice(0, 8)) {\n      sections.push(`- ${pat.content}`);\n      if (pat.tags.length > 0) {\n        sections.push(`  *Applies to: ${pat.tags.join(', ')}*`);\n      }\n    }\n    sections.push('');\n  }\n\n  if (directives.length === 0 && decisions.length === 0 && patterns.length === 0) {\n    sections.push('*No critical context stored yet. As we work, I\\'ll remember important patterns and decisions.*');\n  }\n\n  sections.push('');\n  sections.push('---');\n  sections.push('*This context is automatically injected to help me remember important project conventions and decisions.*');\n\n  return sections.join('\\n');\n}\n\n/**\n * Format memories for concise display\n */\nexport function formatMemoriesCompact(memories: MemoryEntry[]): string {\n  if (memories.length === 0) {\n    return '*No relevant memories found*';\n  }\n\n  const lines: string[] = [];\n\n  for (const mem of memories) {\n    const age = getAgeString(mem.timestamp);\n    const importance = ''.repeat(Math.min(mem.importance, 5));\n    lines.push(`[${age}] ${importance} ${mem.summary || mem.content.substring(0, 80)}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Get human-readable age string\n */\nfunction getAgeString(timestamp: number): string {\n  const ageMs = Date.now() - timestamp;\n  const ageMinutes = Math.floor(ageMs / (1000 * 60));\n  const ageHours = Math.floor(ageMs / (1000 * 60 * 60));\n  const ageDays = Math.floor(ageMs / (1000 * 60 * 60 * 24));\n\n  if (ageDays > 0) {\n    return `${ageDays}d ago`;\n  } else if (ageHours > 0) {\n    return `${ageHours}h ago`;\n  } else if (ageMinutes > 0) {\n    return `${ageMinutes}m ago`;\n  } else {\n    return 'just now';\n  }\n}\n","import { MemoryStore } from '../redis/memory-store.js';\nimport { formatWorkspaceContext } from './formatters.js';\n\nconst memoryStore = new MemoryStore();\n\nexport const prompts = {\n  workspace_context: {\n    name: 'workspace_context',\n    description: 'Critical workspace context: directives, decisions, and code patterns',\n    arguments: [],\n    handler: async () => {\n      // Get important memories\n      const directives = await memoryStore.getMemoriesByType('directive');\n      const decisions = await memoryStore.getMemoriesByType('decision');\n      const patterns = await memoryStore.getMemoriesByType('code_pattern');\n\n      // Filter to high-importance only\n      const importantDirectives = directives.filter(d => d.importance >= 8);\n      const importantDecisions = decisions.filter(d => d.importance >= 7);\n      const importantPatterns = patterns.filter(p => p.importance >= 7);\n\n      // Get workspace path from memoryStore\n      const stats = await memoryStore.getSummaryStats();\n      const workspacePath = stats.workspace_path;\n\n      // Format for Claude\n      const contextText = formatWorkspaceContext(\n        workspacePath,\n        importantDirectives,\n        importantDecisions,\n        importantPatterns\n      );\n\n      return {\n        description: 'Workspace-specific context and conventions',\n        messages: [\n          {\n            role: 'user' as const,\n            content: {\n              type: 'text' as const,\n              text: contextText,\n            },\n          },\n        ],\n      };\n    },\n  },\n};\n\n// Export list for MCP server\nexport async function listPrompts() {\n  return Object.values(prompts).map(p => ({\n    name: p.name,\n    description: p.description,\n    arguments: p.arguments,\n  }));\n}\n\n// Export getter for MCP server\nexport async function getPrompt(name: string) {\n  const prompt = prompts[name as keyof typeof prompts];\n  if (!prompt) {\n    throw new Error(`Unknown prompt: ${name}`);\n  }\n\n  return await prompt.handler();\n}\n"],"mappings":"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","names":["z","McpError","ErrorCode","RelationshipType","globalData","wsData","query","z","query","z","ZodFirstPartyTypeKind","ZodFirstPartyTypeKind","ZodFirstPartyTypeKind","types","x","base","ZodFirstPartyTypeKind","zodToJsonSchema","name","schema","main","ErrorCode","McpError","memoryStore","zodToJsonSchema","McpError","ErrorCode","ErrorCode","McpError","memoryStore","zodToJsonSchema","McpError","ErrorCode","z","ErrorCode","McpError","memoryStore","zodToJsonSchema","McpError","ErrorCode","z","z","ErrorCode","McpError","memoryStore","zodToJsonSchema","McpError","ErrorCode","z","memoryStore","zodToJsonSchema","McpError","ErrorCode","z","zodToJsonSchemaInner","McpError","ErrorCode","memoryStore","McpError","ErrorCode","query","memoryStore"]}